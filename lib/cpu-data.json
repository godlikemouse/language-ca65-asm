{
  "thanks": "https://github.com/mist64/c64ref",
  "6502": {
    "info": {
      "manufacturer": "MOS",
      "name": "6502",
      "year": "1975",
      "id": "6502",
      "description": "This is the (bug-fixed, post June 1976 version of the) original implementation of the 6502 designed by MOS Technology, Inc. in 1975, and manufactured in the NMOS, HMOS or HMOS-2 technologies. All MOS/CSG 65xx/75xx/85xx CPUs, the Rockwell R6502, Synertek SY6502 and Pravetz CM630 CPUs as well as the Ricoh 2A03 and 2A07 chips in the NES are based on this implementation. 151 opcodes are documented, the remaining 105 have undocumented behavior."
    },
    "registers": {
      "registers": [
        "A",
        "X",
        "Y",
        "S",
        "P",
        "PC"
      ],
      "A": {
        "size": "8",
        "description": "Accumulator"
      },
      "X": {
        "size": "8",
        "description": "X Index Register"
      },
      "Y": {
        "size": "8",
        "description": "Y Index Register"
      },
      "S": {
        "size": "8",
        "description": "Stack Pointer"
      },
      "P": {
        "size": "8",
        "description": "Processor Status"
      },
      "PC": {
        "size": "16",
        "description": "Program Counter"
      }
    },
    "vectors": {
      "FFFA": "NMI",
      "FFFC": "RESET",
      "FFFE": "IRQ"
    },
    "flags": {
      "names": "NV-BDIZC",
      "N": "Negative",
      "V": "Overflow",
      "-": "(Expansion)",
      "B": "Break Command",
      "D": "Decimal",
      "I": "Interrupt Disable",
      "Z": "Zero",
      "C": "Carry"
    },
    "opcodes": [
      {
        "illegal": false,
        "mnemo": "BRK",
        "addmode": "-",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SLO",
        "addmode": "(a8,X)",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SLO",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHP",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ANC",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SLO",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BPL",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SLO",
        "addmode": "(a8),Y",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SLO",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLC",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SLO",
        "addmode": "a16,Y",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SLO",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JSR",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RLA",
        "addmode": "(a8,X)",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RLA",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PLP",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ANC",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RLA",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BMI",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RLA",
        "addmode": "(a8),Y",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RLA",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SEC",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RLA",
        "addmode": "a16,Y",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RLA",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RTI",
        "addmode": "-",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SRE",
        "addmode": "(a8,X)",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SRE",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHA",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ASR",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SRE",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BVC",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SRE",
        "addmode": "(a8),Y",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SRE",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLI",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SRE",
        "addmode": "a16,Y",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SRE",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RTS",
        "addmode": "-",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RRA",
        "addmode": "(a8,X)",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RRA",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PLA",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ARR",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "(a16)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RRA",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BVS",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RRA",
        "addmode": "(a8),Y",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RRA",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SEI",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RRA",
        "addmode": "a16,Y",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RRA",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SAX",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SAX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEY",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TXA",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "XAA",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SAX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BCC",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8),Y",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SHA",
        "addmode": "(a8),Y",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a8,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SAX",
        "addmode": "a8,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TYA",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16,Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TXS",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SHS",
        "addmode": "a16,Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SHY",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SHX",
        "addmode": "a16,Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SHA",
        "addmode": "a16,Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAX",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TAY",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TAX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAX",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BCS",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAX",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a8,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAX",
        "addmode": "a8,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLV",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "TSX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAS",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "LAX",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "DCP",
        "addmode": "(a8,X)",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "DCP",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INY",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SBX",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "DCP",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BNE",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "DCP",
        "addmode": "(a8),Y",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "DCP",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLD",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "DCP",
        "addmode": "a16,Y",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "DCP",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ISC",
        "addmode": "(a8,X)",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ISC",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SBC",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ISC",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BEQ",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ISC",
        "addmode": "(a8),Y",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ISC",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SED",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ISC",
        "addmode": "a16,Y",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ISC",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      }
    ],
    "operations": {
      "ADC": {
        "category": "arith",
        "flags": "NV----ZC",
        "description": "A + M + C → A, C",
        "documentation": {
          "title": "Add Memory to Accumulator with Carry",
          "text": [
            "This instruction adds the value of memory and carry from the previous operation to the value of the accumulator and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the carry flag when the sum of a binary add exceeds 255 or when the sum of a decimal add exceeds 99, otherwise carry is reset. The overflow flag is set when the sign or bit 7 is changed due to the result exceeding +127 or -128, otherwise overflow is reset. The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. The zero flag is set if the accumulator result is 0, otherwise the zero flag is reset.",
            "##PRIVATE##",
            "In decimal mode, the N, V and Z flags are not consistent with the decimal result."
          ]
        }
      },
      "AND": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ∧ M → A",
        "documentation": {
          "title": "\"AND\" Memory with Accumulator",
          "text": [
            "The AND instruction transfer the accumulator and memory to the adder which performs a bit-by-bit AND operation and stores the result back in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "ASL": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C ← /M7...M0/ ← 0",
        "documentation": {
          "title": "Arithmetic Shift Left",
          "text": [
            "The shift left instruction shifts either the accumulator or the address memory location 1 bit to the left, with the bit 0 always being set to 0 and the the input bit 7 being stored in the carry flag. ASL either shifts the accumulator left 1 bit or is a read/modify/write instruction that affects only memory.",
            "The instruction does not affect the overflow bit, sets N equal to the result bit 7 (bit 6 in the input), sets Z flag if the result is equal to 0, otherwise resets Z and stores the input bit 7 in the carry flag."
          ]
        }
      },
      "BCC": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on C = 0",
        "documentation": {
          "title": "Branch on Carry Clear",
          "text": [
            "This instruction tests the state of the carry bit and takes a conditional branch if the carry bit is reset.",
            "It affects no flags or registers other than the program counter and then only if the C flag is not on."
          ]
        }
      },
      "BCS": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on C = 1",
        "documentation": {
          "title": "Branch on Carry Set",
          "text": [
            "This instruction takes the conditional branch if the carry flag is on.",
            "BCS does not affect any of the flags or registers except for the program counter and only then if the carry flag is on."
          ]
        }
      },
      "BEQ": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on Z = 1",
        "documentation": {
          "title": "Branch on Result Zero",
          "text": [
            "This instruction could also be called \"Branch on Equal.\"",
            "It takes a conditional branch whenever the Z flag is on or the previ­ ous result is equal to 0.",
            "BEQ does not affect any of the flags or registers other than the program counter and only then when the Z flag is set."
          ]
        }
      },
      "BIT": {
        "category": "logic",
        "flags": "NV----Z-",
        "description": "A ∧ M, M7 → N, M6 → V",
        "documentation": {
          "title": "Test Bits in Memory with Accumulator",
          "text": [
            "This instruction performs an AND between a memory location and the accumulator but does not store the result of the AND into the accumulator.",
            "The bit instruction affects the N flag with N being set to the value of bit 7 of the memory being tested, the V flag with V being set equal to bit 6 of the memory being tested and Z being set by the result of the AND operation between the accumulator and the memory if the result is Zero, Z is reset otherwise. It does not affect the accumulator."
          ]
        }
      },
      "BMI": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on N = 1",
        "documentation": {
          "title": "Branch on Result Minus",
          "text": [
            "This instruction takes the conditional branch if the N bit is set.",
            "BMI does not affect any of the flags or any other part of the machine other than the program counter and then only if the N bit is on."
          ]
        }
      },
      "BNE": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on Z = 0",
        "documentation": {
          "title": "Branch on Result Not Zero",
          "text": [
            "This instruction could also be called \"Branch on Not Equal.\" It tests the Z flag and takes the conditional branch if the Z flag is not on, indicating that the previous result was not zero.",
            "BNE does not affect any of the flags or registers other than the program counter and only then if the Z flag is reset."
          ]
        }
      },
      "BPL": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on N = 0",
        "documentation": {
          "title": "Branch on Result Plus",
          "text": [
            "This instruction is the complementary branch to branch on result minus. It is a conditional branch which takes the branch when the N bit is reset (0). BPL is used to test if the previous result bit 7 was off (0) and branch on result minus is used to determine if the previous result was minus or bit 7 was on (1).",
            "The instruction affects no flags or other registers other than the P counter and only affects the P counter when the N bit is reset."
          ]
        }
      },
      "BRK": {
        "category": "ctrl",
        "flags": "-----1--",
        "description": "PC + 2↓, [FFFE] → PCL, [FFFF] → PCH",
        "documentation": {
          "title": "Break Command",
          "text": [
            "The break command causes the microprocessor to go through an inter­ rupt sequence under program control. This means that the program counter of the second byte after the BRK. is automatically stored on the stack along with the processor status at the beginning of the break instruction. The microprocessor then transfers control to the interrupt vector.",
            "Other than changing the program counter, the break instruction changes no values in either the registers or the flags.",
            "##PRIVATE##",
            "If an IRQ happens at the same time as a BRK instruction, the BRK instruction is ignored."
          ]
        }
      },
      "BVC": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on V = 0",
        "documentation": {
          "title": "Branch on Overflow Clear",
          "text": [
            "This instruction tests the status of the V flag and takes the conditional branch if the flag is not set.",
            "BVC does not affect any of the flags and registers other than the program counter and only when the overflow flag is reset."
          ]
        }
      },
      "BVS": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on V = 1",
        "documentation": {
          "title": "Branch on Overflow Set",
          "text": [
            "This instruction tests the V flag and takes the conditional branch if V is on.",
            "BVS does not affect any flags or registers other than the program, counter and only when the overflow flag is set."
          ]
        }
      },
      "CLC": {
        "category": "flags",
        "flags": "-------0",
        "description": "0 → C",
        "documentation": {
          "title": "Clear Carry Flag",
          "text": [
            "This instruction initializes the carry flag to a 0. This op­ eration should normally precede an ADC loop. It is also useful when used with a R0L instruction to clear a bit in memory.",
            "This instruction affects no registers in the microprocessor and no flags other than the carry flag which is reset."
          ]
        }
      },
      "CLD": {
        "category": "flags",
        "flags": "----0---",
        "description": "0 → D",
        "documentation": {
          "title": "Clear Decimal Mode",
          "text": [
            "This instruction sets the decimal mode flag to a 0. This all subsequent ADC and SBC instructions to operate as simple operations.",
            "CLD affects no registers in the microprocessor and no flags other than the decimal mode flag which is set to a 0.",
            "##PRIVATE##",
            "The value of the decimal mode flag is indeterminate after a RESET."
          ]
        }
      },
      "CLI": {
        "category": "flags",
        "flags": "-----0--",
        "description": "0 → I",
        "documentation": {
          "title": "Clear Interrupt Disable",
          "text": [
            "This instruction initializes the interrupt disable to a 0. This allows the microprocessor to receive interrupts.",
            "It affects no registers in the microprocessor and no flags other than the interrupt disable which is cleared."
          ]
        }
      },
      "CLV": {
        "category": "flags",
        "flags": "-0------",
        "description": "0 → V",
        "documentation": {
          "title": "Clear Overflow Flag",
          "text": [
            "This instruction clears the overflow flag to a 0. This com­ mand is used in conjunction with the set overflow pin which can change the state of the overflow flag with an external signal.",
            "CLV affects no registers in the microprocessor and no flags other than the overflow flag which is set to a 0."
          ]
        }
      },
      "CMP": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "A - M",
        "documentation": {
          "title": "Compare Memory and Accumulator",
          "text": [
            "This instruction subtracts the contents of memory from the contents of the accumulator.",
            "The use of the CMP affects the following flags: Z flag is set on an equal comparison, reset otherwise; the N flag is set or reset by the result bit 7, the carry flag is set when the value in memory is less than or equal to the accumulator, reset when it is greater than the accumulator. The accumulator is not affected."
          ]
        }
      },
      "CPX": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "X - M",
        "documentation": {
          "title": "Compare Index Register X To Memory",
          "text": [
            "This instruction subtracts the value of the addressed memory location from the content of index register X using the adder but does not store the result; therefore, its only use is to set the N, Z and C flags to allow for comparison between the index register X and the value in memory.",
            "The CPX instruction does not affect any register in the machine; it also does not affect the overflow flag. It causes the carry to be set on if the absolute value of the index register X is equal to or greater than the data from memory. If the value of the memory is greater than the content of the index register X, carry is reset. If the results of the subtraction contain a bit 7, then the N flag is set, if not, it is reset. If the value in memory is equal to the value in index register X, the Z flag is set, otherwise it is reset."
          ]
        }
      },
      "CPY": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "Y - M",
        "documentation": {
          "title": "Compare Index Register Y To Memory",
          "text": [
            "This instruction performs a two's complement subtraction between the index register Y and the specified memory location. The results of the subtraction are not stored anywhere. The instruction is strict­ly used to set the flags.",
            "CPY affects no registers in the microprocessor and also does not affect the overflow flag. If the value in the index register Y is equal to or greater than the value in the memory, the carry flag will be set, otherwise it will be cleared. If the results of the subtract- tion contain bit 7 on the N bit will be set, otherwise it will be cleared. If the value in the index register Y and the value in the memory are equal, the zero flag will be set, otherwise it will be cleared."
          ]
        }
      },
      "DEC": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "M - 1 → M",
        "documentation": {
          "title": "Decrement Memory By One",
          "text": [
            "This instruction subtracts 1, in two's complement, from the contents of the addressed memory location.",
            "The decrement instruction does not affect any internal register in the microprocessor. It does not affect the carry or overflow flags. If bit 7 is on as a result of the decrement, then the N flag is set, otherwise it is reset. If the result of the decrement is 0, the Z flag is set, other­wise it is reset."
          ]
        }
      },
      "DEX": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "X - 1 → X",
        "documentation": {
          "title": "Decrement Index Register X By One",
          "text": [
            "This instruction subtracts one from the current value of the index register X and stores the result in the index register X.",
            "DEX does not affect the carry or overflow flag, it sets the N flag if it has bit 7 on as a result of the decrement, otherwise it resets the N flag; sets the Z flag if X is a 0 as a result of the decrement, otherwise it resets the Z flag."
          ]
        }
      },
      "DEY": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "Y - 1 → Y",
        "documentation": {
          "title": "Decrement Index Register Y By One",
          "text": [
            "This instruction subtracts one from the current value in the in­ dex register Y and stores the result into the index register Y. The result does not affect or consider carry so that the value in the index register Y is decremented to 0 and then through 0 to FF.",
            "Decrement Y does not affect the carry or overflow flags; if the Y register contains bit 7 on as a result of the decrement the N flag is set, otherwise the N flag is reset. If the Y register is 0 as a result of the decrement, the Z flag is set otherwise the Z flag is reset. This instruction only affects the index register Y."
          ]
        }
      },
      "EOR": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ⊻ M → A",
        "documentation": {
          "title": "\"Exclusive OR\" Memory with Accumulator",
          "text": [
            "The EOR instruction transfers the memory and the accumulator to the adder which performs a binary \"EXCLUSIVE OR\" on a bit-by-bit basis and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "INC": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "M + 1 → M",
        "documentation": {
          "title": "Increment Memory By One",
          "text": [
            "This instruction adds 1 to the contents of the addressed memory loca­tion.",
            "The increment memory instruction does not affect any internal registers and does not affect the carry or overflow flags. If bit 7 is on as the result of the increment,N is set, otherwise it is reset; if the increment causes the result to become 0, the Z flag is set on, otherwise it is reset."
          ]
        }
      },
      "INX": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "X + 1 → X",
        "documentation": {
          "title": "Increment Index Register X By One",
          "text": [
            "Increment X adds 1 to the current value of the X register. This is an 8-bit increment which does not affect the carry operation, therefore, if the value of X before the increment was FF, the resulting value is 00.",
            "INX does not affect the carry or overflow flags; it sets the N flag if the result of the increment has a one in bit 7, otherwise resets N; sets the Z flag if the result of the increment is 0, otherwise it resets the Z flag.",
            "INX does not affect any other register other than the X register."
          ]
        }
      },
      "INY": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "Y + 1 → Y",
        "documentation": {
          "title": "Increment Index Register Y By One",
          "text": [
            "Increment Y increments or adds one to the current value in the Y register, storing the result in the Y register. As in the case of INX the primary application is to step thru a set of values using the Y register.",
            "The INY does not affect the carry or overflow flags, sets the N flag if the result of the increment has a one in bit 7, otherwise resets N, sets Z if as a result of the increment the Y register is zero otherwise resets the Z flag."
          ]
        }
      },
      "JMP": {
        "category": "ctrl",
        "flags": "--------",
        "description": "[PC + 1] → PCL, [PC + 2] → PCH",
        "documentation": {
          "title": "JMP Indirect",
          "text": [
            "This instruction establishes a new valne for the program counter.",
            "It affects only the program counter in the microprocessor and affects no flags in the status register."
          ]
        }
      },
      "JSR": {
        "category": "ctrl",
        "flags": "--------",
        "description": "PC + 2↓, [PC + 1] → PCL, [PC + 2] → PCH",
        "documentation": {
          "title": "Jump To Subroutine",
          "text": [
            "This instruction transfers control of the program counter to a subroutine location but leaves a return pointer on the stack to allow the user to return to perform the next instruction in the main program after the subroutine is complete. To accomplish this, JSR instruction stores the program counter address which points to the last byte of the jump instruc­ tion onto the stack using the stack pointer. The stack byte contains the program count high first, followed by program count low. The JSR then transfers the addresses following the jump instruction to the program counter low and the program counter high, thereby directing the program to begin at that new address.",
            "The JSR instruction affects no flags, causes the stack pointer to be decremented by 2 and substitutes new values into the program counter low and the program counter high."
          ]
        }
      },
      "LDA": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → A",
        "documentation": {
          "title": "Load Accumulator with Memory",
          "text": [
            "When instruction LDA is executed by the microprocessor, data is transferred from memory to the accumulator and stored in the accumulator.",
            "LDA affects the contents of the accumulator, does not affect the carry or overflow flags; sets the zero flag if the accumulator is zero as a result of the LDA, otherwise resets the zero flag; sets the negative flag if bit 7 of the accumulator is a 1, other­ wise resets the negative flag."
          ]
        }
      },
      "LDX": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → X",
        "documentation": {
          "title": "Load Index Register X From Memory",
          "text": [
            "Load the index register X from memory.",
            "LDX does not affect the C or V flags; sets Z if the value loaded was zero, otherwise resets it; sets N if the value loaded in bit 7 is a 1; otherwise N is reset, and affects only the X register."
          ]
        }
      },
      "LDY": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → Y",
        "documentation": {
          "title": "Load Index Register Y From Memory",
          "text": [
            "Load the index register Y from memory.",
            "LDY does not affect the C or V flags, sets the N flag if the value loaded in bit 7 is a 1, otherwise resets N, sets Z flag if the loaded value is zero otherwise resets Z and only affects the Y register."
          ]
        }
      },
      "LSR": {
        "category": "shift",
        "flags": "0-----ZC",
        "description": "0 → /M7...M0/ → C",
        "documentation": {
          "title": "Logical Shift Right",
          "text": [
            "This instruction shifts either the accumulator or a specified memory location 1 bit to the right, with the higher bit of the result always being set to 0, and the low bit which is shifted out of the field being stored in the carry flag.",
            "The shift right instruction either affects the accumulator by shift­ing it right 1 or is a read/modify/write instruction which changes a speci­fied memory location but does not affect any internal registers. The shift right does not affect the overflow flag. The N flag is always reset. The Z flag is set if the result of the shift is 0 and reset otherwise. The carry is set equal to bit 0 of the input."
          ]
        }
      },
      "NOP": {
        "category": "nop",
        "flags": "--------",
        "description": "No operation"
      },
      "ORA": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ∨ M → A",
        "documentation": {
          "title": "\"OR\" Memory with Accumulator",
          "text": [
            "The ORA instruction transfers the memory and the accumulator to the adder which performs a binary \"OR\" on a bit-by-bit basis and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "PHA": {
        "category": "stack",
        "flags": "--------",
        "description": "A↓",
        "documentation": {
          "title": "Push Accumulator On Stack",
          "text": [
            "This instruction transfers the current value of the accumulator to the next location on the stack, automatically decrementing the stack to point to the next empty location.",
            "The Push A instruction only affects the stack pointer register which is decremented by 1 as a result of the operation. It affects no flags."
          ]
        }
      },
      "PHP": {
        "category": "stack",
        "flags": "--------",
        "description": "P↓",
        "documentation": {
          "title": "Push Processor Status On Stack",
          "text": [
            "This instruction transfers the contents of the processor status reg­ ister unchanged to the stack, as governed by the stack pointer.",
            "The PHP instruction affects no registers or flags in the micropro­cessor."
          ]
        }
      },
      "PLA": {
        "category": "stack",
        "flags": "N-----Z-",
        "description": "A↑",
        "documentation": {
          "title": "Pull Accumulator From Stack",
          "text": [
            "This instruction adds 1 to the current value of the stack pointer and uses it to address the stack and loads the contents of the stack into the A register.",
            "The PLA instruction does not affect the carry or overflow flags. It sets N if the bit 7 is on in accumulator A as a result of instructions, otherwise it is reset. If accumulator A is zero as a result of the PLA, then the Z flag is set, otherwise it is reset. The PLA instruction changes content of the accumulator A to the contents of the memory location at stack register plus 1 and also increments the stack register."
          ]
        }
      },
      "PLP": {
        "category": "stack",
        "flags": "NV--DIZC",
        "description": "P↑",
        "documentation": {
          "title": "Pull Processor Status From Stack",
          "text": [
            "This instruction transfers the next value on the stack to the Proces­ sor Status register, thereby changing all of the flags and setting the mode switches to the values from the stack.",
            "The PLP instruction affects no registers in the processor other than the status register. This instruction could affect all flags in the status register."
          ]
        }
      },
      "ROL": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C ← /M7...M0/ ← C",
        "documentation": {
          "title": "Rotate Left",
          "text": [
            "The rotate left instruction shifts either the accumulator or addressed memory left 1 bit, with the input carry being stored in bit 0 and with the input bit 7 being stored in the carry flags.",
            "The ROL instruction either shifts the accumulator left 1 bit and stores the carry in accumulator bit 0 or does not affect the internal reg­isters at all. The ROL instruction sets carry equal to the input bit 7, sets N equal to the input bit 6 , sets the Z flag if the result of the ro­ tate is 0, otherwise it resets Z and does not affect the overflow flag at all."
          ]
        }
      },
      "ROR": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C → /M7...M0/ → C",
        "documentation": {
          "title": "Rotate Right",
          "text": [
            "The rotate right instruction shifts either the accumulator or addressed memory right 1 bit with bit 0 shifted into the carry and carry shifted into bit 7.",
            "The ROR instruction either shifts the accumulator right 1 bit and stores the carry in accumulator bit 7 or does not affect the internal regis­ ters at all. The ROR instruction sets carry equal to input bit 0, sets N equal to the input carry and sets the Z flag if the result of the rotate is 0; otherwise it resets Z and does not affect the overflow flag at all.",
            "(Available on Microprocessors after June, 1976)"
          ]
        }
      },
      "RTI": {
        "category": "ctrl",
        "flags": "NV--DIZC",
        "description": "P↑ PC↑",
        "documentation": {
          "title": "Return From Interrupt",
          "text": [
            "This instruction transfers from the stack into the microprocessor the processor status and the program counter location for the instruction which was interrupted. By virtue of the interrupt having stored this data before executing the instruction and thei fact that the RTI reinitializes the microprocessor to the same state as when it was interrupted, the combination of interrupt plus RTI allows truly reentrant coding.",
            "The RTI instruction reinitializes all flags to the position to the point they were at the time the interrupt was taken and sets the program counter back to its pre-interrupt state. It affects no other registers in the microprocessor."
          ]
        }
      },
      "RTS": {
        "category": "ctrl",
        "flags": "--------",
        "description": "PC↑, PC + 1 → PC",
        "documentation": {
          "title": "Return From Subroutme",
          "text": [
            "This instruction loads the program count low and program count high from the stack into the program counter and increments the program counter so that it points to the instruction following the JSR. The stack pointer is adjusted by incrementing it twice.",
            "The RTS instruction does not affect any flags and affects only PCL and PCH."
          ]
        }
      },
      "SBC": {
        "category": "arith",
        "flags": "NV----ZC",
        "description": "A - M - ~C → A",
        "documentation": {
          "title": "Subtract Memory from Accumulator with Borrow",
          "text": [
            "This instruction subtracts the value of memory and borrow from the value of the accumulator, using two's complement arithmetic, and stores the result in the accumulator. Borrow is defined as the carry flag complemented; therefore, a resultant carry flag indicates that a borrow has not occurred.",
            "This instruction affects the accumulator. The carry flag is set if the result is greater than or equal to 0. The carry flag is reset when the result is less than 0, indicating a borrow. The over­flow flag is set when the result exceeds +127 or -127, otherwise it is reset. The negative flag is set if the result in the accumulator has bit 7 on, otherwise it is reset. The Z flag is set if the result in the accumulator is 0, otherwise it is reset.",
            "##PRIVATE##",
            "In decimal mode, the N, V and Z flags are not consistent with the decimal result."
          ]
        }
      },
      "SEC": {
        "category": "flags",
        "flags": "-------1",
        "description": "1 → C",
        "documentation": {
          "title": "Set Carry Flag",
          "text": [
            "This instruction initializes the carry flag to a 1. This op eration should normally precede a SBC loop. It is also useful when used with a ROL instruction to initialize a bit in memory to a 1.",
            "This instruction affects no registers in the microprocessor and no flags other than the carry flag which is set."
          ]
        }
      },
      "SED": {
        "category": "flags",
        "flags": "----1---",
        "description": "1 → D",
        "documentation": {
          "title": "Set Decimal Mode",
          "text": [
            "This instruction sets the decimal mode flag D to a 1. This makes all subsequent ADC and SBC instructions operate as a decimal arithmetic operation.",
            "SED affects no registers in the microprocessor and no flags other than the decimal mode which is set to a 1.",
            "##PRIVATE##",
            "The value of the decimal mode flag is indeterminate after a RESET."
          ]
        }
      },
      "SEI": {
        "category": "flags",
        "flags": "-----1--",
        "description": "1 → I",
        "documentation": {
          "title": "Set Interrupt Disable",
          "text": [
            "This instruction initializes the interrupt disable to a 1. It is used to mask interrupt requests during system reset operations and during interrupt commands.",
            "It affects no registers in the microprocessor and no flags other than the interrupt disable which is set."
          ]
        }
      },
      "STA": {
        "category": "load",
        "flags": "--------",
        "description": "A → M",
        "documentation": {
          "title": "Store Accumulator in Memory",
          "text": [
            "This instruction transfers the contents of the accumulator to memory.",
            "This instruction affects none of the flags in the processor status register and does not affect the accumulator."
          ]
        }
      },
      "STX": {
        "category": "load",
        "flags": "--------",
        "description": "X → M",
        "documentation": {
          "title": "Store Index Register X In Memory",
          "text": [
            "Transfers value of X register to addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "STY": {
        "category": "load",
        "flags": "--------",
        "description": "Y → M",
        "documentation": {
          "title": "Store Index Register Y In Memory",
          "text": [
            "Transfer the value of the Y register to the addressed memory location.",
            "STY does not affect any flags or registers in the microprocessor."
          ]
        }
      },
      "TAX": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "A → X",
        "documentation": {
          "title": "Transfer Accumulator To Index X",
          "text": [
            "This instruction takes the value from accumulator A and trans­ fers or loads it into the index register X without disturbing the content of the accumulator A.",
            "TAX only affects the index register X, does not affect the carry or overflow flags. The N flag is set if the resultant value in the index register X has bit 7 on, otherwise N is reset. The Z bit is set if the content of the register X is 0 as aresult of theopera­ tion, otherwise it is reset."
          ]
        }
      },
      "TAY": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "A → Y",
        "documentation": {
          "title": "Transfer Accumula Tor To Index Y",
          "text": [
            "This instruction moves the value of the accumulator into index register Y without affecting the accumulator.",
            "TAY instruction only affects the Y register and does not affect either the carry or overflow flags. If the index register Y has bit 7 on, then N is set, otherwise it is reset. If the content of the index register Y equals 0 as a result of the operation, Z is set on, otherwise it is reset."
          ]
        }
      },
      "TSX": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "S → X",
        "documentation": {
          "title": "Transfer Stack Pointer To Index X",
          "text": [
            "This instruction transfers the value in the stack pointer to the index register X.",
            "TSX does not affect the carry or overflow flags. It sets N if bit 7 is on in index X as a result of the instruction, otherwise it is reset. If index X is zero as a result of the TSX, the Z flag is set, other­ wise it is reset. TSX changes the value of index X, making it equal to the content of the stack pointer."
          ]
        }
      },
      "TXA": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "X → A",
        "documentation": {
          "title": "Transfer Index X To Accumulator",
          "text": [
            "This instruction moves the value that is in the index register X to the accumulator A without disturbing the content of the index register X.",
            "TXA does not affect any register other than the accumula­tor and does not affect the carry or overflow flag. If the result in A has bit 7 on, then the N flag is set, otherwise it is reset. If the resultant value in the accumulator is 0, then the Z flag is set, other­ wise it is reset."
          ]
        }
      },
      "TXS": {
        "category": "trans",
        "flags": "--------",
        "description": "X → S",
        "documentation": {
          "title": "Transfer Index X To Stack Pointer",
          "text": [
            "This instruction transfers the value in the index register X to the stack pointer.",
            "TXS changes only the stack pointer, making it equal to the content of the index register X. It does not affect any of the flags."
          ]
        }
      },
      "TYA": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "Y → A",
        "documentation": {
          "title": "Transfer Index Y To Accumulator",
          "text": [
            "This instruction moves the value that is in the index register Y to accumulator A without disturbing the content of the register Y.",
            "TYA does not affect any other register other than the accumula­ tor and does not affect the carry or overflow flag. If the result in the accumulator A has bit 7 on, the N flag is set, otherwise it is reset. If the resultant value in the accumulator A is 0, then the Z flag is set, otherwise it is reset."
          ]
        }
      },
      "#": {
        "category": "mnemos",
        "flags": "are",
        "description": "based on VICE"
      },
      "ANC": {
        "category": "arith",
        "flags": "*-----**",
        "description": "A ∧ M → A, N → C",
        "documentation": {
          "title": "\"AND\" Memory with Accumulator then Move Negative Flag to Carry Flag",
          "text": [
            "The undocumented ANC instruction performs a bit-by-bit AND operation of the accumulator and memory and stores the result back in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag and the carry flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag and the carry flag."
          ]
        }
      },
      "ARR": {
        "category": "arith",
        "flags": "**----**",
        "description": "(A ∧ M) / 2 → A",
        "documentation": {
          "title": "\"AND\" Accumulator then Rotate Right",
          "text": [
            "The undocumented ARR instruction performs a bit-by-bit \"AND\" operation of the accumulator and memory, then shifts the result right 1 bit with bit 0 shifted into the carry and carry shifted into bit 7. It then stores the result back in the accumulator.",
            "If bit 7 of the result is on, then the N flag is set, otherwise it is reset. The instruction sets the Z flag if the result is 0; otherwise it resets Z.",
            "The V and C flags depends on the Decimal Mode Flag:",
            "In decimal mode, the V flag is set if bit 6 is different than the original data's bit 6, otherwise the V flag is reset. The C flag is set if (operand & 0xF0) + (operand & 0x10) is greater than 0x50, otherwise the C flag is reset.",
            "In binary mode, the V flag is set if bit 6 of the result is different than bit 5 of the result, otherwise the V flag is reset. The C flag is set if the result in the accumulator has bit 6 on, otherwise it is reset."
          ]
        }
      },
      "ASR": {
        "category": "arith",
        "flags": "0-----**",
        "description": "(A ∧ M) / 2 → A",
        "documentation": {
          "title": "\"AND\" then Logical Shift Right",
          "text": [
            "The undocumented ASR instruction performs a bit-by-bit AND operation of the accumulator and memory, then shifts the accumulator 1 bit to the right, with the higher bit of the result always being set to 0, and the low bit which is shifted out of the field being stored in the carry flag.",
            "This instruction affects the accumulator. It does not affect the overflow flag. The N flag is always reset. The Z flag is set if the result of the shift is 0 and reset otherwise. The carry is set equal to bit 0 of the result of the \"AND\" operation."
          ]
        }
      },
      "DCP": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M - 1 → M, A - M",
        "documentation": {
          "title": "Decrement Memory By One then Compare with Accumulator",
          "text": [
            "This undocumented instruction subtracts 1, in two's complement, from the contents of the addressed memory location. It then subtracts the contents of memory from the contents of the accumulator.",
            "The DCP instruction does not affect any internal register in the microprocessor. It does not affect the overflow flag. Z flag is set on an equal comparison, reset otherwise; the N flag is set or reset by the result bit 7, the carry flag is set when the result in memory is less than or equal to the accumulator, reset when it is greater than the accumulator."
          ]
        }
      },
      "ISC": {
        "category": "arith",
        "flags": "**----**",
        "description": "M + 1 → M, A - M → A",
        "documentation": {
          "title": "Increment Memory By One then SBC then Subtract Memory from Accumulator with Borrow",
          "text": [
            "This undocumented instruction adds 1 to the contents of the addressed memory loca­tion. It then subtracts the value of the result in memory and borrow from the value of the accumulator, using two's complement arithmetic, and stores the result in the accumulator.",
            "This instruction affects the accumulator. The carry flag is set if the result is greater than or equal to 0. The carry flag is reset when the result is less than 0, indicating a borrow. The over­flow flag is set when the result exceeds +127 or -127, otherwise it is reset. The negative flag is set if the result in the accumulator has bit 7 on, otherwise it is reset. The Z flag is set if the result in the accumulator is 0, otherwise it is reset."
          ]
        }
      },
      "JAM": {
        "category": "kil",
        "flags": "--------",
        "description": "Stop execution",
        "documentation": {
          "title": "Halt the CPU",
          "text": [
            "This undocumented instruction stops execution. The microprocessor will not fetch further instructions, and will neither handle IRQs nor NMIs. It will handle a RESET though."
          ]
        }
      },
      "LAS": {
        "category": "load",
        "flags": "*-----*-",
        "description": "M ∧ S → A, X, S",
        "documentation": {
          "title": "\"AND\" Memory with Stack Pointer",
          "text": [
            "This undocumented instruction performs a bit-by-bit \"AND\" operation of the stack pointer and memory and stores the result back in the accumulator, the index register X and the stack pointer.",
            "The LAS instruction does not affect the carry or overflow flags. It sets N if the bit 7 of the result is on, otherwise it is reset. If the result is zero, then the Z flag is set, otherwise it is reset."
          ]
        }
      },
      "LAX": {
        "category": "load",
        "flags": "*-----*-",
        "description": "M → A, X",
        "documentation": {
          "title": "Load Accumulator and Index Register X From Memory",
          "text": [
            "The undocumented LAX instruction loads the accumulator and the index register X from memory.",
            "LAX does not affect the C or V flags; sets Z if the value loaded was zero, otherwise resets it; sets N if the value loaded in bit 7 is a 1; otherwise N is reset, and affects only the X register."
          ]
        }
      },
      "RLA": {
        "category": "arith",
        "flags": "*-----**",
        "description": "C ← /M7...M0/ ← C, A ∧ M → A",
        "documentation": {
          "title": "Rotate Left then \"AND\" with Accumulator",
          "text": [
            "The undocumented RLA instruction shifts the addressed memory left 1 bit, with the input carry being stored in bit 0 and with the input bit 7 being stored in the carry flags. It then performs a bit-by-bit AND operation of the result and the value of the accumulator and stores the result back in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "RRA": {
        "category": "arith",
        "flags": "**----**",
        "description": "C → /M7...M0/ → C, A + M + C → A",
        "documentation": {
          "title": "Rotate Right and Add Memory to Accumulator",
          "text": [
            "The undocumented RRA instruction shifts the addressed memory right 1 bit with bit 0 shifted into the carry and carry shifted into bit 7. It then adds the result and generated carry to the value of the accumulator and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the carry flag when the sum of a binary add exceeds 255 or when the sum of a decimal add exceeds 99, otherwise carry is reset. The overflow flag is set when the sign or bit 7 is changed due to the result exceeding +127 or -128, otherwise overflow is reset. The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. The zero flag is set if the accumulator result is 0, otherwise the zero flag is reset."
          ]
        }
      },
      "SAX": {
        "category": "load",
        "flags": "--------",
        "description": "A ∧ X → M",
        "documentation": {
          "title": "Store Accumulator \"AND\" Index Register X in Memory",
          "text": [
            "The undocumented SAX instruction performs a bit-by-bit AND operation of the value of the accumulator and the value of the index register X and stores the result in memory.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SBX": {
        "category": "arith",
        "flags": "*-----**",
        "description": "(A ∧ X) - M → X",
        "documentation": {
          "title": "Subtract Memory from Accumulator \"AND\" Index Register X",
          "text": [
            "This undocumented instruction performs a bit-by-bit \"AND\" of the value of the accumulator and the index register X and subtracts the value of memory from this result, using two's complement arithmetic, and stores the result in the index register X.",
            "This instruction affects the index register X. The carry flag is set if the result is greater than or equal to 0. The carry flag is reset when the result is less than 0, indicating a borrow. The negative flag is set if the result in index register X has bit 7 on, otherwise it is reset. The Z flag is set if the result in index register X is 0, otherwise it is reset. The over­flow flag not affected at all."
          ]
        }
      },
      "SHA": {
        "category": "load",
        "flags": "--------",
        "description": "A ∧ X ∧ V → M",
        "documentation": {
          "title": "Store Accumulator \"AND\" Index Register X \"AND\" Value",
          "text": [
            "The undocumented SHA instruction performs a bit-by-bit AND operation of the following three operands: The first two are the accumulator and the index register X.",
            "The third operand depends on the addressing mode. In the zero page indirect Y-indexed case, the third operand is the data in memory at the given zero page address (ignoring the the addressing mode's Y offset) plus 1. In the Y-indexed absolute case, it is the upper 8 bits of the given address (ignoring the the addressing mode's Y offset), plus 1.",
            "It then transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SHS": {
        "category": "trans",
        "flags": "--------",
        "description": "A ∧ X → S, S ∧ (H + 1) → M",
        "documentation": {
          "title": "Transfer Accumulator \"AND\" Index Register X to Stack Pointer then Store Stack Pointer \"AND\" Hi-Byte In Memory",
          "text": [
            "The undocumented SHS instruction performs a bit-by-bit AND operation of the value of the accumulator and the value of the index register X and stores the result in the stack pointer. It then performs a bit-by-bit AND operation of the resulting stack pointer and the upper 8 bits of the given address (ignoring the addressing mode's Y offset), plus 1, and transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SHX": {
        "category": "load",
        "flags": "--------",
        "description": "X ∧ (H + 1) → M",
        "documentation": {
          "title": "Store Index Register X \"AND\" Value",
          "text": [
            "The undocumented SHX instruction performs a bit-by-bit AND operation of the index register X and the upper 8 bits of the given address (ignoring the the addressing mode's Y offset), plus 1. It then transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SHY": {
        "category": "load",
        "flags": "--------",
        "description": "Y ∧ (H + 1) → M",
        "documentation": {
          "title": "Store Index Register Y \"AND\" Value",
          "text": [
            "The undocumented SHY instruction performs a bit-by-bit AND operation of the index register Y and the upper 8 bits of the given address (ignoring the the addressing mode's X offset), plus 1. It then transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SLO": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M * 2 → M, A ∨ M → A",
        "documentation": {
          "title": "Arithmetic Shift Left then \"OR\" Memory with Accumulator",
          "text": [
            "The undocumented SLO instruction shifts the address memory location 1 bit to the left, with the bit 0 always being set to 0 and the bit 7 output always being contained in the carry flag. It then performs a bit-by-bit \"OR\" operation on the result and the accumulator and stores the result in the accumulator.",
            "The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. It sets Z flag if the result is equal to 0, otherwise resets Z and stores the input bit 7 in the carry flag."
          ]
        }
      },
      "SRE": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M / 2 → M, A ⊻ M → A",
        "documentation": {
          "title": "Logical Shift Right then \"Exclusive OR\" Memory with Accumulator",
          "text": [
            "The undocumented SRE instruction shifts the specified memory location 1 bit to the right, with the higher bit of the result always being set to 0, and the low bit which is shifted out of the field being stored in the carry flag. It then performs a bit-by-bit \"EXCLUSIVE OR\" of the result and the value of the accumulator and stores the result in the accumulator.",
            "This instruction affects the accumulator. It does not affect the overflow flag. The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. The Z flag is set if the result is 0 and reset otherwise. The carry is set equal to input bit 0."
          ]
        }
      },
      "XAA": {
        "category": "arith",
        "flags": "*-----*-",
        "description": "(A ∨ V) ∧ X ∧ M → A",
        "documentation": {
          "title": "Non-deterministic Operation of Accumulator, Index Register X, Memory and Bus Contents",
          "text": [
            "The operation of the undocumented XAA instruction depends on the individual microprocessor. On most machines, it performs a bit-by-bit AND operation of the following three operands: The first two are the index register X and memory.",
            "The third operand is the result of a bit-by-bit AND operation of the accumulator and a magic component. This magic component depends on the individual microprocessor and is usually one of $00, $EE, $EF, $FE and $FF, and may be influenced by the RDY pin, leftover contents of the data bus, the temperature of the microprocessor, the supplied voltage, and other factors.",
            "On some machines, additional bits of the result may be set or reset depending on non-deterministic factors.",
            "It then transfers the result to the accumulator.",
            "XAA does not affect the C or V flags; sets Z if the value loaded was zero, otherwise resets it; sets N if the result in bit 7 is a 1; otherwise N is reset."
          ]
        }
      }
    },
    "mnemos": {
      "ADC": {
        "description": "Add with Carry"
      },
      "AND": {
        "description": "Logical AND"
      },
      "ASL": {
        "description": "Arithmetic Shift Left"
      },
      "BCC": {
        "description": "Branch if Carry Clear"
      },
      "BCS": {
        "description": "Branch if Carry Set"
      },
      "BEQ": {
        "description": "Branch if Equal"
      },
      "BIT": {
        "description": "Bit Test"
      },
      "BMI": {
        "description": "Branch if Minus"
      },
      "BNE": {
        "description": "Branch if Not Equal"
      },
      "BPL": {
        "description": "Branch if Plus"
      },
      "BRK": {
        "description": "Force Interrupt"
      },
      "BVC": {
        "description": "Branch if Overflow Clear"
      },
      "BVS": {
        "description": "Branch if Overflow Set"
      },
      "CLC": {
        "description": "Clear Carry Flag"
      },
      "CLD": {
        "description": "Clear Decimal Mode"
      },
      "CLI": {
        "description": "Clear Interrupt Disable"
      },
      "CLV": {
        "description": "Clear Overflow Flag"
      },
      "CMP": {
        "description": "Compare"
      },
      "CPX": {
        "description": "Compare X Register"
      },
      "CPY": {
        "description": "Compare Y Register"
      },
      "DEC": {
        "description": "Decrement Memory"
      },
      "DEX": {
        "description": "Decrement X Register"
      },
      "DEY": {
        "description": "Decrement Y Register"
      },
      "EOR": {
        "description": "Exclusive OR"
      },
      "INC": {
        "description": "Increment Memory"
      },
      "INX": {
        "description": "Increment X Register"
      },
      "INY": {
        "description": "Increment Y Register"
      },
      "JMP": {
        "description": "Jump"
      },
      "JSR": {
        "description": "Jump to Subroutine"
      },
      "LDA": {
        "description": "Load Accumulator"
      },
      "LDX": {
        "description": "Load X Register"
      },
      "LDY": {
        "description": "Load Y Register"
      },
      "LSR": {
        "description": "Logical Shift Right"
      },
      "NOP": {
        "description": "No Operation"
      },
      "ORA": {
        "description": "Logical OR"
      },
      "PHA": {
        "description": "Push Accumulator"
      },
      "PHP": {
        "description": "Push Processor Status"
      },
      "PLA": {
        "description": "Pull Accumulator"
      },
      "PLP": {
        "description": "Pull Processor Status"
      },
      "ROL": {
        "description": "Rotate Left"
      },
      "ROR": {
        "description": "Rotate Right"
      },
      "RTI": {
        "description": "Return from Interrupt"
      },
      "RTS": {
        "description": "Return from Subroutine"
      },
      "SBC": {
        "description": "Subtract with Carry"
      },
      "SEC": {
        "description": "Set Carry Flag"
      },
      "SED": {
        "description": "Set Decimal Flag"
      },
      "SEI": {
        "description": "Set Interrupt Disable"
      },
      "STA": {
        "description": "Store Accumulator"
      },
      "STX": {
        "description": "Store X Register"
      },
      "STY": {
        "description": "Store Y Register"
      },
      "TAX": {
        "description": "Transfer Accumulator to X"
      },
      "TAY": {
        "description": "Transfer Accumulator to Y"
      },
      "TSX": {
        "description": "Transfer Stack Pointer to X"
      },
      "TXA": {
        "description": "Transfer X to Accumulator"
      },
      "TXS": {
        "description": "Transfer X to Stack Pointer"
      },
      "TYA": {
        "description": "Transfer Y to Accumulator"
      }
    },
    "addmodes": {
      "-": {
        "bytes": "1",
        "syntax": "",
        "description": "Implied",
        "documentation": {
          "title": "Implied",
          "text": [
            "In the implied addressing mode, the address containing the operand is implicitly stated in the operation code of the instruction."
          ]
        }
      },
      "A": {
        "bytes": "1",
        "syntax": "A",
        "description": "Accumulator",
        "documentation": {
          "title": "Accumulator",
          "text": [
            "This form of addressing is represented with a one byte instruction, implying an operation on the accumulator."
          ]
        }
      },
      "#d8": {
        "bytes": "2",
        "syntax": "#$nn",
        "description": "Immediate",
        "documentation": {
          "title": "Immediate",
          "text": [
            "In immediate addressing, the operand is contained in the second byte of the instruction, with no further memory addressing required."
          ]
        }
      },
      "a8": {
        "bytes": "2",
        "syntax": "$nn",
        "description": "Zero Page",
        "documentation": {
          "title": "Zero Page",
          "text": [
            "The zero page instructions allow for shorter code and execution times by only fetching the second byte of the instruction and assuming a zero high address byte. Careful use of the zero page can result in significant increase in code efficiency."
          ]
        }
      },
      "a8,X": {
        "bytes": "2",
        "syntax": "$nn,X",
        "description": "X-Indexed Zero Page",
        "documentation": {
          "title": "X-Indexed Zero Page",
          "text": [
            "This form of addressing is used in conjunction with the X index register. The effective address is calculated by adding the second byte to the contents of the index register. Since this is a form of \"Zero Page\" addressing, the content of the second byte references a location in page zero. Additionally, due to the “Zero Page\" addressing nature of this mode, no carry is added to the high order 8 bits of memory and crossing of page boundaries does not occur."
          ]
        }
      },
      "a8,Y": {
        "bytes": "2",
        "syntax": "$nn,Y",
        "description": "Y-Indexed Zero Page",
        "documentation": {
          "title": "Y-Indexed Zero Page",
          "text": [
            "This form of addressing is used in conjunction with the Y index register. The effective address is calculated by adding the second byte to the contents of the index register. Since this is a form of \"Zero Page\" addressing, the content of the second byte references a location in page zero. Additionally, due to the “Zero Page\" addressing nature of this mode, no carry is added to the high order 8 bits of memory and crossing of page boundaries does not occur."
          ]
        }
      },
      "(a8,X)": {
        "bytes": "2",
        "syntax": "($nn,X)",
        "description": "X-Indexed Zero Page Indirect",
        "documentation": {
          "title": "X-Indexed Zero Page Indirect",
          "text": [
            "In indexed indirect addressing, the second byte of the instruction is added to the contents of the X index register, discarding the carry. The result of this addition points to a memory location on page zero whose contents is the low order eight bits of the effective address. The next memory location in page zero contains the high order eight bits of the effective address. Both memory locations specifying the high and low order bytes of the effective address must be in page zero."
          ]
        }
      },
      "(a8),Y": {
        "bytes": "2",
        "syntax": "($nn),Y",
        "description": "Zero Page Indirect Y-Indexed",
        "documentation": {
          "title": "Zero Page Indirect Y-Indexed",
          "text": [
            "In indirect indexed addressing, the second byte of the instruction points to a memory location in page zero. The contents of this memory location is added to the contents of the Y index register, the result being the low order eight bits of the effective address. The carry from this addition is added to the contents of the next page zero memory location, the result being the high order eight bits of the effective address."
          ]
        }
      },
      "a16": {
        "bytes": "3",
        "syntax": "$nnnn",
        "description": "Absolute",
        "documentation": {
          "title": "Absolute",
          "text": [
            "In absolute addressing, the second byte of the instruction specifies the eight low order bits of the effective address while the third byte specifies the eight high order bits. Thus, the absolute addressing mode allows access to the entire 65 K bytes of addressable memory."
          ]
        }
      },
      "a16,X": {
        "bytes": "3",
        "syntax": "$nnnn,X",
        "description": "X-Indexed Absolute",
        "documentation": {
          "title": "X-Indexed Absolute",
          "text": [
            "This form of addressing is used in conjunction with the X index register. The effective address is formed by adding the contents of X to the address contained in the second and third bytes of the instruction. This mode allows the index register to contain the index or count value and the instruction to contain the base address. This type of indexing allows any location referencing and the index to modify multiple fields resulting in reduced coding and execution time.",
            "##PRIVATE##",
            "The value at the specified address, ignoring the the addressing mode's X offset, is read (and discarded) before the final address is read. This may cause side effects in I/O registers."
          ]
        }
      },
      "a16,Y": {
        "bytes": "3",
        "syntax": "$nnnn,Y",
        "description": "Y-Indexed Absolute",
        "documentation": {
          "title": "Y-Indexed Absolute",
          "text": [
            "This form of addressing is used in conjunction with the Y index register. The effective address is formed by adding the contents of Y to the address contained in the second and third bytes of the instruction. This mode allows the index register to contain the index or count value and the instruction to contain the base address. This type of indexing allows any location referencing and the index to modify multiple fields resulting in reduced coding and execution time.",
            "##PRIVATE##",
            "The value at the specified address, ignoring the the addressing mode's Y offset, is read (and discarded) before the final address is read. This may cause side effects in I/O registers."
          ]
        }
      },
      "(a16)": {
        "bytes": "3",
        "syntax": "($nnnn)",
        "description": "Absolute Indirect",
        "documentation": {
          "title": "Absolute Indirect",
          "text": [
            "The second byte of the instruction contains the low order eight bits of a memory location. The high order eight bits of that memory location is contained in the third byte of the instruction. The contents of the fully specified memory location is the low order byte of the effective address. The next memory location contains the high order byte of the effective address which is loaded into the sixteen bits of the program counter.",
            "##PRIVATE##",
            "The indirect jump instruction does not increment the page address when the indirect pointer crosses a page boundary. JMP ($xxFF) will fetch the address from $xxFF and $xx00."
          ]
        }
      },
      "r8": {
        "bytes": "2",
        "syntax": "$nnnn",
        "description": "Relative",
        "documentation": {
          "title": "Relative",
          "text": [
            "Relative addressing is used only with branch instructions and establishes a destination for the conditional branch.",
            "The second byte of-the instruction becomes the operand which is an “Offset\" added to the contents of the lower eight bits of the program counter when the counter is set at the next instruction. The range of the offset is —128 to +127 bytes from the next instruction."
          ]
        }
      }
    },
    "all_mnemos": {
      "regular": [
        "ADC",
        "AND",
        "ASL",
        "BCC",
        "BCS",
        "BEQ",
        "BIT",
        "BMI",
        "BNE",
        "BPL",
        "BRK",
        "BVC",
        "BVS",
        "CLC",
        "CLD",
        "CLI",
        "CLV",
        "CMP",
        "CPX",
        "CPY",
        "DEC",
        "DEX",
        "DEY",
        "EOR",
        "INC",
        "INX",
        "INY",
        "JMP",
        "JSR",
        "LDA",
        "LDX",
        "LDY",
        "LSR",
        "NOP",
        "ORA",
        "PHA",
        "PHP",
        "PLA",
        "PLP",
        "ROL",
        "ROR",
        "RTI",
        "RTS",
        "SBC",
        "SEC",
        "SED",
        "SEI",
        "STA",
        "STX",
        "STY",
        "TAX",
        "TAY",
        "TSX",
        "TXA",
        "TXS",
        "TYA"
      ],
      "illegal": [
        "ANC",
        "ARR",
        "ASR",
        "DCP",
        "ISC",
        "JAM",
        "LAS",
        "LAX",
        "NOP",
        "RLA",
        "RRA",
        "SAX",
        "SBC",
        "SBX",
        "SHA",
        "SHS",
        "SHX",
        "SHY",
        "SLO",
        "SRE",
        "XAA"
      ],
      "all": [
        "ADC",
        "ANC",
        "AND",
        "ARR",
        "ASL",
        "ASR",
        "BCC",
        "BCS",
        "BEQ",
        "BIT",
        "BMI",
        "BNE",
        "BPL",
        "BRK",
        "BVC",
        "BVS",
        "CLC",
        "CLD",
        "CLI",
        "CLV",
        "CMP",
        "CPX",
        "CPY",
        "DCP",
        "DEC",
        "DEX",
        "DEY",
        "EOR",
        "INC",
        "INX",
        "INY",
        "ISC",
        "JAM",
        "JMP",
        "JSR",
        "LAS",
        "LAX",
        "LDA",
        "LDX",
        "LDY",
        "LSR",
        "NOP",
        "ORA",
        "PHA",
        "PHP",
        "PLA",
        "PLP",
        "RLA",
        "ROL",
        "ROR",
        "RRA",
        "RTI",
        "RTS",
        "SAX",
        "SBC",
        "SBX",
        "SEC",
        "SED",
        "SEI",
        "SHA",
        "SHS",
        "SHX",
        "SHY",
        "SLO",
        "SRE",
        "STA",
        "STX",
        "STY",
        "TAX",
        "TAY",
        "TSX",
        "TXA",
        "TXS",
        "TYA",
        "XAA"
      ]
    },
    "all_addmodes": {
      "regular": [
        "-",
        "A",
        "#d8",
        "a16",
        "a16,X",
        "a16,Y",
        "(a16)",
        "a8",
        "a8,X",
        "a8,Y",
        "(a8,X)",
        "(a8),Y",
        "r8"
      ],
      "illegal": [
        "-",
        "#d8",
        "a16",
        "a16,X",
        "a16,Y",
        "a8",
        "a8,X",
        "a8,Y",
        "(a8,X)",
        "(a8),Y"
      ],
      "all": [
        "-",
        "A",
        "#d8",
        "a16",
        "a16,X",
        "a16,Y",
        "(a16)",
        "a8",
        "a8,X",
        "a8,Y",
        "(a8,X)",
        "(a8),Y",
        "r8"
      ]
    }
  },
  "6502rorbug": {
    "info": {
      "manufacturer": "MOS",
      "name": "6502",
      "revision": "without ROR",
      "year": "1975",
      "id": "6502rorbug",
      "basedon": "6502",
      "description": "This is the pre June 1976 version of the original implementation of the 6502 designed by MOS Technology, Inc. This version does not have the ROR instruction; the respective opcodes behave differently due to a bug in the mask."
    },
    "registers": {
      "registers": [
        "A",
        "X",
        "Y",
        "S",
        "P",
        "PC"
      ],
      "A": {
        "size": "8",
        "description": "Accumulator"
      },
      "X": {
        "size": "8",
        "description": "X Index Register"
      },
      "Y": {
        "size": "8",
        "description": "Y Index Register"
      },
      "S": {
        "size": "8",
        "description": "Stack Pointer"
      },
      "P": {
        "size": "8",
        "description": "Processor Status"
      },
      "PC": {
        "size": "16",
        "description": "Program Counter"
      }
    },
    "vectors": {
      "FFFA": "NMI",
      "FFFC": "RESET",
      "FFFE": "IRQ"
    },
    "flags": {
      "names": "NV-BDIZC",
      "N": "Negative",
      "V": "Overflow",
      "-": "(Expansion)",
      "B": "Break Command",
      "D": "Decimal",
      "I": "Interrupt Disable",
      "Z": "Zero",
      "C": "Carry"
    },
    "opcodes": [
      {
        "illegal": false,
        "mnemo": "BRK",
        "addmode": "-",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SLO",
        "addmode": "(a8,X)",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SLO",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHP",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ANC",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SLO",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BPL",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SLO",
        "addmode": "(a8),Y",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SLO",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLC",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SLO",
        "addmode": "a16,Y",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SLO",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JSR",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RLA",
        "addmode": "(a8,X)",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RLA",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PLP",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ANC",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RLA",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BMI",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RLA",
        "addmode": "(a8),Y",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RLA",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SEC",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RLA",
        "addmode": "a16,Y",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RLA",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RTI",
        "addmode": "-",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SRE",
        "addmode": "(a8,X)",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SRE",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHA",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ASR",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SRE",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BVC",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SRE",
        "addmode": "(a8),Y",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SRE",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLI",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SRE",
        "addmode": "a16,Y",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SRE",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RTS",
        "addmode": "-",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RRA",
        "addmode": "(a8,X)",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ASL0",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RRA",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PLA",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ASL0",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ARR",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "(a16)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ASL0",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RRA",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BVS",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RRA",
        "addmode": "(a8),Y",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ASL0",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RRA",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SEI",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RRA",
        "addmode": "a16,Y",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "ASL0",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RRA",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SAX",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SAX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEY",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TXA",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "XAA",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SAX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BCC",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8),Y",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SHA",
        "addmode": "(a8),Y",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a8,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SAX",
        "addmode": "a8,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TYA",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16,Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TXS",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SHS",
        "addmode": "a16,Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SHY",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SHX",
        "addmode": "a16,Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SHA",
        "addmode": "a16,Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAX",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TAY",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TAX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAX",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BCS",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAX",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a8,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAX",
        "addmode": "a8,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLV",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "TSX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAS",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "LAX",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "DCP",
        "addmode": "(a8,X)",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "DCP",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INY",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SBX",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "DCP",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BNE",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "DCP",
        "addmode": "(a8),Y",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "DCP",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLD",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "DCP",
        "addmode": "a16,Y",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "DCP",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ISC",
        "addmode": "(a8,X)",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ISC",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SBC",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ISC",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BEQ",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ISC",
        "addmode": "(a8),Y",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ISC",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SED",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ISC",
        "addmode": "a16,Y",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ISC",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      }
    ],
    "operations": {
      "ADC": {
        "category": "arith",
        "flags": "NV----ZC",
        "description": "A + M + C → A, C",
        "documentation": {
          "title": "Add Memory to Accumulator with Carry",
          "text": [
            "This instruction adds the value of memory and carry from the previous operation to the value of the accumulator and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the carry flag when the sum of a binary add exceeds 255 or when the sum of a decimal add exceeds 99, otherwise carry is reset. The overflow flag is set when the sign or bit 7 is changed due to the result exceeding +127 or -128, otherwise overflow is reset. The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. The zero flag is set if the accumulator result is 0, otherwise the zero flag is reset."
          ]
        }
      },
      "AND": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ∧ M → A",
        "documentation": {
          "title": "\"AND\" Memory with Accumulator",
          "text": [
            "The AND instruction transfer the accumulator and memory to the adder which performs a bit-by-bit AND operation and stores the result back in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "ASL": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C ← /M7...M0/ ← 0",
        "documentation": {
          "title": "Arithmetic Shift Left",
          "text": [
            "The shift left instruction shifts either the accumulator or the address memory location 1 bit to the left, with the bit 0 always being set to 0 and the the input bit 7 being stored in the carry flag. ASL either shifts the accumulator left 1 bit or is a read/modify/write instruction that affects only memory.",
            "The instruction does not affect the overflow bit, sets N equal to the result bit 7 (bit 6 in the input), sets Z flag if the result is equal to 0, otherwise resets Z and stores the input bit 7 in the carry flag."
          ]
        }
      },
      "BCC": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on C = 0",
        "documentation": {
          "title": "Branch on Carry Clear",
          "text": [
            "This instruction tests the state of the carry bit and takes a conditional branch if the carry bit is reset.",
            "It affects no flags or registers other than the program counter and then only if the C flag is not on."
          ]
        }
      },
      "BCS": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on C = 1",
        "documentation": {
          "title": "Branch on Carry Set",
          "text": [
            "This instruction takes the conditional branch if the carry flag is on.",
            "BCS does not affect any of the flags or registers except for the program counter and only then if the carry flag is on."
          ]
        }
      },
      "BEQ": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on Z = 1",
        "documentation": {
          "title": "Branch on Result Zero",
          "text": [
            "This instruction could also be called \"Branch on Equal.\"",
            "It takes a conditional branch whenever the Z flag is on or the previ­ ous result is equal to 0.",
            "BEQ does not affect any of the flags or registers other than the program counter and only then when the Z flag is set."
          ]
        }
      },
      "BIT": {
        "category": "logic",
        "flags": "NV----Z-",
        "description": "A ∧ M, M7 → N, M6 → V",
        "documentation": {
          "title": "Test Bits in Memory with Accumulator",
          "text": [
            "This instruction performs an AND between a memory location and the accumulator but does not store the result of the AND into the accumulator.",
            "The bit instruction affects the N flag with N being set to the value of bit 7 of the memory being tested, the V flag with V being set equal to bit 6 of the memory being tested and Z being set by the result of the AND operation between the accumulator and the memory if the result is Zero, Z is reset otherwise. It does not affect the accumulator."
          ]
        }
      },
      "BMI": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on N = 1",
        "documentation": {
          "title": "Branch on Result Minus",
          "text": [
            "This instruction takes the conditional branch if the N bit is set.",
            "BMI does not affect any of the flags or any other part of the machine other than the program counter and then only if the N bit is on."
          ]
        }
      },
      "BNE": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on Z = 0",
        "documentation": {
          "title": "Branch on Result Not Zero",
          "text": [
            "This instruction could also be called \"Branch on Not Equal.\" It tests the Z flag and takes the conditional branch if the Z flag is not on, indicating that the previous result was not zero.",
            "BNE does not affect any of the flags or registers other than the program counter and only then if the Z flag is reset."
          ]
        }
      },
      "BPL": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on N = 0",
        "documentation": {
          "title": "Branch on Result Plus",
          "text": [
            "This instruction is the complementary branch to branch on result minus. It is a conditional branch which takes the branch when the N bit is reset (0). BPL is used to test if the previous result bit 7 was off (0) and branch on result minus is used to determine if the previous result was minus or bit 7 was on (1).",
            "The instruction affects no flags or other registers other than the P counter and only affects the P counter when the N bit is reset."
          ]
        }
      },
      "BRK": {
        "category": "ctrl",
        "flags": "-----1--",
        "description": "PC + 2↓, [FFFE] → PCL, [FFFF] → PCH",
        "documentation": {
          "title": "Break Command",
          "text": [
            "The break command causes the microprocessor to go through an inter­ rupt sequence under program control. This means that the program counter of the second byte after the BRK. is automatically stored on the stack along with the processor status at the beginning of the break instruction. The microprocessor then transfers control to the interrupt vector.",
            "Other than changing the program counter, the break instruction changes no values in either the registers or the flags."
          ]
        }
      },
      "BVC": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on V = 0",
        "documentation": {
          "title": "Branch on Overflow Clear",
          "text": [
            "This instruction tests the status of the V flag and takes the conditional branch if the flag is not set.",
            "BVC does not affect any of the flags and registers other than the program counter and only when the overflow flag is reset."
          ]
        }
      },
      "BVS": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on V = 1",
        "documentation": {
          "title": "Branch on Overflow Set",
          "text": [
            "This instruction tests the V flag and takes the conditional branch if V is on.",
            "BVS does not affect any flags or registers other than the program, counter and only when the overflow flag is set."
          ]
        }
      },
      "CLC": {
        "category": "flags",
        "flags": "-------0",
        "description": "0 → C",
        "documentation": {
          "title": "Clear Carry Flag",
          "text": [
            "This instruction initializes the carry flag to a 0. This op­ eration should normally precede an ADC loop. It is also useful when used with a R0L instruction to clear a bit in memory.",
            "This instruction affects no registers in the microprocessor and no flags other than the carry flag which is reset."
          ]
        }
      },
      "CLD": {
        "category": "flags",
        "flags": "----0---",
        "description": "0 → D",
        "documentation": {
          "title": "Clear Decimal Mode",
          "text": [
            "This instruction sets the decimal mode flag to a 0. This all subsequent ADC and SBC instructions to operate as simple operations.",
            "CLD affects no registers in the microprocessor and no flags other than the decimal mode flag which is set to a 0."
          ]
        }
      },
      "CLI": {
        "category": "flags",
        "flags": "-----0--",
        "description": "0 → I",
        "documentation": {
          "title": "Clear Interrupt Disable",
          "text": [
            "This instruction initializes the interrupt disable to a 0. This allows the microprocessor to receive interrupts.",
            "It affects no registers in the microprocessor and no flags other than the interrupt disable which is cleared."
          ]
        }
      },
      "CLV": {
        "category": "flags",
        "flags": "-0------",
        "description": "0 → V",
        "documentation": {
          "title": "Clear Overflow Flag",
          "text": [
            "This instruction clears the overflow flag to a 0. This com­ mand is used in conjunction with the set overflow pin which can change the state of the overflow flag with an external signal.",
            "CLV affects no registers in the microprocessor and no flags other than the overflow flag which is set to a 0."
          ]
        }
      },
      "CMP": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "A - M",
        "documentation": {
          "title": "Compare Memory and Accumulator",
          "text": [
            "This instruction subtracts the contents of memory from the contents of the accumulator.",
            "The use of the CMP affects the following flags: Z flag is set on an equal comparison, reset otherwise; the N flag is set or reset by the result bit 7, the carry flag is set when the value in memory is less than or equal to the accumulator, reset when it is greater than the accumulator. The accumulator is not affected."
          ]
        }
      },
      "CPX": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "X - M",
        "documentation": {
          "title": "Compare Index Register X To Memory",
          "text": [
            "This instruction subtracts the value of the addressed memory location from the content of index register X using the adder but does not store the result; therefore, its only use is to set the N, Z and C flags to allow for comparison between the index register X and the value in memory.",
            "The CPX instruction does not affect any register in the machine; it also does not affect the overflow flag. It causes the carry to be set on if the absolute value of the index register X is equal to or greater than the data from memory. If the value of the memory is greater than the content of the index register X, carry is reset. If the results of the subtraction contain a bit 7, then the N flag is set, if not, it is reset. If the value in memory is equal to the value in index register X, the Z flag is set, otherwise it is reset."
          ]
        }
      },
      "CPY": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "Y - M",
        "documentation": {
          "title": "Compare Index Register Y To Memory",
          "text": [
            "This instruction performs a two's complement subtraction between the index register Y and the specified memory location. The results of the subtraction are not stored anywhere. The instruction is strict­ly used to set the flags.",
            "CPY affects no registers in the microprocessor and also does not affect the overflow flag. If the value in the index register Y is equal to or greater than the value in the memory, the carry flag will be set, otherwise it will be cleared. If the results of the subtract- tion contain bit 7 on the N bit will be set, otherwise it will be cleared. If the value in the index register Y and the value in the memory are equal, the zero flag will be set, otherwise it will be cleared."
          ]
        }
      },
      "DEC": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "M - 1 → M",
        "documentation": {
          "title": "Decrement Memory By One",
          "text": [
            "This instruction subtracts 1, in two's complement, from the contents of the addressed memory location.",
            "The decrement instruction does not affect any internal register in the microprocessor. It does not affect the carry or overflow flags. If bit 7 is on as a result of the decrement, then the N flag is set, otherwise it is reset. If the result of the decrement is 0, the Z flag is set, other­wise it is reset."
          ]
        }
      },
      "DEX": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "X - 1 → X",
        "documentation": {
          "title": "Decrement Index Register X By One",
          "text": [
            "This instruction subtracts one from the current value of the index register X and stores the result in the index register X.",
            "DEX does not affect the carry or overflow flag, it sets the N flag if it has bit 7 on as a result of the decrement, otherwise it resets the N flag; sets the Z flag if X is a 0 as a result of the decrement, otherwise it resets the Z flag."
          ]
        }
      },
      "DEY": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "Y - 1 → Y",
        "documentation": {
          "title": "Decrement Index Register Y By One",
          "text": [
            "This instruction subtracts one from the current value in the in­ dex register Y and stores the result into the index register Y. The result does not affect or consider carry so that the value in the index register Y is decremented to 0 and then through 0 to FF.",
            "Decrement Y does not affect the carry or overflow flags; if the Y register contains bit 7 on as a result of the decrement the N flag is set, otherwise the N flag is reset. If the Y register is 0 as a result of the decrement, the Z flag is set otherwise the Z flag is reset. This instruction only affects the index register Y."
          ]
        }
      },
      "EOR": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ⊻ M → A",
        "documentation": {
          "title": "\"Exclusive OR\" Memory with Accumulator",
          "text": [
            "The EOR instruction transfers the memory and the accumulator to the adder which performs a binary \"EXCLUSIVE OR\" on a bit-by-bit basis and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "INC": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "M + 1 → M",
        "documentation": {
          "title": "Increment Memory By One",
          "text": [
            "This instruction adds 1 to the contents of the addressed memory loca­tion.",
            "The increment memory instruction does not affect any internal registers and does not affect the carry or overflow flags. If bit 7 is on as the result of the increment,N is set, otherwise it is reset; if the increment causes the result to become 0, the Z flag is set on, otherwise it is reset."
          ]
        }
      },
      "INX": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "X + 1 → X",
        "documentation": {
          "title": "Increment Index Register X By One",
          "text": [
            "Increment X adds 1 to the current value of the X register. This is an 8-bit increment which does not affect the carry operation, therefore, if the value of X before the increment was FF, the resulting value is 00.",
            "INX does not affect the carry or overflow flags; it sets the N flag if the result of the increment has a one in bit 7, otherwise resets N; sets the Z flag if the result of the increment is 0, otherwise it resets the Z flag.",
            "INX does not affect any other register other than the X register."
          ]
        }
      },
      "INY": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "Y + 1 → Y",
        "documentation": {
          "title": "Increment Index Register Y By One",
          "text": [
            "Increment Y increments or adds one to the current value in the Y register, storing the result in the Y register. As in the case of INX the primary application is to step thru a set of values using the Y register.",
            "The INY does not affect the carry or overflow flags, sets the N flag if the result of the increment has a one in bit 7, otherwise resets N, sets Z if as a result of the increment the Y register is zero otherwise resets the Z flag."
          ]
        }
      },
      "JMP": {
        "category": "ctrl",
        "flags": "--------",
        "description": "[PC + 1] → PCL, [PC + 2] → PCH",
        "documentation": {
          "title": "JMP Indirect",
          "text": [
            "This instruction establishes a new valne for the program counter.",
            "It affects only the program counter in the microprocessor and affects no flags in the status register."
          ]
        }
      },
      "JSR": {
        "category": "ctrl",
        "flags": "--------",
        "description": "PC + 2↓, [PC + 1] → PCL, [PC + 2] → PCH",
        "documentation": {
          "title": "Jump To Subroutine",
          "text": [
            "This instruction transfers control of the program counter to a subroutine location but leaves a return pointer on the stack to allow the user to return to perform the next instruction in the main program after the subroutine is complete. To accomplish this, JSR instruction stores the program counter address which points to the last byte of the jump instruc­ tion onto the stack using the stack pointer. The stack byte contains the program count high first, followed by program count low. The JSR then transfers the addresses following the jump instruction to the program counter low and the program counter high, thereby directing the program to begin at that new address.",
            "The JSR instruction affects no flags, causes the stack pointer to be decremented by 2 and substitutes new values into the program counter low and the program counter high."
          ]
        }
      },
      "LDA": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → A",
        "documentation": {
          "title": "Load Accumulator with Memory",
          "text": [
            "When instruction LDA is executed by the microprocessor, data is transferred from memory to the accumulator and stored in the accumulator.",
            "LDA affects the contents of the accumulator, does not affect the carry or overflow flags; sets the zero flag if the accumulator is zero as a result of the LDA, otherwise resets the zero flag; sets the negative flag if bit 7 of the accumulator is a 1, other­ wise resets the negative flag."
          ]
        }
      },
      "LDX": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → X",
        "documentation": {
          "title": "Load Index Register X From Memory",
          "text": [
            "Load the index register X from memory.",
            "LDX does not affect the C or V flags; sets Z if the value loaded was zero, otherwise resets it; sets N if the value loaded in bit 7 is a 1; otherwise N is reset, and affects only the X register."
          ]
        }
      },
      "LDY": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → Y",
        "documentation": {
          "title": "Load Index Register Y From Memory",
          "text": [
            "Load the index register Y from memory.",
            "LDY does not affect the C or V flags, sets the N flag if the value loaded in bit 7 is a 1, otherwise resets N, sets Z flag if the loaded value is zero otherwise resets Z and only affects the Y register."
          ]
        }
      },
      "LSR": {
        "category": "shift",
        "flags": "0-----ZC",
        "description": "0 → /M7...M0/ → C",
        "documentation": {
          "title": "Logical Shift Right",
          "text": [
            "This instruction shifts either the accumulator or a specified memory location 1 bit to the right, with the higher bit of the result always being set to 0, and the low bit which is shifted out of the field being stored in the carry flag.",
            "The shift right instruction either affects the accumulator by shift­ing it right 1 or is a read/modify/write instruction which changes a speci­fied memory location but does not affect any internal registers. The shift right does not affect the overflow flag. The N flag is always reset. The Z flag is set if the result of the shift is 0 and reset otherwise. The carry is set equal to bit 0 of the input."
          ]
        }
      },
      "NOP": {
        "category": "nop",
        "flags": "--------",
        "description": "No operation"
      },
      "ORA": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ∨ M → A",
        "documentation": {
          "title": "\"OR\" Memory with Accumulator",
          "text": [
            "The ORA instruction transfers the memory and the accumulator to the adder which performs a binary \"OR\" on a bit-by-bit basis and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "PHA": {
        "category": "stack",
        "flags": "--------",
        "description": "A↓",
        "documentation": {
          "title": "Push Accumulator On Stack",
          "text": [
            "This instruction transfers the current value of the accumulator to the next location on the stack, automatically decrementing the stack to point to the next empty location.",
            "The Push A instruction only affects the stack pointer register which is decremented by 1 as a result of the operation. It affects no flags."
          ]
        }
      },
      "PHP": {
        "category": "stack",
        "flags": "--------",
        "description": "P↓",
        "documentation": {
          "title": "Push Processor Status On Stack",
          "text": [
            "This instruction transfers the contents of the processor status reg­ ister unchanged to the stack, as governed by the stack pointer.",
            "The PHP instruction affects no registers or flags in the micropro­cessor."
          ]
        }
      },
      "PLA": {
        "category": "stack",
        "flags": "N-----Z-",
        "description": "A↑",
        "documentation": {
          "title": "Pull Accumulator From Stack",
          "text": [
            "This instruction adds 1 to the current value of the stack pointer and uses it to address the stack and loads the contents of the stack into the A register.",
            "The PLA instruction does not affect the carry or overflow flags. It sets N if the bit 7 is on in accumulator A as a result of instructions, otherwise it is reset. If accumulator A is zero as a result of the PLA, then the Z flag is set, otherwise it is reset. The PLA instruction changes content of the accumulator A to the contents of the memory location at stack register plus 1 and also increments the stack register."
          ]
        }
      },
      "PLP": {
        "category": "stack",
        "flags": "NV--DIZC",
        "description": "P↑",
        "documentation": {
          "title": "Pull Processor Status From Stack",
          "text": [
            "This instruction transfers the next value on the stack to the Proces­ sor Status register, thereby changing all of the flags and setting the mode switches to the values from the stack.",
            "The PLP instruction affects no registers in the processor other than the status register. This instruction could affect all flags in the status register."
          ]
        }
      },
      "ROL": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C ← /M7...M0/ ← C",
        "documentation": {
          "title": "Rotate Left",
          "text": [
            "The rotate left instruction shifts either the accumulator or addressed memory left 1 bit, with the input carry being stored in bit 0 and with the input bit 7 being stored in the carry flags.",
            "The ROL instruction either shifts the accumulator left 1 bit and stores the carry in accumulator bit 0 or does not affect the internal reg­isters at all. The ROL instruction sets carry equal to the input bit 7, sets N equal to the input bit 6 , sets the Z flag if the result of the ro­ tate is 0, otherwise it resets Z and does not affect the overflow flag at all."
          ]
        }
      },
      "ROR": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C → /M7...M0/ → C",
        "documentation": {
          "title": "Rotate Right",
          "text": [
            "The rotate right instruction shifts either the accumulator or addressed memory right 1 bit with bit 0 shifted into the carry and carry shifted into bit 7.",
            "The ROR instruction either shifts the accumulator right 1 bit and stores the carry in accumulator bit 7 or does not affect the internal regis­ ters at all. The ROR instruction sets carry equal to input bit 0, sets N equal to the input carry and sets the Z flag if the result of the rotate is 0; otherwise it resets Z and does not affect the overflow flag at all.",
            "(Available on Microprocessors after June, 1976)"
          ]
        }
      },
      "RTI": {
        "category": "ctrl",
        "flags": "NV--DIZC",
        "description": "P↑ PC↑",
        "documentation": {
          "title": "Return From Interrupt",
          "text": [
            "This instruction transfers from the stack into the microprocessor the processor status and the program counter location for the instruction which was interrupted. By virtue of the interrupt having stored this data before executing the instruction and thei fact that the RTI reinitializes the microprocessor to the same state as when it was interrupted, the combination of interrupt plus RTI allows truly reentrant coding.",
            "The RTI instruction reinitializes all flags to the position to the point they were at the time the interrupt was taken and sets the program counter back to its pre-interrupt state. It affects no other registers in the microprocessor."
          ]
        }
      },
      "RTS": {
        "category": "ctrl",
        "flags": "--------",
        "description": "PC↑, PC + 1 → PC",
        "documentation": {
          "title": "Return From Subroutme",
          "text": [
            "This instruction loads the program count low and program count high from the stack into the program counter and increments the program counter so that it points to the instruction following the JSR. The stack pointer is adjusted by incrementing it twice.",
            "The RTS instruction does not affect any flags and affects only PCL and PCH."
          ]
        }
      },
      "SBC": {
        "category": "arith",
        "flags": "NV----ZC",
        "description": "A - M - ~C → A",
        "documentation": {
          "title": "Subtract Memory from Accumulator with Borrow",
          "text": [
            "This instruction subtracts the value of memory and borrow from the value of the accumulator, using two's complement arithmetic, and stores the result in the accumulator. Borrow is defined as the carry flag complemented; therefore, a resultant carry flag indicates that a borrow has not occurred.",
            "This instruction affects the accumulator. The carry flag is set if the result is greater than or equal to 0. The carry flag is reset when the result is less than 0, indicating a borrow. The over­flow flag is set when the result exceeds +127 or -127, otherwise it is reset. The negative flag is set if the result in the accumulator has bit 7 on, otherwise it is reset. The Z flag is set if the result in the accumulator is 0, otherwise it is reset."
          ]
        }
      },
      "SEC": {
        "category": "flags",
        "flags": "-------1",
        "description": "1 → C",
        "documentation": {
          "title": "Set Carry Flag",
          "text": [
            "This instruction initializes the carry flag to a 1. This op eration should normally precede a SBC loop. It is also useful when used with a ROL instruction to initialize a bit in memory to a 1.",
            "This instruction affects no registers in the microprocessor and no flags other than the carry flag which is set."
          ]
        }
      },
      "SED": {
        "category": "flags",
        "flags": "----1---",
        "description": "1 → D",
        "documentation": {
          "title": "Set Decimal Mode",
          "text": [
            "This instruction sets the decimal mode flag D to a 1. This makes all subsequent ADC and SBC instructions operate as a decimal arithmetic operation.",
            "SED affects no registers in the microprocessor and no flags other than the decimal mode which is set to a 1."
          ]
        }
      },
      "SEI": {
        "category": "flags",
        "flags": "-----1--",
        "description": "1 → I",
        "documentation": {
          "title": "Set Interrupt Disable",
          "text": [
            "This instruction initializes the interrupt disable to a 1. It is used to mask interrupt requests during system reset operations and during interrupt commands.",
            "It affects no registers in the microprocessor and no flags other than the interrupt disable which is set."
          ]
        }
      },
      "STA": {
        "category": "load",
        "flags": "--------",
        "description": "A → M",
        "documentation": {
          "title": "Store Accumulator in Memory",
          "text": [
            "This instruction transfers the contents of the accumulator to memory.",
            "This instruction affects none of the flags in the processor status register and does not affect the accumulator."
          ]
        }
      },
      "STX": {
        "category": "load",
        "flags": "--------",
        "description": "X → M",
        "documentation": {
          "title": "Store Index Register X In Memory",
          "text": [
            "Transfers value of X register to addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "STY": {
        "category": "load",
        "flags": "--------",
        "description": "Y → M",
        "documentation": {
          "title": "Store Index Register Y In Memory",
          "text": [
            "Transfer the value of the Y register to the addressed memory location.",
            "STY does not affect any flags or registers in the microprocessor."
          ]
        }
      },
      "TAX": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "A → X",
        "documentation": {
          "title": "Transfer Accumulator To Index X",
          "text": [
            "This instruction takes the value from accumulator A and trans­ fers or loads it into the index register X without disturbing the content of the accumulator A.",
            "TAX only affects the index register X, does not affect the carry or overflow flags. The N flag is set if the resultant value in the index register X has bit 7 on, otherwise N is reset. The Z bit is set if the content of the register X is 0 as aresult of theopera­ tion, otherwise it is reset."
          ]
        }
      },
      "TAY": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "A → Y",
        "documentation": {
          "title": "Transfer Accumula Tor To Index Y",
          "text": [
            "This instruction moves the value of the accumulator into index register Y without affecting the accumulator.",
            "TAY instruction only affects the Y register and does not affect either the carry or overflow flags. If the index register Y has bit 7 on, then N is set, otherwise it is reset. If the content of the index register Y equals 0 as a result of the operation, Z is set on, otherwise it is reset."
          ]
        }
      },
      "TSX": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "S → X",
        "documentation": {
          "title": "Transfer Stack Pointer To Index X",
          "text": [
            "This instruction transfers the value in the stack pointer to the index register X.",
            "TSX does not affect the carry or overflow flags. It sets N if bit 7 is on in index X as a result of the instruction, otherwise it is reset. If index X is zero as a result of the TSX, the Z flag is set, other­ wise it is reset. TSX changes the value of index X, making it equal to the content of the stack pointer."
          ]
        }
      },
      "TXA": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "X → A",
        "documentation": {
          "title": "Transfer Index X To Accumulator",
          "text": [
            "This instruction moves the value that is in the index register X to the accumulator A without disturbing the content of the index register X.",
            "TXA does not affect any register other than the accumula­tor and does not affect the carry or overflow flag. If the result in A has bit 7 on, then the N flag is set, otherwise it is reset. If the resultant value in the accumulator is 0, then the Z flag is set, other­ wise it is reset."
          ]
        }
      },
      "TXS": {
        "category": "trans",
        "flags": "--------",
        "description": "X → S",
        "documentation": {
          "title": "Transfer Index X To Stack Pointer",
          "text": [
            "This instruction transfers the value in the index register X to the stack pointer.",
            "TXS changes only the stack pointer, making it equal to the content of the index register X. It does not affect any of the flags."
          ]
        }
      },
      "TYA": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "Y → A",
        "documentation": {
          "title": "Transfer Index Y To Accumulator",
          "text": [
            "This instruction moves the value that is in the index register Y to accumulator A without disturbing the content of the register Y.",
            "TYA does not affect any other register other than the accumula­ tor and does not affect the carry or overflow flag. If the result in the accumulator A has bit 7 on, the N flag is set, otherwise it is reset. If the resultant value in the accumulator A is 0, then the Z flag is set, otherwise it is reset."
          ]
        }
      },
      "#": {
        "category": "mnemos",
        "flags": "are",
        "description": "based on VICE"
      },
      "ANC": {
        "category": "arith",
        "flags": "*-----**",
        "description": "A ∧ M → A, N → C",
        "documentation": {
          "title": "\"AND\" Memory with Accumulator then Move Negative Flag to Carry Flag",
          "text": [
            "The undocumented ANC instruction performs a bit-by-bit AND operation of the accumulator and memory and stores the result back in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag and the carry flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag and the carry flag."
          ]
        }
      },
      "ARR": {
        "category": "arith",
        "flags": "**----**",
        "description": "(A ∧ M) / 2 → A",
        "documentation": {
          "title": "\"AND\" Accumulator then Rotate Right",
          "text": [
            "The undocumented ARR instruction performs a bit-by-bit \"AND\" operation of the accumulator and memory, then shifts the result right 1 bit with bit 0 shifted into the carry and carry shifted into bit 7. It then stores the result back in the accumulator.",
            "If bit 7 of the result is on, then the N flag is set, otherwise it is reset. The instruction sets the Z flag if the result is 0; otherwise it resets Z.",
            "The V and C flags depends on the Decimal Mode Flag:",
            "In decimal mode, the V flag is set if bit 6 is different than the original data's bit 6, otherwise the V flag is reset. The C flag is set if (operand & 0xF0) + (operand & 0x10) is greater than 0x50, otherwise the C flag is reset.",
            "In binary mode, the V flag is set if bit 6 of the result is different than bit 5 of the result, otherwise the V flag is reset. The C flag is set if the result in the accumulator has bit 6 on, otherwise it is reset."
          ]
        }
      },
      "ASR": {
        "category": "arith",
        "flags": "0-----**",
        "description": "(A ∧ M) / 2 → A",
        "documentation": {
          "title": "\"AND\" then Logical Shift Right",
          "text": [
            "The undocumented ASR instruction performs a bit-by-bit AND operation of the accumulator and memory, then shifts the accumulator 1 bit to the right, with the higher bit of the result always being set to 0, and the low bit which is shifted out of the field being stored in the carry flag.",
            "This instruction affects the accumulator. It does not affect the overflow flag. The N flag is always reset. The Z flag is set if the result of the shift is 0 and reset otherwise. The carry is set equal to bit 0 of the result of the \"AND\" operation."
          ]
        }
      },
      "DCP": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M - 1 → M, A - M",
        "documentation": {
          "title": "Decrement Memory By One then Compare with Accumulator",
          "text": [
            "This undocumented instruction subtracts 1, in two's complement, from the contents of the addressed memory location. It then subtracts the contents of memory from the contents of the accumulator.",
            "The DCP instruction does not affect any internal register in the microprocessor. It does not affect the overflow flag. Z flag is set on an equal comparison, reset otherwise; the N flag is set or reset by the result bit 7, the carry flag is set when the result in memory is less than or equal to the accumulator, reset when it is greater than the accumulator."
          ]
        }
      },
      "ISC": {
        "category": "arith",
        "flags": "**----**",
        "description": "M + 1 → M, A - M → A",
        "documentation": {
          "title": "Increment Memory By One then SBC then Subtract Memory from Accumulator with Borrow",
          "text": [
            "This undocumented instruction adds 1 to the contents of the addressed memory loca­tion. It then subtracts the value of the result in memory and borrow from the value of the accumulator, using two's complement arithmetic, and stores the result in the accumulator.",
            "This instruction affects the accumulator. The carry flag is set if the result is greater than or equal to 0. The carry flag is reset when the result is less than 0, indicating a borrow. The over­flow flag is set when the result exceeds +127 or -127, otherwise it is reset. The negative flag is set if the result in the accumulator has bit 7 on, otherwise it is reset. The Z flag is set if the result in the accumulator is 0, otherwise it is reset."
          ]
        }
      },
      "JAM": {
        "category": "kil",
        "flags": "--------",
        "description": "Stop execution",
        "documentation": {
          "title": "Halt the CPU",
          "text": [
            "This undocumented instruction stops execution. The microprocessor will not fetch further instructions, and will neither handle IRQs nor NMIs. It will handle a RESET though."
          ]
        }
      },
      "LAS": {
        "category": "load",
        "flags": "*-----*-",
        "description": "M ∧ S → A, X, S",
        "documentation": {
          "title": "\"AND\" Memory with Stack Pointer",
          "text": [
            "This undocumented instruction performs a bit-by-bit \"AND\" operation of the stack pointer and memory and stores the result back in the accumulator, the index register X and the stack pointer.",
            "The LAS instruction does not affect the carry or overflow flags. It sets N if the bit 7 of the result is on, otherwise it is reset. If the result is zero, then the Z flag is set, otherwise it is reset."
          ]
        }
      },
      "LAX": {
        "category": "load",
        "flags": "*-----*-",
        "description": "M → A, X",
        "documentation": {
          "title": "Load Accumulator and Index Register X From Memory",
          "text": [
            "The undocumented LAX instruction loads the accumulator and the index register X from memory.",
            "LAX does not affect the C or V flags; sets Z if the value loaded was zero, otherwise resets it; sets N if the value loaded in bit 7 is a 1; otherwise N is reset, and affects only the X register."
          ]
        }
      },
      "RLA": {
        "category": "arith",
        "flags": "*-----**",
        "description": "C ← /M7...M0/ ← C, A ∧ M → A",
        "documentation": {
          "title": "Rotate Left then \"AND\" with Accumulator",
          "text": [
            "The undocumented RLA instruction shifts the addressed memory left 1 bit, with the input carry being stored in bit 0 and with the input bit 7 being stored in the carry flags. It then performs a bit-by-bit AND operation of the result and the value of the accumulator and stores the result back in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "RRA": {
        "category": "arith",
        "flags": "**----**",
        "description": "C → /M7...M0/ → C, A + M + C → A",
        "documentation": {
          "title": "Rotate Right and Add Memory to Accumulator",
          "text": [
            "The undocumented RRA instruction shifts the addressed memory right 1 bit with bit 0 shifted into the carry and carry shifted into bit 7. It then adds the result and generated carry to the value of the accumulator and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the carry flag when the sum of a binary add exceeds 255 or when the sum of a decimal add exceeds 99, otherwise carry is reset. The overflow flag is set when the sign or bit 7 is changed due to the result exceeding +127 or -128, otherwise overflow is reset. The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. The zero flag is set if the accumulator result is 0, otherwise the zero flag is reset."
          ]
        }
      },
      "SAX": {
        "category": "load",
        "flags": "--------",
        "description": "A ∧ X → M",
        "documentation": {
          "title": "Store Accumulator \"AND\" Index Register X in Memory",
          "text": [
            "The undocumented SAX instruction performs a bit-by-bit AND operation of the value of the accumulator and the value of the index register X and stores the result in memory.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SBX": {
        "category": "arith",
        "flags": "*-----**",
        "description": "(A ∧ X) - M → X",
        "documentation": {
          "title": "Subtract Memory from Accumulator \"AND\" Index Register X",
          "text": [
            "This undocumented instruction performs a bit-by-bit \"AND\" of the value of the accumulator and the index register X and subtracts the value of memory from this result, using two's complement arithmetic, and stores the result in the index register X.",
            "This instruction affects the index register X. The carry flag is set if the result is greater than or equal to 0. The carry flag is reset when the result is less than 0, indicating a borrow. The negative flag is set if the result in index register X has bit 7 on, otherwise it is reset. The Z flag is set if the result in index register X is 0, otherwise it is reset. The over­flow flag not affected at all."
          ]
        }
      },
      "SHA": {
        "category": "load",
        "flags": "--------",
        "description": "A ∧ X ∧ V → M",
        "documentation": {
          "title": "Store Accumulator \"AND\" Index Register X \"AND\" Value",
          "text": [
            "The undocumented SHA instruction performs a bit-by-bit AND operation of the following three operands: The first two are the accumulator and the index register X.",
            "The third operand depends on the addressing mode. In the zero page indirect Y-indexed case, the third operand is the data in memory at the given zero page address (ignoring the the addressing mode's Y offset) plus 1. In the Y-indexed absolute case, it is the upper 8 bits of the given address (ignoring the the addressing mode's Y offset), plus 1.",
            "It then transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SHS": {
        "category": "trans",
        "flags": "--------",
        "description": "A ∧ X → S, S ∧ (H + 1) → M",
        "documentation": {
          "title": "Transfer Accumulator \"AND\" Index Register X to Stack Pointer then Store Stack Pointer \"AND\" Hi-Byte In Memory",
          "text": [
            "The undocumented SHS instruction performs a bit-by-bit AND operation of the value of the accumulator and the value of the index register X and stores the result in the stack pointer. It then performs a bit-by-bit AND operation of the resulting stack pointer and the upper 8 bits of the given address (ignoring the addressing mode's Y offset), plus 1, and transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SHX": {
        "category": "load",
        "flags": "--------",
        "description": "X ∧ (H + 1) → M",
        "documentation": {
          "title": "Store Index Register X \"AND\" Value",
          "text": [
            "The undocumented SHX instruction performs a bit-by-bit AND operation of the index register X and the upper 8 bits of the given address (ignoring the the addressing mode's Y offset), plus 1. It then transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SHY": {
        "category": "load",
        "flags": "--------",
        "description": "Y ∧ (H + 1) → M",
        "documentation": {
          "title": "Store Index Register Y \"AND\" Value",
          "text": [
            "The undocumented SHY instruction performs a bit-by-bit AND operation of the index register Y and the upper 8 bits of the given address (ignoring the the addressing mode's X offset), plus 1. It then transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SLO": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M * 2 → M, A ∨ M → A",
        "documentation": {
          "title": "Arithmetic Shift Left then \"OR\" Memory with Accumulator",
          "text": [
            "The undocumented SLO instruction shifts the address memory location 1 bit to the left, with the bit 0 always being set to 0 and the bit 7 output always being contained in the carry flag. It then performs a bit-by-bit \"OR\" operation on the result and the accumulator and stores the result in the accumulator.",
            "The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. It sets Z flag if the result is equal to 0, otherwise resets Z and stores the input bit 7 in the carry flag."
          ]
        }
      },
      "SRE": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M / 2 → M, A ⊻ M → A",
        "documentation": {
          "title": "Logical Shift Right then \"Exclusive OR\" Memory with Accumulator",
          "text": [
            "The undocumented SRE instruction shifts the specified memory location 1 bit to the right, with the higher bit of the result always being set to 0, and the low bit which is shifted out of the field being stored in the carry flag. It then performs a bit-by-bit \"EXCLUSIVE OR\" of the result and the value of the accumulator and stores the result in the accumulator.",
            "This instruction affects the accumulator. It does not affect the overflow flag. The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. The Z flag is set if the result is 0 and reset otherwise. The carry is set equal to input bit 0."
          ]
        }
      },
      "XAA": {
        "category": "arith",
        "flags": "*-----*-",
        "description": "(A ∨ V) ∧ X ∧ M → A",
        "documentation": {
          "title": "Non-deterministic Operation of Accumulator, Index Register X, Memory and Bus Contents",
          "text": [
            "The operation of the undocumented XAA instruction depends on the individual microprocessor. On most machines, it performs a bit-by-bit AND operation of the following three operands: The first two are the index register X and memory.",
            "The third operand is the result of a bit-by-bit AND operation of the accumulator and a magic component. This magic component depends on the individual microprocessor and is usually one of $00, $EE, $EF, $FE and $FF, and may be influenced by the RDY pin, leftover contents of the data bus, the temperature of the microprocessor, the supplied voltage, and other factors.",
            "On some machines, additional bits of the result may be set or reset depending on non-deterministic factors.",
            "It then transfers the result to the accumulator.",
            "XAA does not affect the C or V flags; sets Z if the value loaded was zero, otherwise resets it; sets N if the result in bit 7 is a 1; otherwise N is reset."
          ]
        }
      },
      "ASL0": {
        "category": "shift",
        "flags": "N-----Z-",
        "description": "/M7...M0/ ← 0",
        "documentation": {
          "title": "Arithmetic Shift Left Without Updating Carry",
          "text": [
            "This instruction shifts either the accumulator or the address memory location 1 bit to the left, with the bit 0 always being set to 0. ASL0 either shifts the accumulator left 1 bit or is a read/modify/write instruction that affects only memory.",
            "The instruction does not affect the overflow bit, sets N equal to the result bit 7 (bit 6 in the input), sets Z flag if the result is equal to 0, otherwise resets Z.",
            "##PRIVATE##",
            "These are the buggy opcodes that were supposed to do a ROR."
          ]
        }
      }
    },
    "mnemos": {
      "ADC": {
        "description": "Add with Carry"
      },
      "AND": {
        "description": "Logical AND"
      },
      "ASL": {
        "description": "Arithmetic Shift Left"
      },
      "BCC": {
        "description": "Branch if Carry Clear"
      },
      "BCS": {
        "description": "Branch if Carry Set"
      },
      "BEQ": {
        "description": "Branch if Equal"
      },
      "BIT": {
        "description": "Bit Test"
      },
      "BMI": {
        "description": "Branch if Minus"
      },
      "BNE": {
        "description": "Branch if Not Equal"
      },
      "BPL": {
        "description": "Branch if Plus"
      },
      "BRK": {
        "description": "Force Interrupt"
      },
      "BVC": {
        "description": "Branch if Overflow Clear"
      },
      "BVS": {
        "description": "Branch if Overflow Set"
      },
      "CLC": {
        "description": "Clear Carry Flag"
      },
      "CLD": {
        "description": "Clear Decimal Mode"
      },
      "CLI": {
        "description": "Clear Interrupt Disable"
      },
      "CLV": {
        "description": "Clear Overflow Flag"
      },
      "CMP": {
        "description": "Compare"
      },
      "CPX": {
        "description": "Compare X Register"
      },
      "CPY": {
        "description": "Compare Y Register"
      },
      "DEC": {
        "description": "Decrement Memory"
      },
      "DEX": {
        "description": "Decrement X Register"
      },
      "DEY": {
        "description": "Decrement Y Register"
      },
      "EOR": {
        "description": "Exclusive OR"
      },
      "INC": {
        "description": "Increment Memory"
      },
      "INX": {
        "description": "Increment X Register"
      },
      "INY": {
        "description": "Increment Y Register"
      },
      "JMP": {
        "description": "Jump"
      },
      "JSR": {
        "description": "Jump to Subroutine"
      },
      "LDA": {
        "description": "Load Accumulator"
      },
      "LDX": {
        "description": "Load X Register"
      },
      "LDY": {
        "description": "Load Y Register"
      },
      "LSR": {
        "description": "Logical Shift Right"
      },
      "NOP": {
        "description": "No Operation"
      },
      "ORA": {
        "description": "Logical OR"
      },
      "PHA": {
        "description": "Push Accumulator"
      },
      "PHP": {
        "description": "Push Processor Status"
      },
      "PLA": {
        "description": "Pull Accumulator"
      },
      "PLP": {
        "description": "Pull Processor Status"
      },
      "ROL": {
        "description": "Rotate Left"
      },
      "ROR": {
        "description": "Rotate Right"
      },
      "RTI": {
        "description": "Return from Interrupt"
      },
      "RTS": {
        "description": "Return from Subroutine"
      },
      "SBC": {
        "description": "Subtract with Carry"
      },
      "SEC": {
        "description": "Set Carry Flag"
      },
      "SED": {
        "description": "Set Decimal Flag"
      },
      "SEI": {
        "description": "Set Interrupt Disable"
      },
      "STA": {
        "description": "Store Accumulator"
      },
      "STX": {
        "description": "Store X Register"
      },
      "STY": {
        "description": "Store Y Register"
      },
      "TAX": {
        "description": "Transfer Accumulator to X"
      },
      "TAY": {
        "description": "Transfer Accumulator to Y"
      },
      "TSX": {
        "description": "Transfer Stack Pointer to X"
      },
      "TXA": {
        "description": "Transfer X to Accumulator"
      },
      "TXS": {
        "description": "Transfer X to Stack Pointer"
      },
      "TYA": {
        "description": "Transfer Y to Accumulator"
      }
    },
    "addmodes": {
      "-": {
        "bytes": "1",
        "syntax": "",
        "description": "Implied",
        "documentation": {
          "title": "Implied",
          "text": [
            "In the implied addressing mode, the address containing the operand is implicitly stated in the operation code of the instruction."
          ]
        }
      },
      "A": {
        "bytes": "1",
        "syntax": "A",
        "description": "Accumulator",
        "documentation": {
          "title": "Accumulator",
          "text": [
            "This form of addressing is represented with a one byte instruction, implying an operation on the accumulator."
          ]
        }
      },
      "#d8": {
        "bytes": "2",
        "syntax": "#$nn",
        "description": "Immediate",
        "documentation": {
          "title": "Immediate",
          "text": [
            "In immediate addressing, the operand is contained in the second byte of the instruction, with no further memory addressing required."
          ]
        }
      },
      "a8": {
        "bytes": "2",
        "syntax": "$nn",
        "description": "Zero Page",
        "documentation": {
          "title": "Zero Page",
          "text": [
            "The zero page instructions allow for shorter code and execution times by only fetching the second byte of the instruction and assuming a zero high address byte. Careful use of the zero page can result in significant increase in code efficiency."
          ]
        }
      },
      "a8,X": {
        "bytes": "2",
        "syntax": "$nn,X",
        "description": "X-Indexed Zero Page",
        "documentation": {
          "title": "X-Indexed Zero Page",
          "text": [
            "This form of addressing is used in conjunction with the X index register. The effective address is calculated by adding the second byte to the contents of the index register. Since this is a form of \"Zero Page\" addressing, the content of the second byte references a location in page zero. Additionally, due to the “Zero Page\" addressing nature of this mode, no carry is added to the high order 8 bits of memory and crossing of page boundaries does not occur."
          ]
        }
      },
      "a8,Y": {
        "bytes": "2",
        "syntax": "$nn,Y",
        "description": "Y-Indexed Zero Page",
        "documentation": {
          "title": "Y-Indexed Zero Page",
          "text": [
            "This form of addressing is used in conjunction with the Y index register. The effective address is calculated by adding the second byte to the contents of the index register. Since this is a form of \"Zero Page\" addressing, the content of the second byte references a location in page zero. Additionally, due to the “Zero Page\" addressing nature of this mode, no carry is added to the high order 8 bits of memory and crossing of page boundaries does not occur."
          ]
        }
      },
      "(a8,X)": {
        "bytes": "2",
        "syntax": "($nn,X)",
        "description": "X-Indexed Zero Page Indirect",
        "documentation": {
          "title": "X-Indexed Zero Page Indirect",
          "text": [
            "In indexed indirect addressing, the second byte of the instruction is added to the contents of the X index register, discarding the carry. The result of this addition points to a memory location on page zero whose contents is the low order eight bits of the effective address. The next memory location in page zero contains the high order eight bits of the effective address. Both memory locations specifying the high and low order bytes of the effective address must be in page zero."
          ]
        }
      },
      "(a8),Y": {
        "bytes": "2",
        "syntax": "($nn),Y",
        "description": "Zero Page Indirect Y-Indexed",
        "documentation": {
          "title": "Zero Page Indirect Y-Indexed",
          "text": [
            "In indirect indexed addressing, the second byte of the instruction points to a memory location in page zero. The contents of this memory location is added to the contents of the Y index register, the result being the low order eight bits of the effective address. The carry from this addition is added to the contents of the next page zero memory location, the result being the high order eight bits of the effective address."
          ]
        }
      },
      "a16": {
        "bytes": "3",
        "syntax": "$nnnn",
        "description": "Absolute",
        "documentation": {
          "title": "Absolute",
          "text": [
            "In absolute addressing, the second byte of the instruction specifies the eight low order bits of the effective address while the third byte specifies the eight high order bits. Thus, the absolute addressing mode allows access to the entire 65 K bytes of addressable memory."
          ]
        }
      },
      "a16,X": {
        "bytes": "3",
        "syntax": "$nnnn,X",
        "description": "X-Indexed Absolute",
        "documentation": {
          "title": "X-Indexed Absolute",
          "text": [
            "This form of addressing is used in conjunction with the X index register. The effective address is formed by adding the contents of X to the address contained in the second and third bytes of the instruction. This mode allows the index register to contain the index or count value and the instruction to contain the base address. This type of indexing allows any location referencing and the index to modify multiple fields resulting in reduced coding and execution time."
          ]
        }
      },
      "a16,Y": {
        "bytes": "3",
        "syntax": "$nnnn,Y",
        "description": "Y-Indexed Absolute",
        "documentation": {
          "title": "Y-Indexed Absolute",
          "text": [
            "This form of addressing is used in conjunction with the Y index register. The effective address is formed by adding the contents of Y to the address contained in the second and third bytes of the instruction. This mode allows the index register to contain the index or count value and the instruction to contain the base address. This type of indexing allows any location referencing and the index to modify multiple fields resulting in reduced coding and execution time."
          ]
        }
      },
      "(a16)": {
        "bytes": "3",
        "syntax": "($nnnn)",
        "description": "Absolute Indirect",
        "documentation": {
          "title": "Absolute Indirect",
          "text": [
            "The second byte of the instruction contains the low order eight bits of a memory location. The high order eight bits of that memory location is contained in the third byte of the instruction. The contents of the fully specified memory location is the low order byte of the effective address. The next memory location contains the high order byte of the effective address which is loaded into the sixteen bits of the program counter."
          ]
        }
      },
      "r8": {
        "bytes": "2",
        "syntax": "$nnnn",
        "description": "Relative",
        "documentation": {
          "title": "Relative",
          "text": [
            "Relative addressing is used only with branch instructions and establishes a destination for the conditional branch.",
            "The second byte of-the instruction becomes the operand which is an “Offset\" added to the contents of the lower eight bits of the program counter when the counter is set at the next instruction. The range of the offset is —128 to +127 bytes from the next instruction."
          ]
        }
      }
    },
    "all_mnemos": {
      "regular": [
        "ADC",
        "AND",
        "ASL",
        "BCC",
        "BCS",
        "BEQ",
        "BIT",
        "BMI",
        "BNE",
        "BPL",
        "BRK",
        "BVC",
        "BVS",
        "CLC",
        "CLD",
        "CLI",
        "CLV",
        "CMP",
        "CPX",
        "CPY",
        "DEC",
        "DEX",
        "DEY",
        "EOR",
        "INC",
        "INX",
        "INY",
        "JMP",
        "JSR",
        "LDA",
        "LDX",
        "LDY",
        "LSR",
        "NOP",
        "ORA",
        "PHA",
        "PHP",
        "PLA",
        "PLP",
        "ROL",
        "RTI",
        "RTS",
        "SBC",
        "SEC",
        "SED",
        "SEI",
        "STA",
        "STX",
        "STY",
        "TAX",
        "TAY",
        "TSX",
        "TXA",
        "TXS",
        "TYA"
      ],
      "illegal": [
        "ANC",
        "ARR",
        "ASL0",
        "ASR",
        "DCP",
        "ISC",
        "JAM",
        "LAS",
        "LAX",
        "NOP",
        "RLA",
        "RRA",
        "SAX",
        "SBC",
        "SBX",
        "SHA",
        "SHS",
        "SHX",
        "SHY",
        "SLO",
        "SRE",
        "XAA"
      ],
      "all": [
        "ADC",
        "ANC",
        "AND",
        "ARR",
        "ASL",
        "ASL0",
        "ASR",
        "BCC",
        "BCS",
        "BEQ",
        "BIT",
        "BMI",
        "BNE",
        "BPL",
        "BRK",
        "BVC",
        "BVS",
        "CLC",
        "CLD",
        "CLI",
        "CLV",
        "CMP",
        "CPX",
        "CPY",
        "DCP",
        "DEC",
        "DEX",
        "DEY",
        "EOR",
        "INC",
        "INX",
        "INY",
        "ISC",
        "JAM",
        "JMP",
        "JSR",
        "LAS",
        "LAX",
        "LDA",
        "LDX",
        "LDY",
        "LSR",
        "NOP",
        "ORA",
        "PHA",
        "PHP",
        "PLA",
        "PLP",
        "RLA",
        "ROL",
        "RRA",
        "RTI",
        "RTS",
        "SAX",
        "SBC",
        "SBX",
        "SEC",
        "SED",
        "SEI",
        "SHA",
        "SHS",
        "SHX",
        "SHY",
        "SLO",
        "SRE",
        "STA",
        "STX",
        "STY",
        "TAX",
        "TAY",
        "TSX",
        "TXA",
        "TXS",
        "TYA",
        "XAA"
      ]
    },
    "all_addmodes": {
      "regular": [
        "-",
        "A",
        "#d8",
        "a16",
        "a16,X",
        "a16,Y",
        "(a16)",
        "a8",
        "a8,X",
        "a8,Y",
        "(a8,X)",
        "(a8),Y",
        "r8"
      ],
      "illegal": [
        "-",
        "A",
        "#d8",
        "a16",
        "a16,X",
        "a16,Y",
        "a8",
        "a8,X",
        "a8,Y",
        "(a8,X)",
        "(a8),Y"
      ],
      "all": [
        "-",
        "A",
        "#d8",
        "a16",
        "a16,X",
        "a16,Y",
        "(a16)",
        "a8",
        "a8,X",
        "a8,Y",
        "(a8,X)",
        "(a8),Y",
        "r8"
      ]
    }
  },
  "65dtv02": {
    "info": {
      "name": "65DTV02",
      "year": "2005",
      "id": "65dtv02",
      "basedon": "6502",
      "description": "This is a modern reimplementation of the 6502 by Jeri Ellsworth as used in the C64DTV2. It reproduces all quirks of the original 6502 as well as most undocumented opcodes and adds three new instructions and an MMU. (The timing information corresponds to \"skip internal cycles\" mode.)"
    },
    "registers": {
      "registers": [
        "A",
        "X",
        "Y",
        "S",
        "P",
        "PC",
        "R0",
        "R1",
        "R2",
        "R3",
        "R4",
        "R5",
        "R6",
        "R7",
        "R8",
        "R9",
        "R10",
        "R11",
        "R12",
        "R13",
        "R14",
        "R15"
      ],
      "A": {
        "size": "8",
        "description": "Accumulator (alias for R0-R15)"
      },
      "X": {
        "size": "8",
        "description": "X Index Register (alias for R0-R15)"
      },
      "Y": {
        "size": "8",
        "description": "Y Index Register (alias for R0-R15)"
      },
      "S": {
        "size": "8",
        "description": "Stack Pointer"
      },
      "P": {
        "size": "8",
        "description": "Processor Status"
      },
      "PC": {
        "size": "16",
        "description": "Program Counter"
      },
      "R0": {
        "size": "8",
        "description": "Default Accumulator"
      },
      "R1": {
        "size": "8",
        "description": "Default Y Register"
      },
      "R2": {
        "size": "8",
        "description": "Default X Register"
      },
      "R3": {
        "size": "8",
        "description": "Reserved"
      },
      "R4": {
        "size": "8",
        "description": "Reserved"
      },
      "R5": {
        "size": "8",
        "description": "Reserved"
      },
      "R6": {
        "size": "8",
        "description": "Reserved"
      },
      "R7": {
        "size": "8",
        "description": "Reserved"
      },
      "R8": {
        "size": "8",
        "description": "Bank 0-3 Access Mode"
      },
      "R9": {
        "size": "8",
        "description": "CPU Control"
      },
      "R10": {
        "size": "8",
        "description": "Base Page Segment"
      },
      "R11": {
        "size": "8",
        "description": "Stack Segment"
      },
      "R12": {
        "size": "8",
        "description": "Bank 0 Segment"
      },
      "R13": {
        "size": "8",
        "description": "Bank 1 Segment"
      },
      "R14": {
        "size": "8",
        "description": "Bank 2 Segment"
      },
      "R15": {
        "size": "8",
        "description": "Bank 3 Segment"
      }
    },
    "vectors": {
      "FFFA": "NMI",
      "FFFC": "RESET",
      "FFFE": "IRQ"
    },
    "flags": {
      "names": "NV-BDIZC",
      "N": "Negative",
      "V": "Overflow",
      "-": "(Expansion)",
      "B": "Break Command",
      "D": "Decimal",
      "I": "Interrupt Disable",
      "Z": "Zero",
      "C": "Carry"
    },
    "opcodes": [
      {
        "illegal": false,
        "mnemo": "BRK",
        "addmode": "-",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SLO",
        "addmode": "(a8,X)",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a8",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SLO",
        "addmode": "a8",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHP",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "A",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ANC",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a16",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SLO",
        "addmode": "a16",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BPL",
        "addmode": "r8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8),Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BRA",
        "addmode": "r8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SLO",
        "addmode": "(a8),Y",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a8,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SLO",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLC",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SLO",
        "addmode": "a16,Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a16,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SLO",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JSR",
        "addmode": "a16",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RLA",
        "addmode": "(a8,X)",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a8",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RLA",
        "addmode": "a8",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PLP",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "A",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ANC",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a16",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RLA",
        "addmode": "a16",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BMI",
        "addmode": "r8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8),Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SAC",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RLA",
        "addmode": "(a8),Y",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a8,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RLA",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SEC",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RLA",
        "addmode": "a16,Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a16,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RLA",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RTI",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SIR",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SRE",
        "addmode": "(a8,X)",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a8",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SRE",
        "addmode": "a8",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHA",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "A",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ASR",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a16",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SRE",
        "addmode": "a16",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BVC",
        "addmode": "r8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8),Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SRE",
        "addmode": "(a8),Y",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a8,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SRE",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLI",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SRE",
        "addmode": "a16,Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a16,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SRE",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RTS",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RRA",
        "addmode": "(a8,X)",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a8",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RRA",
        "addmode": "a8",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PLA",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "A",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ARR",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "(a16)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a16",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RRA",
        "addmode": "a16",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BVS",
        "addmode": "r8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8),Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RRA",
        "addmode": "(a8),Y",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a8,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RRA",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SEI",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RRA",
        "addmode": "a16,Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a16,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "RRA",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SAX",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SAX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEY",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TXA",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "XAA",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SAX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BCC",
        "addmode": "r8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8),Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SHA",
        "addmode": "(a8),Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a8,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a8,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a8,Y",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SAX",
        "addmode": "a8,Y",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TYA",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TXS",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SHS",
        "addmode": "a16,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SHY",
        "addmode": "a16,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SHX",
        "addmode": "a16,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SHA",
        "addmode": "a16,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAX",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TAY",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TAX",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAX",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BCS",
        "addmode": "r8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8),Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAX",
        "addmode": "(a8),Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a8,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a8,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a8,Y",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAX",
        "addmode": "a8,Y",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLV",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TSX",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAS",
        "addmode": "a16,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a16,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a16,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "LAX",
        "addmode": "a16,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "DCP",
        "addmode": "(a8,X)",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a8",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "DCP",
        "addmode": "a8",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INY",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEX",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SBX",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a16",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "DCP",
        "addmode": "a16",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BNE",
        "addmode": "r8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8),Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "DCP",
        "addmode": "(a8),Y",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a8,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "DCP",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLD",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "DCP",
        "addmode": "a16,Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a16,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "DCP",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ISC",
        "addmode": "(a8,X)",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a8",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ISC",
        "addmode": "a8",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INX",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "SBC",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a16",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ISC",
        "addmode": "a16",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BEQ",
        "addmode": "r8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8),Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "JAM",
        "addmode": "-",
        "cycles": "X",
        "mincycles": null,
        "maxcycles": null,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ISC",
        "addmode": "(a8),Y",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a8,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a8,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ISC",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SED",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ISC",
        "addmode": "a16,Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "a16,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "ISC",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      }
    ],
    "operations": {
      "ADC": {
        "category": "arith",
        "flags": "NV----ZC",
        "description": "A + M + C → A, C",
        "documentation": {
          "title": "Add Memory to Accumulator with Carry",
          "text": [
            "This instruction adds the value of memory and carry from the previous operation to the value of the accumulator and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the carry flag when the sum of a binary add exceeds 255 or when the sum of a decimal add exceeds 99, otherwise carry is reset. The overflow flag is set when the sign or bit 7 is changed due to the result exceeding +127 or -128, otherwise overflow is reset. The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. The zero flag is set if the accumulator result is 0, otherwise the zero flag is reset."
          ]
        }
      },
      "AND": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ∧ M → A",
        "documentation": {
          "title": "\"AND\" Memory with Accumulator",
          "text": [
            "The AND instruction transfer the accumulator and memory to the adder which performs a bit-by-bit AND operation and stores the result back in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "ASL": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C ← /M7...M0/ ← 0",
        "documentation": {
          "title": "Arithmetic Shift Left",
          "text": [
            "The shift left instruction shifts either the accumulator or the address memory location 1 bit to the left, with the bit 0 always being set to 0 and the the input bit 7 being stored in the carry flag. ASL either shifts the accumulator left 1 bit or is a read/modify/write instruction that affects only memory.",
            "The instruction does not affect the overflow bit, sets N equal to the result bit 7 (bit 6 in the input), sets Z flag if the result is equal to 0, otherwise resets Z and stores the input bit 7 in the carry flag."
          ]
        }
      },
      "BCC": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on C = 0",
        "documentation": {
          "title": "Branch on Carry Clear",
          "text": [
            "This instruction tests the state of the carry bit and takes a conditional branch if the carry bit is reset.",
            "It affects no flags or registers other than the program counter and then only if the C flag is not on."
          ]
        }
      },
      "BCS": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on C = 1",
        "documentation": {
          "title": "Branch on Carry Set",
          "text": [
            "This instruction takes the conditional branch if the carry flag is on.",
            "BCS does not affect any of the flags or registers except for the program counter and only then if the carry flag is on."
          ]
        }
      },
      "BEQ": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on Z = 1",
        "documentation": {
          "title": "Branch on Result Zero",
          "text": [
            "This instruction could also be called \"Branch on Equal.\"",
            "It takes a conditional branch whenever the Z flag is on or the previ­ ous result is equal to 0.",
            "BEQ does not affect any of the flags or registers other than the program counter and only then when the Z flag is set."
          ]
        }
      },
      "BIT": {
        "category": "logic",
        "flags": "NV----Z-",
        "description": "A ∧ M, M7 → N, M6 → V",
        "documentation": {
          "title": "Test Bits in Memory with Accumulator",
          "text": [
            "This instruction performs an AND between a memory location and the accumulator but does not store the result of the AND into the accumulator.",
            "The bit instruction affects the N flag with N being set to the value of bit 7 of the memory being tested, the V flag with V being set equal to bit 6 of the memory being tested and Z being set by the result of the AND operation between the accumulator and the memory if the result is Zero, Z is reset otherwise. It does not affect the accumulator."
          ]
        }
      },
      "BMI": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on N = 1",
        "documentation": {
          "title": "Branch on Result Minus",
          "text": [
            "This instruction takes the conditional branch if the N bit is set.",
            "BMI does not affect any of the flags or any other part of the machine other than the program counter and then only if the N bit is on."
          ]
        }
      },
      "BNE": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on Z = 0",
        "documentation": {
          "title": "Branch on Result Not Zero",
          "text": [
            "This instruction could also be called \"Branch on Not Equal.\" It tests the Z flag and takes the conditional branch if the Z flag is not on, indicating that the previous result was not zero.",
            "BNE does not affect any of the flags or registers other than the program counter and only then if the Z flag is reset."
          ]
        }
      },
      "BPL": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on N = 0",
        "documentation": {
          "title": "Branch on Result Plus",
          "text": [
            "This instruction is the complementary branch to branch on result minus. It is a conditional branch which takes the branch when the N bit is reset (0). BPL is used to test if the previous result bit 7 was off (0) and branch on result minus is used to determine if the previous result was minus or bit 7 was on (1).",
            "The instruction affects no flags or other registers other than the P counter and only affects the P counter when the N bit is reset."
          ]
        }
      },
      "BRK": {
        "category": "ctrl",
        "flags": "-----1--",
        "description": "PC + 2↓, [FFFE] → PCL, [FFFF] → PCH",
        "documentation": {
          "title": "Break Command",
          "text": [
            "The break command causes the microprocessor to go through an inter­ rupt sequence under program control. This means that the program counter of the second byte after the BRK. is automatically stored on the stack along with the processor status at the beginning of the break instruction. The microprocessor then transfers control to the interrupt vector.",
            "Other than changing the program counter, the break instruction changes no values in either the registers or the flags."
          ]
        }
      },
      "BVC": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on V = 0",
        "documentation": {
          "title": "Branch on Overflow Clear",
          "text": [
            "This instruction tests the status of the V flag and takes the conditional branch if the flag is not set.",
            "BVC does not affect any of the flags and registers other than the program counter and only when the overflow flag is reset."
          ]
        }
      },
      "BVS": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on V = 1",
        "documentation": {
          "title": "Branch on Overflow Set",
          "text": [
            "This instruction tests the V flag and takes the conditional branch if V is on.",
            "BVS does not affect any flags or registers other than the program, counter and only when the overflow flag is set."
          ]
        }
      },
      "CLC": {
        "category": "flags",
        "flags": "-------0",
        "description": "0 → C",
        "documentation": {
          "title": "Clear Carry Flag",
          "text": [
            "This instruction initializes the carry flag to a 0. This op­ eration should normally precede an ADC loop. It is also useful when used with a R0L instruction to clear a bit in memory.",
            "This instruction affects no registers in the microprocessor and no flags other than the carry flag which is reset."
          ]
        }
      },
      "CLD": {
        "category": "flags",
        "flags": "----0---",
        "description": "0 → D",
        "documentation": {
          "title": "Clear Decimal Mode",
          "text": [
            "This instruction sets the decimal mode flag to a 0. This all subsequent ADC and SBC instructions to operate as simple operations.",
            "CLD affects no registers in the microprocessor and no flags other than the decimal mode flag which is set to a 0."
          ]
        }
      },
      "CLI": {
        "category": "flags",
        "flags": "-----0--",
        "description": "0 → I",
        "documentation": {
          "title": "Clear Interrupt Disable",
          "text": [
            "This instruction initializes the interrupt disable to a 0. This allows the microprocessor to receive interrupts.",
            "It affects no registers in the microprocessor and no flags other than the interrupt disable which is cleared."
          ]
        }
      },
      "CLV": {
        "category": "flags",
        "flags": "-0------",
        "description": "0 → V",
        "documentation": {
          "title": "Clear Overflow Flag",
          "text": [
            "This instruction clears the overflow flag to a 0. This com­ mand is used in conjunction with the set overflow pin which can change the state of the overflow flag with an external signal.",
            "CLV affects no registers in the microprocessor and no flags other than the overflow flag which is set to a 0."
          ]
        }
      },
      "CMP": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "A - M",
        "documentation": {
          "title": "Compare Memory and Accumulator",
          "text": [
            "This instruction subtracts the contents of memory from the contents of the accumulator.",
            "The use of the CMP affects the following flags: Z flag is set on an equal comparison, reset otherwise; the N flag is set or reset by the result bit 7, the carry flag is set when the value in memory is less than or equal to the accumulator, reset when it is greater than the accumulator. The accumulator is not affected."
          ]
        }
      },
      "CPX": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "X - M",
        "documentation": {
          "title": "Compare Index Register X To Memory",
          "text": [
            "This instruction subtracts the value of the addressed memory location from the content of index register X using the adder but does not store the result; therefore, its only use is to set the N, Z and C flags to allow for comparison between the index register X and the value in memory.",
            "The CPX instruction does not affect any register in the machine; it also does not affect the overflow flag. It causes the carry to be set on if the absolute value of the index register X is equal to or greater than the data from memory. If the value of the memory is greater than the content of the index register X, carry is reset. If the results of the subtraction contain a bit 7, then the N flag is set, if not, it is reset. If the value in memory is equal to the value in index register X, the Z flag is set, otherwise it is reset."
          ]
        }
      },
      "CPY": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "Y - M",
        "documentation": {
          "title": "Compare Index Register Y To Memory",
          "text": [
            "This instruction performs a two's complement subtraction between the index register Y and the specified memory location. The results of the subtraction are not stored anywhere. The instruction is strict­ly used to set the flags.",
            "CPY affects no registers in the microprocessor and also does not affect the overflow flag. If the value in the index register Y is equal to or greater than the value in the memory, the carry flag will be set, otherwise it will be cleared. If the results of the subtract- tion contain bit 7 on the N bit will be set, otherwise it will be cleared. If the value in the index register Y and the value in the memory are equal, the zero flag will be set, otherwise it will be cleared."
          ]
        }
      },
      "DEC": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "M - 1 → M",
        "documentation": {
          "title": "Decrement Memory By One",
          "text": [
            "This instruction subtracts 1, in two's complement, from the contents of the addressed memory location.",
            "The decrement instruction does not affect any internal register in the microprocessor. It does not affect the carry or overflow flags. If bit 7 is on as a result of the decrement, then the N flag is set, otherwise it is reset. If the result of the decrement is 0, the Z flag is set, other­wise it is reset."
          ]
        }
      },
      "DEX": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "X - 1 → X",
        "documentation": {
          "title": "Decrement Index Register X By One",
          "text": [
            "This instruction subtracts one from the current value of the index register X and stores the result in the index register X.",
            "DEX does not affect the carry or overflow flag, it sets the N flag if it has bit 7 on as a result of the decrement, otherwise it resets the N flag; sets the Z flag if X is a 0 as a result of the decrement, otherwise it resets the Z flag."
          ]
        }
      },
      "DEY": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "Y - 1 → Y",
        "documentation": {
          "title": "Decrement Index Register Y By One",
          "text": [
            "This instruction subtracts one from the current value in the in­ dex register Y and stores the result into the index register Y. The result does not affect or consider carry so that the value in the index register Y is decremented to 0 and then through 0 to FF.",
            "Decrement Y does not affect the carry or overflow flags; if the Y register contains bit 7 on as a result of the decrement the N flag is set, otherwise the N flag is reset. If the Y register is 0 as a result of the decrement, the Z flag is set otherwise the Z flag is reset. This instruction only affects the index register Y."
          ]
        }
      },
      "EOR": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ⊻ M → A",
        "documentation": {
          "title": "\"Exclusive OR\" Memory with Accumulator",
          "text": [
            "The EOR instruction transfers the memory and the accumulator to the adder which performs a binary \"EXCLUSIVE OR\" on a bit-by-bit basis and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "INC": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "M + 1 → M",
        "documentation": {
          "title": "Increment Memory By One",
          "text": [
            "This instruction adds 1 to the contents of the addressed memory loca­tion.",
            "The increment memory instruction does not affect any internal registers and does not affect the carry or overflow flags. If bit 7 is on as the result of the increment,N is set, otherwise it is reset; if the increment causes the result to become 0, the Z flag is set on, otherwise it is reset."
          ]
        }
      },
      "INX": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "X + 1 → X",
        "documentation": {
          "title": "Increment Index Register X By One",
          "text": [
            "Increment X adds 1 to the current value of the X register. This is an 8-bit increment which does not affect the carry operation, therefore, if the value of X before the increment was FF, the resulting value is 00.",
            "INX does not affect the carry or overflow flags; it sets the N flag if the result of the increment has a one in bit 7, otherwise resets N; sets the Z flag if the result of the increment is 0, otherwise it resets the Z flag.",
            "INX does not affect any other register other than the X register."
          ]
        }
      },
      "INY": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "Y + 1 → Y",
        "documentation": {
          "title": "Increment Index Register Y By One",
          "text": [
            "Increment Y increments or adds one to the current value in the Y register, storing the result in the Y register. As in the case of INX the primary application is to step thru a set of values using the Y register.",
            "The INY does not affect the carry or overflow flags, sets the N flag if the result of the increment has a one in bit 7, otherwise resets N, sets Z if as a result of the increment the Y register is zero otherwise resets the Z flag."
          ]
        }
      },
      "JMP": {
        "category": "ctrl",
        "flags": "--------",
        "description": "[PC + 1] → PCL, [PC + 2] → PCH",
        "documentation": {
          "title": "JMP Indirect",
          "text": [
            "This instruction establishes a new valne for the program counter.",
            "It affects only the program counter in the microprocessor and affects no flags in the status register."
          ]
        }
      },
      "JSR": {
        "category": "ctrl",
        "flags": "--------",
        "description": "PC + 2↓, [PC + 1] → PCL, [PC + 2] → PCH",
        "documentation": {
          "title": "Jump To Subroutine",
          "text": [
            "This instruction transfers control of the program counter to a subroutine location but leaves a return pointer on the stack to allow the user to return to perform the next instruction in the main program after the subroutine is complete. To accomplish this, JSR instruction stores the program counter address which points to the last byte of the jump instruc­ tion onto the stack using the stack pointer. The stack byte contains the program count high first, followed by program count low. The JSR then transfers the addresses following the jump instruction to the program counter low and the program counter high, thereby directing the program to begin at that new address.",
            "The JSR instruction affects no flags, causes the stack pointer to be decremented by 2 and substitutes new values into the program counter low and the program counter high."
          ]
        }
      },
      "LDA": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → A",
        "documentation": {
          "title": "Load Accumulator with Memory",
          "text": [
            "When instruction LDA is executed by the microprocessor, data is transferred from memory to the accumulator and stored in the accumulator.",
            "LDA affects the contents of the accumulator, does not affect the carry or overflow flags; sets the zero flag if the accumulator is zero as a result of the LDA, otherwise resets the zero flag; sets the negative flag if bit 7 of the accumulator is a 1, other­ wise resets the negative flag."
          ]
        }
      },
      "LDX": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → X",
        "documentation": {
          "title": "Load Index Register X From Memory",
          "text": [
            "Load the index register X from memory.",
            "LDX does not affect the C or V flags; sets Z if the value loaded was zero, otherwise resets it; sets N if the value loaded in bit 7 is a 1; otherwise N is reset, and affects only the X register."
          ]
        }
      },
      "LDY": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → Y",
        "documentation": {
          "title": "Load Index Register Y From Memory",
          "text": [
            "Load the index register Y from memory.",
            "LDY does not affect the C or V flags, sets the N flag if the value loaded in bit 7 is a 1, otherwise resets N, sets Z flag if the loaded value is zero otherwise resets Z and only affects the Y register."
          ]
        }
      },
      "LSR": {
        "category": "shift",
        "flags": "0-----ZC",
        "description": "0 → /M7...M0/ → C",
        "documentation": {
          "title": "Logical Shift Right",
          "text": [
            "This instruction shifts either the accumulator or a specified memory location 1 bit to the right, with the higher bit of the result always being set to 0, and the low bit which is shifted out of the field being stored in the carry flag.",
            "The shift right instruction either affects the accumulator by shift­ing it right 1 or is a read/modify/write instruction which changes a speci­fied memory location but does not affect any internal registers. The shift right does not affect the overflow flag. The N flag is always reset. The Z flag is set if the result of the shift is 0 and reset otherwise. The carry is set equal to bit 0 of the input."
          ]
        }
      },
      "NOP": {
        "category": "nop",
        "flags": "--------",
        "description": "No operation"
      },
      "ORA": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ∨ M → A",
        "documentation": {
          "title": "\"OR\" Memory with Accumulator",
          "text": [
            "The ORA instruction transfers the memory and the accumulator to the adder which performs a binary \"OR\" on a bit-by-bit basis and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "PHA": {
        "category": "stack",
        "flags": "--------",
        "description": "A↓",
        "documentation": {
          "title": "Push Accumulator On Stack",
          "text": [
            "This instruction transfers the current value of the accumulator to the next location on the stack, automatically decrementing the stack to point to the next empty location.",
            "The Push A instruction only affects the stack pointer register which is decremented by 1 as a result of the operation. It affects no flags."
          ]
        }
      },
      "PHP": {
        "category": "stack",
        "flags": "--------",
        "description": "P↓",
        "documentation": {
          "title": "Push Processor Status On Stack",
          "text": [
            "This instruction transfers the contents of the processor status reg­ ister unchanged to the stack, as governed by the stack pointer.",
            "The PHP instruction affects no registers or flags in the micropro­cessor."
          ]
        }
      },
      "PLA": {
        "category": "stack",
        "flags": "N-----Z-",
        "description": "A↑",
        "documentation": {
          "title": "Pull Accumulator From Stack",
          "text": [
            "This instruction adds 1 to the current value of the stack pointer and uses it to address the stack and loads the contents of the stack into the A register.",
            "The PLA instruction does not affect the carry or overflow flags. It sets N if the bit 7 is on in accumulator A as a result of instructions, otherwise it is reset. If accumulator A is zero as a result of the PLA, then the Z flag is set, otherwise it is reset. The PLA instruction changes content of the accumulator A to the contents of the memory location at stack register plus 1 and also increments the stack register."
          ]
        }
      },
      "PLP": {
        "category": "stack",
        "flags": "NV--DIZC",
        "description": "P↑",
        "documentation": {
          "title": "Pull Processor Status From Stack",
          "text": [
            "This instruction transfers the next value on the stack to the Proces­ sor Status register, thereby changing all of the flags and setting the mode switches to the values from the stack.",
            "The PLP instruction affects no registers in the processor other than the status register. This instruction could affect all flags in the status register."
          ]
        }
      },
      "ROL": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C ← /M7...M0/ ← C",
        "documentation": {
          "title": "Rotate Left",
          "text": [
            "The rotate left instruction shifts either the accumulator or addressed memory left 1 bit, with the input carry being stored in bit 0 and with the input bit 7 being stored in the carry flags.",
            "The ROL instruction either shifts the accumulator left 1 bit and stores the carry in accumulator bit 0 or does not affect the internal reg­isters at all. The ROL instruction sets carry equal to the input bit 7, sets N equal to the input bit 6 , sets the Z flag if the result of the ro­ tate is 0, otherwise it resets Z and does not affect the overflow flag at all."
          ]
        }
      },
      "ROR": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C → /M7...M0/ → C",
        "documentation": {
          "title": "Rotate Right",
          "text": [
            "The rotate right instruction shifts either the accumulator or addressed memory right 1 bit with bit 0 shifted into the carry and carry shifted into bit 7.",
            "The ROR instruction either shifts the accumulator right 1 bit and stores the carry in accumulator bit 7 or does not affect the internal regis­ ters at all. The ROR instruction sets carry equal to input bit 0, sets N equal to the input carry and sets the Z flag if the result of the rotate is 0; otherwise it resets Z and does not affect the overflow flag at all.",
            "(Available on Microprocessors after June, 1976)"
          ]
        }
      },
      "RTI": {
        "category": "ctrl",
        "flags": "NV--DIZC",
        "description": "P↑ PC↑",
        "documentation": {
          "title": "Return From Interrupt",
          "text": [
            "This instruction transfers from the stack into the microprocessor the processor status and the program counter location for the instruction which was interrupted. By virtue of the interrupt having stored this data before executing the instruction and thei fact that the RTI reinitializes the microprocessor to the same state as when it was interrupted, the combination of interrupt plus RTI allows truly reentrant coding.",
            "The RTI instruction reinitializes all flags to the position to the point they were at the time the interrupt was taken and sets the program counter back to its pre-interrupt state. It affects no other registers in the microprocessor."
          ]
        }
      },
      "RTS": {
        "category": "ctrl",
        "flags": "--------",
        "description": "PC↑, PC + 1 → PC",
        "documentation": {
          "title": "Return From Subroutme",
          "text": [
            "This instruction loads the program count low and program count high from the stack into the program counter and increments the program counter so that it points to the instruction following the JSR. The stack pointer is adjusted by incrementing it twice.",
            "The RTS instruction does not affect any flags and affects only PCL and PCH."
          ]
        }
      },
      "SBC": {
        "category": "arith",
        "flags": "NV----ZC",
        "description": "A - M - ~C → A",
        "documentation": {
          "title": "Subtract Memory from Accumulator with Borrow",
          "text": [
            "This instruction subtracts the value of memory and borrow from the value of the accumulator, using two's complement arithmetic, and stores the result in the accumulator. Borrow is defined as the carry flag complemented; therefore, a resultant carry flag indicates that a borrow has not occurred.",
            "This instruction affects the accumulator. The carry flag is set if the result is greater than or equal to 0. The carry flag is reset when the result is less than 0, indicating a borrow. The over­flow flag is set when the result exceeds +127 or -127, otherwise it is reset. The negative flag is set if the result in the accumulator has bit 7 on, otherwise it is reset. The Z flag is set if the result in the accumulator is 0, otherwise it is reset."
          ]
        }
      },
      "SEC": {
        "category": "flags",
        "flags": "-------1",
        "description": "1 → C",
        "documentation": {
          "title": "Set Carry Flag",
          "text": [
            "This instruction initializes the carry flag to a 1. This op eration should normally precede a SBC loop. It is also useful when used with a ROL instruction to initialize a bit in memory to a 1.",
            "This instruction affects no registers in the microprocessor and no flags other than the carry flag which is set."
          ]
        }
      },
      "SED": {
        "category": "flags",
        "flags": "----1---",
        "description": "1 → D",
        "documentation": {
          "title": "Set Decimal Mode",
          "text": [
            "This instruction sets the decimal mode flag D to a 1. This makes all subsequent ADC and SBC instructions operate as a decimal arithmetic operation.",
            "SED affects no registers in the microprocessor and no flags other than the decimal mode which is set to a 1."
          ]
        }
      },
      "SEI": {
        "category": "flags",
        "flags": "-----1--",
        "description": "1 → I",
        "documentation": {
          "title": "Set Interrupt Disable",
          "text": [
            "This instruction initializes the interrupt disable to a 1. It is used to mask interrupt requests during system reset operations and during interrupt commands.",
            "It affects no registers in the microprocessor and no flags other than the interrupt disable which is set."
          ]
        }
      },
      "STA": {
        "category": "load",
        "flags": "--------",
        "description": "A → M",
        "documentation": {
          "title": "Store Accumulator in Memory",
          "text": [
            "This instruction transfers the contents of the accumulator to memory.",
            "This instruction affects none of the flags in the processor status register and does not affect the accumulator."
          ]
        }
      },
      "STX": {
        "category": "load",
        "flags": "--------",
        "description": "X → M",
        "documentation": {
          "title": "Store Index Register X In Memory",
          "text": [
            "Transfers value of X register to addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "STY": {
        "category": "load",
        "flags": "--------",
        "description": "Y → M",
        "documentation": {
          "title": "Store Index Register Y In Memory",
          "text": [
            "Transfer the value of the Y register to the addressed memory location.",
            "STY does not affect any flags or registers in the microprocessor."
          ]
        }
      },
      "TAX": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "A → X",
        "documentation": {
          "title": "Transfer Accumulator To Index X",
          "text": [
            "This instruction takes the value from accumulator A and trans­ fers or loads it into the index register X without disturbing the content of the accumulator A.",
            "TAX only affects the index register X, does not affect the carry or overflow flags. The N flag is set if the resultant value in the index register X has bit 7 on, otherwise N is reset. The Z bit is set if the content of the register X is 0 as aresult of theopera­ tion, otherwise it is reset."
          ]
        }
      },
      "TAY": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "A → Y",
        "documentation": {
          "title": "Transfer Accumula Tor To Index Y",
          "text": [
            "This instruction moves the value of the accumulator into index register Y without affecting the accumulator.",
            "TAY instruction only affects the Y register and does not affect either the carry or overflow flags. If the index register Y has bit 7 on, then N is set, otherwise it is reset. If the content of the index register Y equals 0 as a result of the operation, Z is set on, otherwise it is reset."
          ]
        }
      },
      "TSX": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "S → X",
        "documentation": {
          "title": "Transfer Stack Pointer To Index X",
          "text": [
            "This instruction transfers the value in the stack pointer to the index register X.",
            "TSX does not affect the carry or overflow flags. It sets N if bit 7 is on in index X as a result of the instruction, otherwise it is reset. If index X is zero as a result of the TSX, the Z flag is set, other­ wise it is reset. TSX changes the value of index X, making it equal to the content of the stack pointer."
          ]
        }
      },
      "TXA": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "X → A",
        "documentation": {
          "title": "Transfer Index X To Accumulator",
          "text": [
            "This instruction moves the value that is in the index register X to the accumulator A without disturbing the content of the index register X.",
            "TXA does not affect any register other than the accumula­tor and does not affect the carry or overflow flag. If the result in A has bit 7 on, then the N flag is set, otherwise it is reset. If the resultant value in the accumulator is 0, then the Z flag is set, other­ wise it is reset."
          ]
        }
      },
      "TXS": {
        "category": "trans",
        "flags": "--------",
        "description": "X → S",
        "documentation": {
          "title": "Transfer Index X To Stack Pointer",
          "text": [
            "This instruction transfers the value in the index register X to the stack pointer.",
            "TXS changes only the stack pointer, making it equal to the content of the index register X. It does not affect any of the flags."
          ]
        }
      },
      "TYA": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "Y → A",
        "documentation": {
          "title": "Transfer Index Y To Accumulator",
          "text": [
            "This instruction moves the value that is in the index register Y to accumulator A without disturbing the content of the register Y.",
            "TYA does not affect any other register other than the accumula­ tor and does not affect the carry or overflow flag. If the result in the accumulator A has bit 7 on, the N flag is set, otherwise it is reset. If the resultant value in the accumulator A is 0, then the Z flag is set, otherwise it is reset."
          ]
        }
      },
      "#": {
        "category": "mnemos",
        "flags": "are",
        "description": "based on VICE"
      },
      "ANC": {
        "category": "arith",
        "flags": "*-----**",
        "description": "A ∧ M → A, N → C",
        "documentation": {
          "title": "\"AND\" Memory with Accumulator then Move Negative Flag to Carry Flag",
          "text": [
            "The undocumented ANC instruction performs a bit-by-bit AND operation of the accumulator and memory and stores the result back in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag and the carry flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag and the carry flag."
          ]
        }
      },
      "ARR": {
        "category": "arith",
        "flags": "**----**",
        "description": "(A ∧ M) / 2 → A",
        "documentation": {
          "title": "\"AND\" Accumulator then Rotate Right",
          "text": [
            "The undocumented ARR instruction performs a bit-by-bit \"AND\" operation of the accumulator and memory, then shifts the result right 1 bit with bit 0 shifted into the carry and carry shifted into bit 7. It then stores the result back in the accumulator.",
            "If bit 7 of the result is on, then the N flag is set, otherwise it is reset. The instruction sets the Z flag if the result is 0; otherwise it resets Z.",
            "The V and C flags depends on the Decimal Mode Flag:",
            "In decimal mode, the V flag is set if bit 6 is different than the original data's bit 6, otherwise the V flag is reset. The C flag is set if (operand & 0xF0) + (operand & 0x10) is greater than 0x50, otherwise the C flag is reset.",
            "In binary mode, the V flag is set if bit 6 of the result is different than bit 5 of the result, otherwise the V flag is reset. The C flag is set if the result in the accumulator has bit 6 on, otherwise it is reset."
          ]
        }
      },
      "ASR": {
        "category": "arith",
        "flags": "0-----**",
        "description": "(A ∧ M) / 2 → A",
        "documentation": {
          "title": "\"AND\" then Logical Shift Right",
          "text": [
            "The undocumented ASR instruction performs a bit-by-bit AND operation of the accumulator and memory, then shifts the accumulator 1 bit to the right, with the higher bit of the result always being set to 0, and the low bit which is shifted out of the field being stored in the carry flag.",
            "This instruction affects the accumulator. It does not affect the overflow flag. The N flag is always reset. The Z flag is set if the result of the shift is 0 and reset otherwise. The carry is set equal to bit 0 of the result of the \"AND\" operation."
          ]
        }
      },
      "DCP": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M - 1 → M, A - M",
        "documentation": {
          "title": "Decrement Memory By One then Compare with Accumulator",
          "text": [
            "This undocumented instruction subtracts 1, in two's complement, from the contents of the addressed memory location. It then subtracts the contents of memory from the contents of the accumulator.",
            "The DCP instruction does not affect any internal register in the microprocessor. It does not affect the overflow flag. Z flag is set on an equal comparison, reset otherwise; the N flag is set or reset by the result bit 7, the carry flag is set when the result in memory is less than or equal to the accumulator, reset when it is greater than the accumulator."
          ]
        }
      },
      "ISC": {
        "category": "arith",
        "flags": "**----**",
        "description": "M + 1 → M, A - M → A",
        "documentation": {
          "title": "Increment Memory By One then SBC then Subtract Memory from Accumulator with Borrow",
          "text": [
            "This undocumented instruction adds 1 to the contents of the addressed memory loca­tion. It then subtracts the value of the result in memory and borrow from the value of the accumulator, using two's complement arithmetic, and stores the result in the accumulator.",
            "This instruction affects the accumulator. The carry flag is set if the result is greater than or equal to 0. The carry flag is reset when the result is less than 0, indicating a borrow. The over­flow flag is set when the result exceeds +127 or -127, otherwise it is reset. The negative flag is set if the result in the accumulator has bit 7 on, otherwise it is reset. The Z flag is set if the result in the accumulator is 0, otherwise it is reset."
          ]
        }
      },
      "JAM": {
        "category": "kil",
        "flags": "--------",
        "description": "Stop execution",
        "documentation": {
          "title": "Halt the CPU",
          "text": [
            "This undocumented instruction stops execution. The microprocessor will not fetch further instructions, and will neither handle IRQs nor NMIs. It will handle a RESET though."
          ]
        }
      },
      "LAS": {
        "category": "load",
        "flags": "*-----*-",
        "description": "M ∧ S → A, X, S",
        "documentation": {
          "title": "\"AND\" Memory with Stack Pointer",
          "text": [
            "This undocumented instruction performs a bit-by-bit \"AND\" operation of the stack pointer and memory and stores the result back in the accumulator, the index register X and the stack pointer.",
            "The LAS instruction does not affect the carry or overflow flags. It sets N if the bit 7 of the result is on, otherwise it is reset. If the result is zero, then the Z flag is set, otherwise it is reset."
          ]
        }
      },
      "LAX": {
        "category": "load",
        "flags": "*-----*-",
        "description": "M → A, X",
        "documentation": {
          "title": "Load Accumulator and Index Register X From Memory",
          "text": [
            "The undocumented LAX instruction loads the accumulator and the index register X from memory.",
            "LAX does not affect the C or V flags; sets Z if the value loaded was zero, otherwise resets it; sets N if the value loaded in bit 7 is a 1; otherwise N is reset, and affects only the X register."
          ]
        }
      },
      "RLA": {
        "category": "arith",
        "flags": "*-----**",
        "description": "C ← /M7...M0/ ← C, A ∧ M → A",
        "documentation": {
          "title": "Rotate Left then \"AND\" with Accumulator",
          "text": [
            "The undocumented RLA instruction shifts the addressed memory left 1 bit, with the input carry being stored in bit 0 and with the input bit 7 being stored in the carry flags. It then performs a bit-by-bit AND operation of the result and the value of the accumulator and stores the result back in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "RRA": {
        "category": "arith",
        "flags": "**----**",
        "description": "C → /M7...M0/ → C, A + M + C → A",
        "documentation": {
          "title": "Rotate Right and Add Memory to Accumulator",
          "text": [
            "The undocumented RRA instruction shifts the addressed memory right 1 bit with bit 0 shifted into the carry and carry shifted into bit 7. It then adds the result and generated carry to the value of the accumulator and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the carry flag when the sum of a binary add exceeds 255 or when the sum of a decimal add exceeds 99, otherwise carry is reset. The overflow flag is set when the sign or bit 7 is changed due to the result exceeding +127 or -128, otherwise overflow is reset. The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. The zero flag is set if the accumulator result is 0, otherwise the zero flag is reset."
          ]
        }
      },
      "SAX": {
        "category": "load",
        "flags": "--------",
        "description": "A ∧ X → M",
        "documentation": {
          "title": "Store Accumulator \"AND\" Index Register X in Memory",
          "text": [
            "The undocumented SAX instruction performs a bit-by-bit AND operation of the value of the accumulator and the value of the index register X and stores the result in memory.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SBX": {
        "category": "arith",
        "flags": "*-----**",
        "description": "(A ∧ X) - M → X",
        "documentation": {
          "title": "Subtract Memory from Accumulator \"AND\" Index Register X",
          "text": [
            "This undocumented instruction performs a bit-by-bit \"AND\" of the value of the accumulator and the index register X and subtracts the value of memory from this result, using two's complement arithmetic, and stores the result in the index register X.",
            "This instruction affects the index register X. The carry flag is set if the result is greater than or equal to 0. The carry flag is reset when the result is less than 0, indicating a borrow. The negative flag is set if the result in index register X has bit 7 on, otherwise it is reset. The Z flag is set if the result in index register X is 0, otherwise it is reset. The over­flow flag not affected at all."
          ]
        }
      },
      "SHA": {
        "category": "load",
        "flags": "--------",
        "description": "A ∧ X ∧ V → M",
        "documentation": {
          "title": "Store Accumulator \"AND\" Index Register X \"AND\" Value",
          "text": [
            "The undocumented SHA instruction performs a bit-by-bit AND operation of the following three operands: The first two are the accumulator and the index register X.",
            "The third operand depends on the addressing mode. In the zero page indirect Y-indexed case, the third operand is the data in memory at the given zero page address (ignoring the the addressing mode's Y offset) plus 1. In the Y-indexed absolute case, it is the upper 8 bits of the given address (ignoring the the addressing mode's Y offset), plus 1.",
            "It then transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SHS": {
        "category": "trans",
        "flags": "--------",
        "description": "A ∧ X → S, S ∧ (H + 1) → M",
        "documentation": {
          "title": "Transfer Accumulator \"AND\" Index Register X to Stack Pointer then Store Stack Pointer \"AND\" Hi-Byte In Memory",
          "text": [
            "The undocumented SHS instruction performs a bit-by-bit AND operation of the value of the accumulator and the value of the index register X and stores the result in the stack pointer. It then performs a bit-by-bit AND operation of the resulting stack pointer and the upper 8 bits of the given address (ignoring the addressing mode's Y offset), plus 1, and transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SHX": {
        "category": "load",
        "flags": "--------",
        "description": "X ∧ (H + 1) → M",
        "documentation": {
          "title": "Store Index Register X \"AND\" Value",
          "text": [
            "The undocumented SHX instruction performs a bit-by-bit AND operation of the index register X and the upper 8 bits of the given address (ignoring the the addressing mode's Y offset), plus 1. It then transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SHY": {
        "category": "load",
        "flags": "--------",
        "description": "Y ∧ (H + 1) → M",
        "documentation": {
          "title": "Store Index Register Y \"AND\" Value",
          "text": [
            "The undocumented SHY instruction performs a bit-by-bit AND operation of the index register Y and the upper 8 bits of the given address (ignoring the the addressing mode's X offset), plus 1. It then transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SLO": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M * 2 → M, A ∨ M → A",
        "documentation": {
          "title": "Arithmetic Shift Left then \"OR\" Memory with Accumulator",
          "text": [
            "The undocumented SLO instruction shifts the address memory location 1 bit to the left, with the bit 0 always being set to 0 and the bit 7 output always being contained in the carry flag. It then performs a bit-by-bit \"OR\" operation on the result and the accumulator and stores the result in the accumulator.",
            "The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. It sets Z flag if the result is equal to 0, otherwise resets Z and stores the input bit 7 in the carry flag."
          ]
        }
      },
      "SRE": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M / 2 → M, A ⊻ M → A",
        "documentation": {
          "title": "Logical Shift Right then \"Exclusive OR\" Memory with Accumulator",
          "text": [
            "The undocumented SRE instruction shifts the specified memory location 1 bit to the right, with the higher bit of the result always being set to 0, and the low bit which is shifted out of the field being stored in the carry flag. It then performs a bit-by-bit \"EXCLUSIVE OR\" of the result and the value of the accumulator and stores the result in the accumulator.",
            "This instruction affects the accumulator. It does not affect the overflow flag. The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. The Z flag is set if the result is 0 and reset otherwise. The carry is set equal to input bit 0."
          ]
        }
      },
      "XAA": {
        "category": "arith",
        "flags": "*-----*-",
        "description": "(A ∨ V) ∧ X ∧ M → A",
        "documentation": {
          "title": "Non-deterministic Operation of Accumulator, Index Register X, Memory and Bus Contents",
          "text": [
            "The operation of the undocumented XAA instruction depends on the individual microprocessor. On most machines, it performs a bit-by-bit AND operation of the following three operands: The first two are the index register X and memory.",
            "The third operand is the result of a bit-by-bit AND operation of the accumulator and a magic component. This magic component depends on the individual microprocessor and is usually one of $00, $EE, $EF, $FE and $FF, and may be influenced by the RDY pin, leftover contents of the data bus, the temperature of the microprocessor, the supplied voltage, and other factors.",
            "On some machines, additional bits of the result may be set or reset depending on non-deterministic factors.",
            "It then transfers the result to the accumulator.",
            "XAA does not affect the C or V flags; sets Z if the value loaded was zero, otherwise resets it; sets N if the result in bit 7 is a 1; otherwise N is reset."
          ]
        }
      },
      "SAC": {
        "category": "flags",
        "flags": "--------",
        "description": "Set Accumulator Mapping",
        "documentation": {
          "title": "Set Accumulator Mapping",
          "text": [
            "The 65DTV02 has a register file of 16 bytes, some of which double as control/MMU registers. The lower four bits of the SAC instruction's immediate operand assign the register that will be accessed through read operations to the accumulator, and the upper four bits assign the register that will be accessed through write operations to the accumulator. The default register for the accumulator is 0."
          ]
        }
      },
      "SIR": {
        "category": "flags",
        "flags": "--------",
        "description": "Set Index Register Mapping",
        "documentation": {
          "title": "Set Index Register Mapping",
          "text": [
            "The 65DTV02 has a register file of 16 bytes, some of which double as control/MMU registers. The lower four bits of the SIR instruction's immediate operand assign the register that index register X is mapped to, and the upper four bits assign the register that index register Y is mapped to. The default register for the index register X is 2, and the default for the index register Y is 1."
          ]
        }
      },
      "BRA": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch Always",
        "documentation": {
          "title": "Branch Always",
          "text": [
            "This instruction takes an unconditional branch.",
            "BRA does not affect any of the flags or any other part of the machine other than the program counter."
          ]
        }
      }
    },
    "mnemos": {
      "ADC": {
        "description": "Add with Carry"
      },
      "AND": {
        "description": "Logical AND"
      },
      "ASL": {
        "description": "Arithmetic Shift Left"
      },
      "BCC": {
        "description": "Branch if Carry Clear"
      },
      "BCS": {
        "description": "Branch if Carry Set"
      },
      "BEQ": {
        "description": "Branch if Equal"
      },
      "BIT": {
        "description": "Bit Test"
      },
      "BMI": {
        "description": "Branch if Minus"
      },
      "BNE": {
        "description": "Branch if Not Equal"
      },
      "BPL": {
        "description": "Branch if Plus"
      },
      "BRK": {
        "description": "Force Interrupt"
      },
      "BVC": {
        "description": "Branch if Overflow Clear"
      },
      "BVS": {
        "description": "Branch if Overflow Set"
      },
      "CLC": {
        "description": "Clear Carry Flag"
      },
      "CLD": {
        "description": "Clear Decimal Mode"
      },
      "CLI": {
        "description": "Clear Interrupt Disable"
      },
      "CLV": {
        "description": "Clear Overflow Flag"
      },
      "CMP": {
        "description": "Compare"
      },
      "CPX": {
        "description": "Compare X Register"
      },
      "CPY": {
        "description": "Compare Y Register"
      },
      "DEC": {
        "description": "Decrement Memory"
      },
      "DEX": {
        "description": "Decrement X Register"
      },
      "DEY": {
        "description": "Decrement Y Register"
      },
      "EOR": {
        "description": "Exclusive OR"
      },
      "INC": {
        "description": "Increment Memory"
      },
      "INX": {
        "description": "Increment X Register"
      },
      "INY": {
        "description": "Increment Y Register"
      },
      "JMP": {
        "description": "Jump"
      },
      "JSR": {
        "description": "Jump to Subroutine"
      },
      "LDA": {
        "description": "Load Accumulator"
      },
      "LDX": {
        "description": "Load X Register"
      },
      "LDY": {
        "description": "Load Y Register"
      },
      "LSR": {
        "description": "Logical Shift Right"
      },
      "NOP": {
        "description": "No Operation"
      },
      "ORA": {
        "description": "Logical OR"
      },
      "PHA": {
        "description": "Push Accumulator"
      },
      "PHP": {
        "description": "Push Processor Status"
      },
      "PLA": {
        "description": "Pull Accumulator"
      },
      "PLP": {
        "description": "Pull Processor Status"
      },
      "ROL": {
        "description": "Rotate Left"
      },
      "ROR": {
        "description": "Rotate Right"
      },
      "RTI": {
        "description": "Return from Interrupt"
      },
      "RTS": {
        "description": "Return from Subroutine"
      },
      "SBC": {
        "description": "Subtract with Carry"
      },
      "SEC": {
        "description": "Set Carry Flag"
      },
      "SED": {
        "description": "Set Decimal Flag"
      },
      "SEI": {
        "description": "Set Interrupt Disable"
      },
      "STA": {
        "description": "Store Accumulator"
      },
      "STX": {
        "description": "Store X Register"
      },
      "STY": {
        "description": "Store Y Register"
      },
      "TAX": {
        "description": "Transfer Accumulator to X"
      },
      "TAY": {
        "description": "Transfer Accumulator to Y"
      },
      "TSX": {
        "description": "Transfer Stack Pointer to X"
      },
      "TXA": {
        "description": "Transfer X to Accumulator"
      },
      "TXS": {
        "description": "Transfer X to Stack Pointer"
      },
      "TYA": {
        "description": "Transfer Y to Accumulator"
      },
      "#": {
        "description": "bugs in undocumented instructions"
      },
      "SAC": {
        "description": "Set Accumulator Mapping"
      },
      "SIR": {
        "description": "Set Index Register Mapping"
      },
      "BRA": {
        "description": "Branch Always"
      },
      "2B": {
        "description": "*ANC #d8"
      },
      "9B": {
        "description": "*NOP a16,Y"
      }
    },
    "addmodes": {
      "-": {
        "bytes": "1",
        "syntax": "",
        "description": "Implied",
        "documentation": {
          "title": "Implied",
          "text": [
            "In the implied addressing mode, the address containing the operand is implicitly stated in the operation code of the instruction."
          ]
        }
      },
      "A": {
        "bytes": "1",
        "syntax": "A",
        "description": "Accumulator",
        "documentation": {
          "title": "Accumulator",
          "text": [
            "This form of addressing is represented with a one byte instruction, implying an operation on the accumulator."
          ]
        }
      },
      "#d8": {
        "bytes": "2",
        "syntax": "#$nn",
        "description": "Immediate",
        "documentation": {
          "title": "Immediate",
          "text": [
            "In immediate addressing, the operand is contained in the second byte of the instruction, with no further memory addressing required."
          ]
        }
      },
      "a8": {
        "bytes": "2",
        "syntax": "$nn",
        "description": "Zero Page",
        "documentation": {
          "title": "Zero Page",
          "text": [
            "The zero page instructions allow for shorter code and execution times by only fetching the second byte of the instruction and assuming a zero high address byte. Careful use of the zero page can result in significant increase in code efficiency."
          ]
        }
      },
      "a8,X": {
        "bytes": "2",
        "syntax": "$nn,X",
        "description": "X-Indexed Zero Page",
        "documentation": {
          "title": "X-Indexed Zero Page",
          "text": [
            "This form of addressing is used in conjunction with the X index register. The effective address is calculated by adding the second byte to the contents of the index register. Since this is a form of \"Zero Page\" addressing, the content of the second byte references a location in page zero. Additionally, due to the “Zero Page\" addressing nature of this mode, no carry is added to the high order 8 bits of memory and crossing of page boundaries does not occur."
          ]
        }
      },
      "a8,Y": {
        "bytes": "2",
        "syntax": "$nn,Y",
        "description": "Y-Indexed Zero Page",
        "documentation": {
          "title": "Y-Indexed Zero Page",
          "text": [
            "This form of addressing is used in conjunction with the Y index register. The effective address is calculated by adding the second byte to the contents of the index register. Since this is a form of \"Zero Page\" addressing, the content of the second byte references a location in page zero. Additionally, due to the “Zero Page\" addressing nature of this mode, no carry is added to the high order 8 bits of memory and crossing of page boundaries does not occur."
          ]
        }
      },
      "(a8,X)": {
        "bytes": "2",
        "syntax": "($nn,X)",
        "description": "X-Indexed Zero Page Indirect",
        "documentation": {
          "title": "X-Indexed Zero Page Indirect",
          "text": [
            "In indexed indirect addressing, the second byte of the instruction is added to the contents of the X index register, discarding the carry. The result of this addition points to a memory location on page zero whose contents is the low order eight bits of the effective address. The next memory location in page zero contains the high order eight bits of the effective address. Both memory locations specifying the high and low order bytes of the effective address must be in page zero."
          ]
        }
      },
      "(a8),Y": {
        "bytes": "2",
        "syntax": "($nn),Y",
        "description": "Zero Page Indirect Y-Indexed",
        "documentation": {
          "title": "Zero Page Indirect Y-Indexed",
          "text": [
            "In indirect indexed addressing, the second byte of the instruction points to a memory location in page zero. The contents of this memory location is added to the contents of the Y index register, the result being the low order eight bits of the effective address. The carry from this addition is added to the contents of the next page zero memory location, the result being the high order eight bits of the effective address."
          ]
        }
      },
      "a16": {
        "bytes": "3",
        "syntax": "$nnnn",
        "description": "Absolute",
        "documentation": {
          "title": "Absolute",
          "text": [
            "In absolute addressing, the second byte of the instruction specifies the eight low order bits of the effective address while the third byte specifies the eight high order bits. Thus, the absolute addressing mode allows access to the entire 65 K bytes of addressable memory."
          ]
        }
      },
      "a16,X": {
        "bytes": "3",
        "syntax": "$nnnn,X",
        "description": "X-Indexed Absolute",
        "documentation": {
          "title": "X-Indexed Absolute",
          "text": [
            "This form of addressing is used in conjunction with the X index register. The effective address is formed by adding the contents of X to the address contained in the second and third bytes of the instruction. This mode allows the index register to contain the index or count value and the instruction to contain the base address. This type of indexing allows any location referencing and the index to modify multiple fields resulting in reduced coding and execution time."
          ]
        }
      },
      "a16,Y": {
        "bytes": "3",
        "syntax": "$nnnn,Y",
        "description": "Y-Indexed Absolute",
        "documentation": {
          "title": "Y-Indexed Absolute",
          "text": [
            "This form of addressing is used in conjunction with the Y index register. The effective address is formed by adding the contents of Y to the address contained in the second and third bytes of the instruction. This mode allows the index register to contain the index or count value and the instruction to contain the base address. This type of indexing allows any location referencing and the index to modify multiple fields resulting in reduced coding and execution time."
          ]
        }
      },
      "(a16)": {
        "bytes": "3",
        "syntax": "($nnnn)",
        "description": "Absolute Indirect",
        "documentation": {
          "title": "Absolute Indirect",
          "text": [
            "The second byte of the instruction contains the low order eight bits of a memory location. The high order eight bits of that memory location is contained in the third byte of the instruction. The contents of the fully specified memory location is the low order byte of the effective address. The next memory location contains the high order byte of the effective address which is loaded into the sixteen bits of the program counter."
          ]
        }
      },
      "r8": {
        "bytes": "2",
        "syntax": "$nnnn",
        "description": "Relative",
        "documentation": {
          "title": "Relative",
          "text": [
            "Relative addressing is used only with branch instructions and establishes a destination for the conditional branch.",
            "The second byte of-the instruction becomes the operand which is an “Offset\" added to the contents of the lower eight bits of the program counter when the counter is set at the next instruction. The range of the offset is —128 to +127 bytes from the next instruction."
          ]
        }
      }
    },
    "all_mnemos": {
      "regular": [
        "ADC",
        "AND",
        "ASL",
        "BCC",
        "BCS",
        "BEQ",
        "BIT",
        "BMI",
        "BNE",
        "BPL",
        "BRA",
        "BRK",
        "BVC",
        "BVS",
        "CLC",
        "CLD",
        "CLI",
        "CLV",
        "CMP",
        "CPX",
        "CPY",
        "DEC",
        "DEX",
        "DEY",
        "EOR",
        "INC",
        "INX",
        "INY",
        "JMP",
        "JSR",
        "LDA",
        "LDX",
        "LDY",
        "LSR",
        "NOP",
        "ORA",
        "PHA",
        "PHP",
        "PLA",
        "PLP",
        "ROL",
        "ROR",
        "RTI",
        "RTS",
        "SAC",
        "SBC",
        "SEC",
        "SED",
        "SEI",
        "SIR",
        "STA",
        "STX",
        "STY",
        "TAX",
        "TAY",
        "TSX",
        "TXA",
        "TXS",
        "TYA"
      ],
      "illegal": [
        "ANC",
        "ARR",
        "ASR",
        "DCP",
        "ISC",
        "JAM",
        "LAS",
        "LAX",
        "NOP",
        "RLA",
        "RRA",
        "SAX",
        "SBC",
        "SBX",
        "SHA",
        "SHS",
        "SHX",
        "SHY",
        "SLO",
        "SRE",
        "XAA"
      ],
      "all": [
        "ADC",
        "ANC",
        "AND",
        "ARR",
        "ASL",
        "ASR",
        "BCC",
        "BCS",
        "BEQ",
        "BIT",
        "BMI",
        "BNE",
        "BPL",
        "BRA",
        "BRK",
        "BVC",
        "BVS",
        "CLC",
        "CLD",
        "CLI",
        "CLV",
        "CMP",
        "CPX",
        "CPY",
        "DCP",
        "DEC",
        "DEX",
        "DEY",
        "EOR",
        "INC",
        "INX",
        "INY",
        "ISC",
        "JAM",
        "JMP",
        "JSR",
        "LAS",
        "LAX",
        "LDA",
        "LDX",
        "LDY",
        "LSR",
        "NOP",
        "ORA",
        "PHA",
        "PHP",
        "PLA",
        "PLP",
        "RLA",
        "ROL",
        "ROR",
        "RRA",
        "RTI",
        "RTS",
        "SAC",
        "SAX",
        "SBC",
        "SBX",
        "SEC",
        "SED",
        "SEI",
        "SHA",
        "SHS",
        "SHX",
        "SHY",
        "SIR",
        "SLO",
        "SRE",
        "STA",
        "STX",
        "STY",
        "TAX",
        "TAY",
        "TSX",
        "TXA",
        "TXS",
        "TYA",
        "XAA"
      ]
    },
    "all_addmodes": {
      "regular": [
        "-",
        "A",
        "#d8",
        "a16",
        "a16,X",
        "a16,Y",
        "(a16)",
        "a8",
        "a8,X",
        "a8,Y",
        "(a8,X)",
        "(a8),Y",
        "r8"
      ],
      "illegal": [
        "-",
        "#d8",
        "a16",
        "a16,X",
        "a16,Y",
        "a8",
        "a8,X",
        "a8,Y",
        "(a8,X)",
        "(a8),Y"
      ],
      "all": [
        "-",
        "A",
        "#d8",
        "a16",
        "a16,X",
        "a16,Y",
        "(a16)",
        "a8",
        "a8,X",
        "a8,Y",
        "(a8,X)",
        "(a8),Y",
        "r8"
      ]
    }
  },
  "65c02": {
    "info": {
      "manufacturer": "WDC",
      "name": "65C02",
      "year": "1983",
      "id": "65c02",
      "basedon": "6502",
      "description": "This is the CMOS-based reimplementation of the 6502 designed by Western Design Center, Inc. It supports all documented features of the original 6502, fixes all known quirks, adds 27 new opcodes and two addressing modes, and guarantees all undocumented opcodes to be NOPs. To distinguish it from derived versions, it is also sometimes called the 65SC02."
    },
    "registers": {
      "registers": [
        "A",
        "X",
        "Y",
        "S",
        "P",
        "PC"
      ],
      "A": {
        "size": "8",
        "description": "Accumulator"
      },
      "X": {
        "size": "8",
        "description": "X Index Register"
      },
      "Y": {
        "size": "8",
        "description": "Y Index Register"
      },
      "S": {
        "size": "8",
        "description": "Stack Pointer"
      },
      "P": {
        "size": "8",
        "description": "Processor Status"
      },
      "PC": {
        "size": "16",
        "description": "Program Counter"
      }
    },
    "vectors": {
      "FFFA": "NMI",
      "FFFC": "RESET",
      "FFFE": "IRQ"
    },
    "flags": {
      "names": "NV-BDIZC",
      "N": "Negative",
      "V": "Overflow",
      "-": "(Expansion)",
      "B": "Break Command",
      "D": "Decimal",
      "I": "Interrupt Disable",
      "Z": "Zero",
      "C": "Carry"
    },
    "opcodes": [
      {
        "illegal": false,
        "mnemo": "BRK",
        "addmode": "-",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TSB",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHP",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TSB",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BPL",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TRB",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLC",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TRB",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JSR",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PLP",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BMI",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a8,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SEC",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a16,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RTI",
        "addmode": "-",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHA",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BVC",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLI",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PHY",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RTS",
        "addmode": "-",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8,X)",
        "cycles": "6+d",
        "mincycles": 6,
        "maxcycles": 7,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STZ",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a8",
        "cycles": "3+d",
        "mincycles": 3,
        "maxcycles": 4,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PLA",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "#d8",
        "cycles": "2+d",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "(a16)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16",
        "cycles": "4+d",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BVS",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8),Y",
        "cycles": "5+p+d",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "p",
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8)",
        "cycles": "5+d",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STZ",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a8,X",
        "cycles": "4+d",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SEI",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16,Y",
        "cycles": "4+p+d",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "p",
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PLY",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "(a16,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16,X",
        "cycles": "4+p+d",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "p",
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BRA",
        "addmode": "r8",
        "cycles": "3+t+p",
        "mincycles": 3,
        "maxcycles": 5,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEY",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "#d8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TXA",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BCC",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8),Y",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a8,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TYA",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16,Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TXS",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STZ",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STZ",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TAY",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TAX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BCS",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a8,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLV",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "TSX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INY",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BNE",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLD",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PHX",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8,X)",
        "cycles": "6+d",
        "mincycles": 6,
        "maxcycles": 7,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a8",
        "cycles": "3+d",
        "mincycles": 3,
        "maxcycles": 4,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "#d8",
        "cycles": "2+d",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16",
        "cycles": "4+d",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BEQ",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8),Y",
        "cycles": "5+p+d",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "p",
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8)",
        "cycles": "5+d",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a8,X",
        "cycles": "4+d",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SED",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16,Y",
        "cycles": "4+p+d",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "p",
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PLX",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16,X",
        "cycles": "4+p+d",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "p",
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      }
    ],
    "operations": {
      "ADC": {
        "category": "arith",
        "flags": "NV----ZC",
        "description": "A + M + C → A, C",
        "documentation": {
          "title": "Add Memory to Accumulator with Carry",
          "text": [
            "This instruction adds the value of memory and carry from the previous operation to the value of the accumulator and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the carry flag when the sum of a binary add exceeds 255 or when the sum of a decimal add exceeds 99, otherwise carry is reset. The overflow flag is set when the sign or bit 7 is changed due to the result exceeding +127 or -128, otherwise overflow is reset. The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. The zero flag is set if the accumulator result is 0, otherwise the zero flag is reset."
          ]
        }
      },
      "AND": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ∧ M → A",
        "documentation": {
          "title": "\"AND\" Memory with Accumulator",
          "text": [
            "The AND instruction transfer the accumulator and memory to the adder which performs a bit-by-bit AND operation and stores the result back in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "ASL": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C ← /M7...M0/ ← 0",
        "documentation": {
          "title": "Arithmetic Shift Left",
          "text": [
            "The shift left instruction shifts either the accumulator or the address memory location 1 bit to the left, with the bit 0 always being set to 0 and the the input bit 7 being stored in the carry flag. ASL either shifts the accumulator left 1 bit or is a read/modify/write instruction that affects only memory.",
            "The instruction does not affect the overflow bit, sets N equal to the result bit 7 (bit 6 in the input), sets Z flag if the result is equal to 0, otherwise resets Z and stores the input bit 7 in the carry flag."
          ]
        }
      },
      "BCC": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on C = 0",
        "documentation": {
          "title": "Branch on Carry Clear",
          "text": [
            "This instruction tests the state of the carry bit and takes a conditional branch if the carry bit is reset.",
            "It affects no flags or registers other than the program counter and then only if the C flag is not on."
          ]
        }
      },
      "BCS": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on C = 1",
        "documentation": {
          "title": "Branch on Carry Set",
          "text": [
            "This instruction takes the conditional branch if the carry flag is on.",
            "BCS does not affect any of the flags or registers except for the program counter and only then if the carry flag is on."
          ]
        }
      },
      "BEQ": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on Z = 1",
        "documentation": {
          "title": "Branch on Result Zero",
          "text": [
            "This instruction could also be called \"Branch on Equal.\"",
            "It takes a conditional branch whenever the Z flag is on or the previ­ ous result is equal to 0.",
            "BEQ does not affect any of the flags or registers other than the program counter and only then when the Z flag is set."
          ]
        }
      },
      "BIT": {
        "category": "logic",
        "flags": "NV----Z-",
        "description": "A ∧ M, M7 → N, M6 → V",
        "documentation": {
          "title": "Test Bits in Memory with Accumulator",
          "text": [
            "This instruction performs an AND between a memory location and the accumulator but does not store the result of the AND into the accumulator.",
            "The bit instruction affects the N flag with N being set to the value of bit 7 of the memory being tested, the V flag with V being set equal to bit 6 of the memory being tested and Z being set by the result of the AND operation between the accumulator and the memory if the result is Zero, Z is reset otherwise. It does not affect the accumulator."
          ]
        }
      },
      "BMI": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on N = 1",
        "documentation": {
          "title": "Branch on Result Minus",
          "text": [
            "This instruction takes the conditional branch if the N bit is set.",
            "BMI does not affect any of the flags or any other part of the machine other than the program counter and then only if the N bit is on."
          ]
        }
      },
      "BNE": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on Z = 0",
        "documentation": {
          "title": "Branch on Result Not Zero",
          "text": [
            "This instruction could also be called \"Branch on Not Equal.\" It tests the Z flag and takes the conditional branch if the Z flag is not on, indicating that the previous result was not zero.",
            "BNE does not affect any of the flags or registers other than the program counter and only then if the Z flag is reset."
          ]
        }
      },
      "BPL": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on N = 0",
        "documentation": {
          "title": "Branch on Result Plus",
          "text": [
            "This instruction is the complementary branch to branch on result minus. It is a conditional branch which takes the branch when the N bit is reset (0). BPL is used to test if the previous result bit 7 was off (0) and branch on result minus is used to determine if the previous result was minus or bit 7 was on (1).",
            "The instruction affects no flags or other registers other than the P counter and only affects the P counter when the N bit is reset."
          ]
        }
      },
      "BRK": {
        "category": "ctrl",
        "flags": "-----1--",
        "description": "PC + 2↓, [FFFE] → PCL, [FFFF] → PCH",
        "documentation": {
          "title": "Break Command",
          "text": [
            "The break command causes the microprocessor to go through an inter­ rupt sequence under program control. This means that the program counter of the second byte after the BRK. is automatically stored on the stack along with the processor status at the beginning of the break instruction. The microprocessor then transfers control to the interrupt vector.",
            "Other than changing the program counter, the break instruction changes no values in either the registers or the flags."
          ]
        }
      },
      "BVC": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on V = 0",
        "documentation": {
          "title": "Branch on Overflow Clear",
          "text": [
            "This instruction tests the status of the V flag and takes the conditional branch if the flag is not set.",
            "BVC does not affect any of the flags and registers other than the program counter and only when the overflow flag is reset."
          ]
        }
      },
      "BVS": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on V = 1",
        "documentation": {
          "title": "Branch on Overflow Set",
          "text": [
            "This instruction tests the V flag and takes the conditional branch if V is on.",
            "BVS does not affect any flags or registers other than the program, counter and only when the overflow flag is set."
          ]
        }
      },
      "CLC": {
        "category": "flags",
        "flags": "-------0",
        "description": "0 → C",
        "documentation": {
          "title": "Clear Carry Flag",
          "text": [
            "This instruction initializes the carry flag to a 0. This op­ eration should normally precede an ADC loop. It is also useful when used with a R0L instruction to clear a bit in memory.",
            "This instruction affects no registers in the microprocessor and no flags other than the carry flag which is reset."
          ]
        }
      },
      "CLD": {
        "category": "flags",
        "flags": "----0---",
        "description": "0 → D",
        "documentation": {
          "title": "Clear Decimal Mode",
          "text": [
            "This instruction sets the decimal mode flag to a 0. This all subsequent ADC and SBC instructions to operate as simple operations.",
            "CLD affects no registers in the microprocessor and no flags other than the decimal mode flag which is set to a 0."
          ]
        }
      },
      "CLI": {
        "category": "flags",
        "flags": "-----0--",
        "description": "0 → I",
        "documentation": {
          "title": "Clear Interrupt Disable",
          "text": [
            "This instruction initializes the interrupt disable to a 0. This allows the microprocessor to receive interrupts.",
            "It affects no registers in the microprocessor and no flags other than the interrupt disable which is cleared."
          ]
        }
      },
      "CLV": {
        "category": "flags",
        "flags": "-0------",
        "description": "0 → V",
        "documentation": {
          "title": "Clear Overflow Flag",
          "text": [
            "This instruction clears the overflow flag to a 0. This com­ mand is used in conjunction with the set overflow pin which can change the state of the overflow flag with an external signal.",
            "CLV affects no registers in the microprocessor and no flags other than the overflow flag which is set to a 0."
          ]
        }
      },
      "CMP": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "A - M",
        "documentation": {
          "title": "Compare Memory and Accumulator",
          "text": [
            "This instruction subtracts the contents of memory from the contents of the accumulator.",
            "The use of the CMP affects the following flags: Z flag is set on an equal comparison, reset otherwise; the N flag is set or reset by the result bit 7, the carry flag is set when the value in memory is less than or equal to the accumulator, reset when it is greater than the accumulator. The accumulator is not affected."
          ]
        }
      },
      "CPX": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "X - M",
        "documentation": {
          "title": "Compare Index Register X To Memory",
          "text": [
            "This instruction subtracts the value of the addressed memory location from the content of index register X using the adder but does not store the result; therefore, its only use is to set the N, Z and C flags to allow for comparison between the index register X and the value in memory.",
            "The CPX instruction does not affect any register in the machine; it also does not affect the overflow flag. It causes the carry to be set on if the absolute value of the index register X is equal to or greater than the data from memory. If the value of the memory is greater than the content of the index register X, carry is reset. If the results of the subtraction contain a bit 7, then the N flag is set, if not, it is reset. If the value in memory is equal to the value in index register X, the Z flag is set, otherwise it is reset."
          ]
        }
      },
      "CPY": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "Y - M",
        "documentation": {
          "title": "Compare Index Register Y To Memory",
          "text": [
            "This instruction performs a two's complement subtraction between the index register Y and the specified memory location. The results of the subtraction are not stored anywhere. The instruction is strict­ly used to set the flags.",
            "CPY affects no registers in the microprocessor and also does not affect the overflow flag. If the value in the index register Y is equal to or greater than the value in the memory, the carry flag will be set, otherwise it will be cleared. If the results of the subtract- tion contain bit 7 on the N bit will be set, otherwise it will be cleared. If the value in the index register Y and the value in the memory are equal, the zero flag will be set, otherwise it will be cleared."
          ]
        }
      },
      "DEC": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "M - 1 → M",
        "documentation": {
          "title": "Decrement Memory By One",
          "text": [
            "This instruction subtracts 1, in two's complement, from the contents of the addressed memory location.",
            "The decrement instruction does not affect any internal register in the microprocessor. It does not affect the carry or overflow flags. If bit 7 is on as a result of the decrement, then the N flag is set, otherwise it is reset. If the result of the decrement is 0, the Z flag is set, other­wise it is reset."
          ]
        }
      },
      "DEX": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "X - 1 → X",
        "documentation": {
          "title": "Decrement Index Register X By One",
          "text": [
            "This instruction subtracts one from the current value of the index register X and stores the result in the index register X.",
            "DEX does not affect the carry or overflow flag, it sets the N flag if it has bit 7 on as a result of the decrement, otherwise it resets the N flag; sets the Z flag if X is a 0 as a result of the decrement, otherwise it resets the Z flag."
          ]
        }
      },
      "DEY": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "Y - 1 → Y",
        "documentation": {
          "title": "Decrement Index Register Y By One",
          "text": [
            "This instruction subtracts one from the current value in the in­ dex register Y and stores the result into the index register Y. The result does not affect or consider carry so that the value in the index register Y is decremented to 0 and then through 0 to FF.",
            "Decrement Y does not affect the carry or overflow flags; if the Y register contains bit 7 on as a result of the decrement the N flag is set, otherwise the N flag is reset. If the Y register is 0 as a result of the decrement, the Z flag is set otherwise the Z flag is reset. This instruction only affects the index register Y."
          ]
        }
      },
      "EOR": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ⊻ M → A",
        "documentation": {
          "title": "\"Exclusive OR\" Memory with Accumulator",
          "text": [
            "The EOR instruction transfers the memory and the accumulator to the adder which performs a binary \"EXCLUSIVE OR\" on a bit-by-bit basis and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "INC": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "M + 1 → M",
        "documentation": {
          "title": "Increment Memory By One",
          "text": [
            "This instruction adds 1 to the contents of the addressed memory loca­tion.",
            "The increment memory instruction does not affect any internal registers and does not affect the carry or overflow flags. If bit 7 is on as the result of the increment,N is set, otherwise it is reset; if the increment causes the result to become 0, the Z flag is set on, otherwise it is reset."
          ]
        }
      },
      "INX": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "X + 1 → X",
        "documentation": {
          "title": "Increment Index Register X By One",
          "text": [
            "Increment X adds 1 to the current value of the X register. This is an 8-bit increment which does not affect the carry operation, therefore, if the value of X before the increment was FF, the resulting value is 00.",
            "INX does not affect the carry or overflow flags; it sets the N flag if the result of the increment has a one in bit 7, otherwise resets N; sets the Z flag if the result of the increment is 0, otherwise it resets the Z flag.",
            "INX does not affect any other register other than the X register."
          ]
        }
      },
      "INY": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "Y + 1 → Y",
        "documentation": {
          "title": "Increment Index Register Y By One",
          "text": [
            "Increment Y increments or adds one to the current value in the Y register, storing the result in the Y register. As in the case of INX the primary application is to step thru a set of values using the Y register.",
            "The INY does not affect the carry or overflow flags, sets the N flag if the result of the increment has a one in bit 7, otherwise resets N, sets Z if as a result of the increment the Y register is zero otherwise resets the Z flag."
          ]
        }
      },
      "JMP": {
        "category": "ctrl",
        "flags": "--------",
        "description": "[PC + 1] → PCL, [PC + 2] → PCH",
        "documentation": {
          "title": "JMP Indirect",
          "text": [
            "This instruction establishes a new valne for the program counter.",
            "It affects only the program counter in the microprocessor and affects no flags in the status register."
          ]
        }
      },
      "JSR": {
        "category": "ctrl",
        "flags": "--------",
        "description": "PC + 2↓, [PC + 1] → PCL, [PC + 2] → PCH",
        "documentation": {
          "title": "Jump To Subroutine",
          "text": [
            "This instruction transfers control of the program counter to a subroutine location but leaves a return pointer on the stack to allow the user to return to perform the next instruction in the main program after the subroutine is complete. To accomplish this, JSR instruction stores the program counter address which points to the last byte of the jump instruc­ tion onto the stack using the stack pointer. The stack byte contains the program count high first, followed by program count low. The JSR then transfers the addresses following the jump instruction to the program counter low and the program counter high, thereby directing the program to begin at that new address.",
            "The JSR instruction affects no flags, causes the stack pointer to be decremented by 2 and substitutes new values into the program counter low and the program counter high."
          ]
        }
      },
      "LDA": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → A",
        "documentation": {
          "title": "Load Accumulator with Memory",
          "text": [
            "When instruction LDA is executed by the microprocessor, data is transferred from memory to the accumulator and stored in the accumulator.",
            "LDA affects the contents of the accumulator, does not affect the carry or overflow flags; sets the zero flag if the accumulator is zero as a result of the LDA, otherwise resets the zero flag; sets the negative flag if bit 7 of the accumulator is a 1, other­ wise resets the negative flag."
          ]
        }
      },
      "LDX": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → X",
        "documentation": {
          "title": "Load Index Register X From Memory",
          "text": [
            "Load the index register X from memory.",
            "LDX does not affect the C or V flags; sets Z if the value loaded was zero, otherwise resets it; sets N if the value loaded in bit 7 is a 1; otherwise N is reset, and affects only the X register."
          ]
        }
      },
      "LDY": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → Y",
        "documentation": {
          "title": "Load Index Register Y From Memory",
          "text": [
            "Load the index register Y from memory.",
            "LDY does not affect the C or V flags, sets the N flag if the value loaded in bit 7 is a 1, otherwise resets N, sets Z flag if the loaded value is zero otherwise resets Z and only affects the Y register."
          ]
        }
      },
      "LSR": {
        "category": "shift",
        "flags": "0-----ZC",
        "description": "0 → /M7...M0/ → C",
        "documentation": {
          "title": "Logical Shift Right",
          "text": [
            "This instruction shifts either the accumulator or a specified memory location 1 bit to the right, with the higher bit of the result always being set to 0, and the low bit which is shifted out of the field being stored in the carry flag.",
            "The shift right instruction either affects the accumulator by shift­ing it right 1 or is a read/modify/write instruction which changes a speci­fied memory location but does not affect any internal registers. The shift right does not affect the overflow flag. The N flag is always reset. The Z flag is set if the result of the shift is 0 and reset otherwise. The carry is set equal to bit 0 of the input."
          ]
        }
      },
      "NOP": {
        "category": "nop",
        "flags": "--------",
        "description": "No operation"
      },
      "ORA": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ∨ M → A",
        "documentation": {
          "title": "\"OR\" Memory with Accumulator",
          "text": [
            "The ORA instruction transfers the memory and the accumulator to the adder which performs a binary \"OR\" on a bit-by-bit basis and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "PHA": {
        "category": "stack",
        "flags": "--------",
        "description": "A↓",
        "documentation": {
          "title": "Push Accumulator On Stack",
          "text": [
            "This instruction transfers the current value of the accumulator to the next location on the stack, automatically decrementing the stack to point to the next empty location.",
            "The Push A instruction only affects the stack pointer register which is decremented by 1 as a result of the operation. It affects no flags."
          ]
        }
      },
      "PHP": {
        "category": "stack",
        "flags": "--------",
        "description": "P↓",
        "documentation": {
          "title": "Push Processor Status On Stack",
          "text": [
            "This instruction transfers the contents of the processor status reg­ ister unchanged to the stack, as governed by the stack pointer.",
            "The PHP instruction affects no registers or flags in the micropro­cessor."
          ]
        }
      },
      "PLA": {
        "category": "stack",
        "flags": "N-----Z-",
        "description": "A↑",
        "documentation": {
          "title": "Pull Accumulator From Stack",
          "text": [
            "This instruction adds 1 to the current value of the stack pointer and uses it to address the stack and loads the contents of the stack into the A register.",
            "The PLA instruction does not affect the carry or overflow flags. It sets N if the bit 7 is on in accumulator A as a result of instructions, otherwise it is reset. If accumulator A is zero as a result of the PLA, then the Z flag is set, otherwise it is reset. The PLA instruction changes content of the accumulator A to the contents of the memory location at stack register plus 1 and also increments the stack register."
          ]
        }
      },
      "PLP": {
        "category": "stack",
        "flags": "NV--DIZC",
        "description": "P↑",
        "documentation": {
          "title": "Pull Processor Status From Stack",
          "text": [
            "This instruction transfers the next value on the stack to the Proces­ sor Status register, thereby changing all of the flags and setting the mode switches to the values from the stack.",
            "The PLP instruction affects no registers in the processor other than the status register. This instruction could affect all flags in the status register."
          ]
        }
      },
      "ROL": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C ← /M7...M0/ ← C",
        "documentation": {
          "title": "Rotate Left",
          "text": [
            "The rotate left instruction shifts either the accumulator or addressed memory left 1 bit, with the input carry being stored in bit 0 and with the input bit 7 being stored in the carry flags.",
            "The ROL instruction either shifts the accumulator left 1 bit and stores the carry in accumulator bit 0 or does not affect the internal reg­isters at all. The ROL instruction sets carry equal to the input bit 7, sets N equal to the input bit 6 , sets the Z flag if the result of the ro­ tate is 0, otherwise it resets Z and does not affect the overflow flag at all."
          ]
        }
      },
      "ROR": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C → /M7...M0/ → C",
        "documentation": {
          "title": "Rotate Right",
          "text": [
            "The rotate right instruction shifts either the accumulator or addressed memory right 1 bit with bit 0 shifted into the carry and carry shifted into bit 7.",
            "The ROR instruction either shifts the accumulator right 1 bit and stores the carry in accumulator bit 7 or does not affect the internal regis­ ters at all. The ROR instruction sets carry equal to input bit 0, sets N equal to the input carry and sets the Z flag if the result of the rotate is 0; otherwise it resets Z and does not affect the overflow flag at all.",
            "(Available on Microprocessors after June, 1976)"
          ]
        }
      },
      "RTI": {
        "category": "ctrl",
        "flags": "NV--DIZC",
        "description": "P↑ PC↑",
        "documentation": {
          "title": "Return From Interrupt",
          "text": [
            "This instruction transfers from the stack into the microprocessor the processor status and the program counter location for the instruction which was interrupted. By virtue of the interrupt having stored this data before executing the instruction and thei fact that the RTI reinitializes the microprocessor to the same state as when it was interrupted, the combination of interrupt plus RTI allows truly reentrant coding.",
            "The RTI instruction reinitializes all flags to the position to the point they were at the time the interrupt was taken and sets the program counter back to its pre-interrupt state. It affects no other registers in the microprocessor."
          ]
        }
      },
      "RTS": {
        "category": "ctrl",
        "flags": "--------",
        "description": "PC↑, PC + 1 → PC",
        "documentation": {
          "title": "Return From Subroutme",
          "text": [
            "This instruction loads the program count low and program count high from the stack into the program counter and increments the program counter so that it points to the instruction following the JSR. The stack pointer is adjusted by incrementing it twice.",
            "The RTS instruction does not affect any flags and affects only PCL and PCH."
          ]
        }
      },
      "SBC": {
        "category": "arith",
        "flags": "NV----ZC",
        "description": "A - M - ~C → A",
        "documentation": {
          "title": "Subtract Memory from Accumulator with Borrow",
          "text": [
            "This instruction subtracts the value of memory and borrow from the value of the accumulator, using two's complement arithmetic, and stores the result in the accumulator. Borrow is defined as the carry flag complemented; therefore, a resultant carry flag indicates that a borrow has not occurred.",
            "This instruction affects the accumulator. The carry flag is set if the result is greater than or equal to 0. The carry flag is reset when the result is less than 0, indicating a borrow. The over­flow flag is set when the result exceeds +127 or -127, otherwise it is reset. The negative flag is set if the result in the accumulator has bit 7 on, otherwise it is reset. The Z flag is set if the result in the accumulator is 0, otherwise it is reset."
          ]
        }
      },
      "SEC": {
        "category": "flags",
        "flags": "-------1",
        "description": "1 → C",
        "documentation": {
          "title": "Set Carry Flag",
          "text": [
            "This instruction initializes the carry flag to a 1. This op eration should normally precede a SBC loop. It is also useful when used with a ROL instruction to initialize a bit in memory to a 1.",
            "This instruction affects no registers in the microprocessor and no flags other than the carry flag which is set."
          ]
        }
      },
      "SED": {
        "category": "flags",
        "flags": "----1---",
        "description": "1 → D",
        "documentation": {
          "title": "Set Decimal Mode",
          "text": [
            "This instruction sets the decimal mode flag D to a 1. This makes all subsequent ADC and SBC instructions operate as a decimal arithmetic operation.",
            "SED affects no registers in the microprocessor and no flags other than the decimal mode which is set to a 1."
          ]
        }
      },
      "SEI": {
        "category": "flags",
        "flags": "-----1--",
        "description": "1 → I",
        "documentation": {
          "title": "Set Interrupt Disable",
          "text": [
            "This instruction initializes the interrupt disable to a 1. It is used to mask interrupt requests during system reset operations and during interrupt commands.",
            "It affects no registers in the microprocessor and no flags other than the interrupt disable which is set."
          ]
        }
      },
      "STA": {
        "category": "load",
        "flags": "--------",
        "description": "A → M",
        "documentation": {
          "title": "Store Accumulator in Memory",
          "text": [
            "This instruction transfers the contents of the accumulator to memory.",
            "This instruction affects none of the flags in the processor status register and does not affect the accumulator."
          ]
        }
      },
      "STX": {
        "category": "load",
        "flags": "--------",
        "description": "X → M",
        "documentation": {
          "title": "Store Index Register X In Memory",
          "text": [
            "Transfers value of X register to addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "STY": {
        "category": "load",
        "flags": "--------",
        "description": "Y → M",
        "documentation": {
          "title": "Store Index Register Y In Memory",
          "text": [
            "Transfer the value of the Y register to the addressed memory location.",
            "STY does not affect any flags or registers in the microprocessor."
          ]
        }
      },
      "TAX": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "A → X",
        "documentation": {
          "title": "Transfer Accumulator To Index X",
          "text": [
            "This instruction takes the value from accumulator A and trans­ fers or loads it into the index register X without disturbing the content of the accumulator A.",
            "TAX only affects the index register X, does not affect the carry or overflow flags. The N flag is set if the resultant value in the index register X has bit 7 on, otherwise N is reset. The Z bit is set if the content of the register X is 0 as aresult of theopera­ tion, otherwise it is reset."
          ]
        }
      },
      "TAY": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "A → Y",
        "documentation": {
          "title": "Transfer Accumula Tor To Index Y",
          "text": [
            "This instruction moves the value of the accumulator into index register Y without affecting the accumulator.",
            "TAY instruction only affects the Y register and does not affect either the carry or overflow flags. If the index register Y has bit 7 on, then N is set, otherwise it is reset. If the content of the index register Y equals 0 as a result of the operation, Z is set on, otherwise it is reset."
          ]
        }
      },
      "TSX": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "S → X",
        "documentation": {
          "title": "Transfer Stack Pointer To Index X",
          "text": [
            "This instruction transfers the value in the stack pointer to the index register X.",
            "TSX does not affect the carry or overflow flags. It sets N if bit 7 is on in index X as a result of the instruction, otherwise it is reset. If index X is zero as a result of the TSX, the Z flag is set, other­ wise it is reset. TSX changes the value of index X, making it equal to the content of the stack pointer."
          ]
        }
      },
      "TXA": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "X → A",
        "documentation": {
          "title": "Transfer Index X To Accumulator",
          "text": [
            "This instruction moves the value that is in the index register X to the accumulator A without disturbing the content of the index register X.",
            "TXA does not affect any register other than the accumula­tor and does not affect the carry or overflow flag. If the result in A has bit 7 on, then the N flag is set, otherwise it is reset. If the resultant value in the accumulator is 0, then the Z flag is set, other­ wise it is reset."
          ]
        }
      },
      "TXS": {
        "category": "trans",
        "flags": "--------",
        "description": "X → S",
        "documentation": {
          "title": "Transfer Index X To Stack Pointer",
          "text": [
            "This instruction transfers the value in the index register X to the stack pointer.",
            "TXS changes only the stack pointer, making it equal to the content of the index register X. It does not affect any of the flags."
          ]
        }
      },
      "TYA": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "Y → A",
        "documentation": {
          "title": "Transfer Index Y To Accumulator",
          "text": [
            "This instruction moves the value that is in the index register Y to accumulator A without disturbing the content of the register Y.",
            "TYA does not affect any other register other than the accumula­ tor and does not affect the carry or overflow flag. If the result in the accumulator A has bit 7 on, the N flag is set, otherwise it is reset. If the resultant value in the accumulator A is 0, then the Z flag is set, otherwise it is reset."
          ]
        }
      },
      "#": {
        "category": "mnemos",
        "flags": "are",
        "description": "based on VICE"
      },
      "ANC": {
        "category": "arith",
        "flags": "*-----**",
        "description": "A ∧ M → A, N → C",
        "documentation": {
          "title": "\"AND\" Memory with Accumulator then Move Negative Flag to Carry Flag",
          "text": [
            "The undocumented ANC instruction performs a bit-by-bit AND operation of the accumulator and memory and stores the result back in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag and the carry flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag and the carry flag."
          ]
        }
      },
      "ARR": {
        "category": "arith",
        "flags": "**----**",
        "description": "(A ∧ M) / 2 → A",
        "documentation": {
          "title": "\"AND\" Accumulator then Rotate Right",
          "text": [
            "The undocumented ARR instruction performs a bit-by-bit \"AND\" operation of the accumulator and memory, then shifts the result right 1 bit with bit 0 shifted into the carry and carry shifted into bit 7. It then stores the result back in the accumulator.",
            "If bit 7 of the result is on, then the N flag is set, otherwise it is reset. The instruction sets the Z flag if the result is 0; otherwise it resets Z.",
            "The V and C flags depends on the Decimal Mode Flag:",
            "In decimal mode, the V flag is set if bit 6 is different than the original data's bit 6, otherwise the V flag is reset. The C flag is set if (operand & 0xF0) + (operand & 0x10) is greater than 0x50, otherwise the C flag is reset.",
            "In binary mode, the V flag is set if bit 6 of the result is different than bit 5 of the result, otherwise the V flag is reset. The C flag is set if the result in the accumulator has bit 6 on, otherwise it is reset."
          ]
        }
      },
      "ASR": {
        "category": "arith",
        "flags": "0-----**",
        "description": "(A ∧ M) / 2 → A",
        "documentation": {
          "title": "\"AND\" then Logical Shift Right",
          "text": [
            "The undocumented ASR instruction performs a bit-by-bit AND operation of the accumulator and memory, then shifts the accumulator 1 bit to the right, with the higher bit of the result always being set to 0, and the low bit which is shifted out of the field being stored in the carry flag.",
            "This instruction affects the accumulator. It does not affect the overflow flag. The N flag is always reset. The Z flag is set if the result of the shift is 0 and reset otherwise. The carry is set equal to bit 0 of the result of the \"AND\" operation."
          ]
        }
      },
      "DCP": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M - 1 → M, A - M",
        "documentation": {
          "title": "Decrement Memory By One then Compare with Accumulator",
          "text": [
            "This undocumented instruction subtracts 1, in two's complement, from the contents of the addressed memory location. It then subtracts the contents of memory from the contents of the accumulator.",
            "The DCP instruction does not affect any internal register in the microprocessor. It does not affect the overflow flag. Z flag is set on an equal comparison, reset otherwise; the N flag is set or reset by the result bit 7, the carry flag is set when the result in memory is less than or equal to the accumulator, reset when it is greater than the accumulator."
          ]
        }
      },
      "ISC": {
        "category": "arith",
        "flags": "**----**",
        "description": "M + 1 → M, A - M → A",
        "documentation": {
          "title": "Increment Memory By One then SBC then Subtract Memory from Accumulator with Borrow",
          "text": [
            "This undocumented instruction adds 1 to the contents of the addressed memory loca­tion. It then subtracts the value of the result in memory and borrow from the value of the accumulator, using two's complement arithmetic, and stores the result in the accumulator.",
            "This instruction affects the accumulator. The carry flag is set if the result is greater than or equal to 0. The carry flag is reset when the result is less than 0, indicating a borrow. The over­flow flag is set when the result exceeds +127 or -127, otherwise it is reset. The negative flag is set if the result in the accumulator has bit 7 on, otherwise it is reset. The Z flag is set if the result in the accumulator is 0, otherwise it is reset."
          ]
        }
      },
      "JAM": {
        "category": "kil",
        "flags": "--------",
        "description": "Stop execution",
        "documentation": {
          "title": "Halt the CPU",
          "text": [
            "This undocumented instruction stops execution. The microprocessor will not fetch further instructions, and will neither handle IRQs nor NMIs. It will handle a RESET though."
          ]
        }
      },
      "LAS": {
        "category": "load",
        "flags": "*-----*-",
        "description": "M ∧ S → A, X, S",
        "documentation": {
          "title": "\"AND\" Memory with Stack Pointer",
          "text": [
            "This undocumented instruction performs a bit-by-bit \"AND\" operation of the stack pointer and memory and stores the result back in the accumulator, the index register X and the stack pointer.",
            "The LAS instruction does not affect the carry or overflow flags. It sets N if the bit 7 of the result is on, otherwise it is reset. If the result is zero, then the Z flag is set, otherwise it is reset."
          ]
        }
      },
      "LAX": {
        "category": "load",
        "flags": "*-----*-",
        "description": "M → A, X",
        "documentation": {
          "title": "Load Accumulator and Index Register X From Memory",
          "text": [
            "The undocumented LAX instruction loads the accumulator and the index register X from memory.",
            "LAX does not affect the C or V flags; sets Z if the value loaded was zero, otherwise resets it; sets N if the value loaded in bit 7 is a 1; otherwise N is reset, and affects only the X register."
          ]
        }
      },
      "RLA": {
        "category": "arith",
        "flags": "*-----**",
        "description": "C ← /M7...M0/ ← C, A ∧ M → A",
        "documentation": {
          "title": "Rotate Left then \"AND\" with Accumulator",
          "text": [
            "The undocumented RLA instruction shifts the addressed memory left 1 bit, with the input carry being stored in bit 0 and with the input bit 7 being stored in the carry flags. It then performs a bit-by-bit AND operation of the result and the value of the accumulator and stores the result back in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "RRA": {
        "category": "arith",
        "flags": "**----**",
        "description": "C → /M7...M0/ → C, A + M + C → A",
        "documentation": {
          "title": "Rotate Right and Add Memory to Accumulator",
          "text": [
            "The undocumented RRA instruction shifts the addressed memory right 1 bit with bit 0 shifted into the carry and carry shifted into bit 7. It then adds the result and generated carry to the value of the accumulator and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the carry flag when the sum of a binary add exceeds 255 or when the sum of a decimal add exceeds 99, otherwise carry is reset. The overflow flag is set when the sign or bit 7 is changed due to the result exceeding +127 or -128, otherwise overflow is reset. The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. The zero flag is set if the accumulator result is 0, otherwise the zero flag is reset."
          ]
        }
      },
      "SAX": {
        "category": "load",
        "flags": "--------",
        "description": "A ∧ X → M",
        "documentation": {
          "title": "Store Accumulator \"AND\" Index Register X in Memory",
          "text": [
            "The undocumented SAX instruction performs a bit-by-bit AND operation of the value of the accumulator and the value of the index register X and stores the result in memory.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SBX": {
        "category": "arith",
        "flags": "*-----**",
        "description": "(A ∧ X) - M → X",
        "documentation": {
          "title": "Subtract Memory from Accumulator \"AND\" Index Register X",
          "text": [
            "This undocumented instruction performs a bit-by-bit \"AND\" of the value of the accumulator and the index register X and subtracts the value of memory from this result, using two's complement arithmetic, and stores the result in the index register X.",
            "This instruction affects the index register X. The carry flag is set if the result is greater than or equal to 0. The carry flag is reset when the result is less than 0, indicating a borrow. The negative flag is set if the result in index register X has bit 7 on, otherwise it is reset. The Z flag is set if the result in index register X is 0, otherwise it is reset. The over­flow flag not affected at all."
          ]
        }
      },
      "SHA": {
        "category": "load",
        "flags": "--------",
        "description": "A ∧ X ∧ V → M",
        "documentation": {
          "title": "Store Accumulator \"AND\" Index Register X \"AND\" Value",
          "text": [
            "The undocumented SHA instruction performs a bit-by-bit AND operation of the following three operands: The first two are the accumulator and the index register X.",
            "The third operand depends on the addressing mode. In the zero page indirect Y-indexed case, the third operand is the data in memory at the given zero page address (ignoring the the addressing mode's Y offset) plus 1. In the Y-indexed absolute case, it is the upper 8 bits of the given address (ignoring the the addressing mode's Y offset), plus 1.",
            "It then transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SHS": {
        "category": "trans",
        "flags": "--------",
        "description": "A ∧ X → S, S ∧ (H + 1) → M",
        "documentation": {
          "title": "Transfer Accumulator \"AND\" Index Register X to Stack Pointer then Store Stack Pointer \"AND\" Hi-Byte In Memory",
          "text": [
            "The undocumented SHS instruction performs a bit-by-bit AND operation of the value of the accumulator and the value of the index register X and stores the result in the stack pointer. It then performs a bit-by-bit AND operation of the resulting stack pointer and the upper 8 bits of the given address (ignoring the addressing mode's Y offset), plus 1, and transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SHX": {
        "category": "load",
        "flags": "--------",
        "description": "X ∧ (H + 1) → M",
        "documentation": {
          "title": "Store Index Register X \"AND\" Value",
          "text": [
            "The undocumented SHX instruction performs a bit-by-bit AND operation of the index register X and the upper 8 bits of the given address (ignoring the the addressing mode's Y offset), plus 1. It then transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SHY": {
        "category": "load",
        "flags": "--------",
        "description": "Y ∧ (H + 1) → M",
        "documentation": {
          "title": "Store Index Register Y \"AND\" Value",
          "text": [
            "The undocumented SHY instruction performs a bit-by-bit AND operation of the index register Y and the upper 8 bits of the given address (ignoring the the addressing mode's X offset), plus 1. It then transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SLO": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M * 2 → M, A ∨ M → A",
        "documentation": {
          "title": "Arithmetic Shift Left then \"OR\" Memory with Accumulator",
          "text": [
            "The undocumented SLO instruction shifts the address memory location 1 bit to the left, with the bit 0 always being set to 0 and the bit 7 output always being contained in the carry flag. It then performs a bit-by-bit \"OR\" operation on the result and the accumulator and stores the result in the accumulator.",
            "The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. It sets Z flag if the result is equal to 0, otherwise resets Z and stores the input bit 7 in the carry flag."
          ]
        }
      },
      "SRE": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M / 2 → M, A ⊻ M → A",
        "documentation": {
          "title": "Logical Shift Right then \"Exclusive OR\" Memory with Accumulator",
          "text": [
            "The undocumented SRE instruction shifts the specified memory location 1 bit to the right, with the higher bit of the result always being set to 0, and the low bit which is shifted out of the field being stored in the carry flag. It then performs a bit-by-bit \"EXCLUSIVE OR\" of the result and the value of the accumulator and stores the result in the accumulator.",
            "This instruction affects the accumulator. It does not affect the overflow flag. The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. The Z flag is set if the result is 0 and reset otherwise. The carry is set equal to input bit 0."
          ]
        }
      },
      "XAA": {
        "category": "arith",
        "flags": "*-----*-",
        "description": "(A ∨ V) ∧ X ∧ M → A",
        "documentation": {
          "title": "Non-deterministic Operation of Accumulator, Index Register X, Memory and Bus Contents",
          "text": [
            "The operation of the undocumented XAA instruction depends on the individual microprocessor. On most machines, it performs a bit-by-bit AND operation of the following three operands: The first two are the index register X and memory.",
            "The third operand is the result of a bit-by-bit AND operation of the accumulator and a magic component. This magic component depends on the individual microprocessor and is usually one of $00, $EE, $EF, $FE and $FF, and may be influenced by the RDY pin, leftover contents of the data bus, the temperature of the microprocessor, the supplied voltage, and other factors.",
            "On some machines, additional bits of the result may be set or reset depending on non-deterministic factors.",
            "It then transfers the result to the accumulator.",
            "XAA does not affect the C or V flags; sets Z if the value loaded was zero, otherwise resets it; sets N if the result in bit 7 is a 1; otherwise N is reset."
          ]
        }
      },
      "BRA": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch Always",
        "documentation": {
          "title": "Branch Always",
          "text": [
            "This instruction takes an unconditional branch.",
            "BRA does not affect any of the flags or any other part of the machine other than the program counter."
          ]
        }
      },
      "PHX": {
        "category": "stack",
        "flags": "--------",
        "description": "X↓",
        "documentation": {
          "title": "Push Index Register X On Stack",
          "text": [
            "This instruction transfers the current value of the index register X to the next location on the stack, automatically decrementing the stack to point to the next empty location.",
            "The Push X instruction only affects the stack pointer register which is decremented by 1 as a result of the operation. It affects no flags."
          ]
        }
      },
      "PHY": {
        "category": "stack",
        "flags": "--------",
        "description": "Y↑",
        "documentation": {
          "title": "Push Index Register Y On Stack",
          "text": [
            "This instruction transfers the current value of the index register Y to the next location on the stack, automatically decrementing the stack to point to the next empty location.",
            "The Push Y instruction only affects the stack pointer register which is decremented by 1 as a result of the operation. It affects no flags."
          ]
        }
      },
      "PLX": {
        "category": "stack",
        "flags": "N-----Z-",
        "description": "X↑",
        "documentation": {
          "title": "Pull Index Register X From Stack",
          "text": [
            "This instruction adds 1 to the current value of the stack pointer and uses it to address the stack and loads the contents of the stack into the X register.",
            "The PLX instruction does not affect the carry or overflow flags. It sets N if the bit 7 is on in index register X as a result of instructions, otherwise it is reset. If index register X is zero as a result of the PLA, then the Z flag is set, otherwise it is reset. The PLX instruction changes content of the index register X to the contents of the memory location at stack register plus 1 and also increments the stack register."
          ]
        }
      },
      "PLY": {
        "category": "stack",
        "flags": "N-----Z-",
        "description": "Y↑",
        "documentation": {
          "title": "Pull Index Register Y From Stack",
          "text": [
            "This instruction adds 1 to the current value of the stack pointer and uses it to address the stack and loads the contents of the stack into the Y register.",
            "The PLY instruction does not affect the carry or overflow flags. It sets N if the bit 7 is on in index register Y as a result of instructions, otherwise it is reset. If index register Y is zero as a result of the PLA, then the Z flag is set, otherwise it is reset. The PLY instruction changes content of the index register Y to the contents of the memory location at stack register plus 1 and also increments the stack register."
          ]
        }
      },
      "STZ": {
        "category": "load",
        "flags": "--------",
        "description": "0 → M",
        "documentation": {
          "title": "Store Zero In Memory",
          "text": [
            "Transfers the value 0 to addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "TRB": {
        "category": "logic",
        "flags": "------Z-",
        "description": "~A ∧ M → M",
        "documentation": {
          "title": "Test And Reset Memory Bits With Accumulator",
          "text": [
            "This instruction tests and resets bits in memory, using the accumulator for both a test mask, and a reset mask. It performs a logical AND between the inverted bits of the accumulator and the bits in memory, storing the result back into memory.",
            "The zero flag is set if all bits of the result of the AND are zero, otherwise it is reset."
          ]
        }
      },
      "TSB": {
        "category": "logic",
        "flags": "------Z-",
        "description": "A ∨ M → M",
        "documentation": {
          "title": "Test And Set Memory Bits With Accumulator",
          "text": [
            "This instruction tests and sets bits in memory, using the accumulator for both a test mask, and a set mask. It performs a logical OR between the bits of the accumulator and the bits in memory, storing the result back into memory.",
            "The zero flag is set if all bits of the result of the OR are zero, otherwise it is reset."
          ]
        }
      }
    },
    "mnemos": {
      "ADC": {
        "description": "Add with Carry"
      },
      "AND": {
        "description": "Logical AND"
      },
      "ASL": {
        "description": "Arithmetic Shift Left"
      },
      "BCC": {
        "description": "Branch if Carry Clear"
      },
      "BCS": {
        "description": "Branch if Carry Set"
      },
      "BEQ": {
        "description": "Branch if Equal"
      },
      "BIT": {
        "description": "Bit Test"
      },
      "BMI": {
        "description": "Branch if Minus"
      },
      "BNE": {
        "description": "Branch if Not Equal"
      },
      "BPL": {
        "description": "Branch if Plus"
      },
      "BRK": {
        "description": "Force Interrupt"
      },
      "BVC": {
        "description": "Branch if Overflow Clear"
      },
      "BVS": {
        "description": "Branch if Overflow Set"
      },
      "CLC": {
        "description": "Clear Carry Flag"
      },
      "CLD": {
        "description": "Clear Decimal Mode"
      },
      "CLI": {
        "description": "Clear Interrupt Disable"
      },
      "CLV": {
        "description": "Clear Overflow Flag"
      },
      "CMP": {
        "description": "Compare"
      },
      "CPX": {
        "description": "Compare X Register"
      },
      "CPY": {
        "description": "Compare Y Register"
      },
      "DEC": {
        "description": "Decrement Memory"
      },
      "DEX": {
        "description": "Decrement X Register"
      },
      "DEY": {
        "description": "Decrement Y Register"
      },
      "EOR": {
        "description": "Exclusive OR"
      },
      "INC": {
        "description": "Increment Memory"
      },
      "INX": {
        "description": "Increment X Register"
      },
      "INY": {
        "description": "Increment Y Register"
      },
      "JMP": {
        "description": "Jump"
      },
      "JSR": {
        "description": "Jump to Subroutine"
      },
      "LDA": {
        "description": "Load Accumulator"
      },
      "LDX": {
        "description": "Load X Register"
      },
      "LDY": {
        "description": "Load Y Register"
      },
      "LSR": {
        "description": "Logical Shift Right"
      },
      "NOP": {
        "description": "No Operation"
      },
      "ORA": {
        "description": "Logical OR"
      },
      "PHA": {
        "description": "Push Accumulator"
      },
      "PHP": {
        "description": "Push Processor Status"
      },
      "PLA": {
        "description": "Pull Accumulator"
      },
      "PLP": {
        "description": "Pull Processor Status"
      },
      "ROL": {
        "description": "Rotate Left"
      },
      "ROR": {
        "description": "Rotate Right"
      },
      "RTI": {
        "description": "Return from Interrupt"
      },
      "RTS": {
        "description": "Return from Subroutine"
      },
      "SBC": {
        "description": "Subtract with Carry"
      },
      "SEC": {
        "description": "Set Carry Flag"
      },
      "SED": {
        "description": "Set Decimal Flag"
      },
      "SEI": {
        "description": "Set Interrupt Disable"
      },
      "STA": {
        "description": "Store Accumulator"
      },
      "STX": {
        "description": "Store X Register"
      },
      "STY": {
        "description": "Store Y Register"
      },
      "TAX": {
        "description": "Transfer Accumulator to X"
      },
      "TAY": {
        "description": "Transfer Accumulator to Y"
      },
      "TSX": {
        "description": "Transfer Stack Pointer to X"
      },
      "TXA": {
        "description": "Transfer X to Accumulator"
      },
      "TXS": {
        "description": "Transfer X to Stack Pointer"
      },
      "TYA": {
        "description": "Transfer Y to Accumulator"
      },
      "BRA": {
        "description": "Branch Always"
      },
      "PHX": {
        "description": "Push X Register"
      },
      "PHY": {
        "description": "Push Y Register"
      },
      "PLX": {
        "description": "Pull X Register"
      },
      "PLY": {
        "description": "Pull Y Register"
      },
      "STZ": {
        "description": "Store Zero"
      },
      "TRB": {
        "description": "Test and Reset Memory Bits"
      },
      "TSB": {
        "description": "Test and Set Memory Bits"
      }
    },
    "addmodes": {
      "-": {
        "bytes": "1",
        "syntax": "",
        "description": "Implied",
        "documentation": {
          "title": "Implied",
          "text": [
            "In the implied addressing mode, the address containing the operand is implicitly stated in the operation code of the instruction."
          ]
        }
      },
      "A": {
        "bytes": "1",
        "syntax": "A",
        "description": "Accumulator",
        "documentation": {
          "title": "Accumulator",
          "text": [
            "This form of addressing is represented with a one byte instruction, implying an operation on the accumulator."
          ]
        }
      },
      "#d8": {
        "bytes": "2",
        "syntax": "#$nn",
        "description": "Immediate",
        "documentation": {
          "title": "Immediate",
          "text": [
            "In immediate addressing, the operand is contained in the second byte of the instruction, with no further memory addressing required."
          ]
        }
      },
      "a8": {
        "bytes": "2",
        "syntax": "$nn",
        "description": "Zero Page",
        "documentation": {
          "title": "Zero Page",
          "text": [
            "The zero page instructions allow for shorter code and execution times by only fetching the second byte of the instruction and assuming a zero high address byte. Careful use of the zero page can result in significant increase in code efficiency."
          ]
        }
      },
      "a8,X": {
        "bytes": "2",
        "syntax": "$nn,X",
        "description": "X-Indexed Zero Page",
        "documentation": {
          "title": "X-Indexed Zero Page",
          "text": [
            "This form of addressing is used in conjunction with the X index register. The effective address is calculated by adding the second byte to the contents of the index register. Since this is a form of \"Zero Page\" addressing, the content of the second byte references a location in page zero. Additionally, due to the “Zero Page\" addressing nature of this mode, no carry is added to the high order 8 bits of memory and crossing of page boundaries does not occur."
          ]
        }
      },
      "a8,Y": {
        "bytes": "2",
        "syntax": "$nn,Y",
        "description": "Y-Indexed Zero Page",
        "documentation": {
          "title": "Y-Indexed Zero Page",
          "text": [
            "This form of addressing is used in conjunction with the Y index register. The effective address is calculated by adding the second byte to the contents of the index register. Since this is a form of \"Zero Page\" addressing, the content of the second byte references a location in page zero. Additionally, due to the “Zero Page\" addressing nature of this mode, no carry is added to the high order 8 bits of memory and crossing of page boundaries does not occur."
          ]
        }
      },
      "(a8,X)": {
        "bytes": "2",
        "syntax": "($nn,X)",
        "description": "X-Indexed Zero Page Indirect",
        "documentation": {
          "title": "X-Indexed Zero Page Indirect",
          "text": [
            "In indexed indirect addressing, the second byte of the instruction is added to the contents of the X index register, discarding the carry. The result of this addition points to a memory location on page zero whose contents is the low order eight bits of the effective address. The next memory location in page zero contains the high order eight bits of the effective address. Both memory locations specifying the high and low order bytes of the effective address must be in page zero."
          ]
        }
      },
      "(a8),Y": {
        "bytes": "2",
        "syntax": "($nn),Y",
        "description": "Zero Page Indirect Y-Indexed",
        "documentation": {
          "title": "Zero Page Indirect Y-Indexed",
          "text": [
            "In indirect indexed addressing, the second byte of the instruction points to a memory location in page zero. The contents of this memory location is added to the contents of the Y index register, the result being the low order eight bits of the effective address. The carry from this addition is added to the contents of the next page zero memory location, the result being the high order eight bits of the effective address."
          ]
        }
      },
      "a16": {
        "bytes": "3",
        "syntax": "$nnnn",
        "description": "Absolute",
        "documentation": {
          "title": "Absolute",
          "text": [
            "In absolute addressing, the second byte of the instruction specifies the eight low order bits of the effective address while the third byte specifies the eight high order bits. Thus, the absolute addressing mode allows access to the entire 65 K bytes of addressable memory."
          ]
        }
      },
      "a16,X": {
        "bytes": "3",
        "syntax": "$nnnn,X",
        "description": "X-Indexed Absolute",
        "documentation": {
          "title": "X-Indexed Absolute",
          "text": [
            "This form of addressing is used in conjunction with the X index register. The effective address is formed by adding the contents of X to the address contained in the second and third bytes of the instruction. This mode allows the index register to contain the index or count value and the instruction to contain the base address. This type of indexing allows any location referencing and the index to modify multiple fields resulting in reduced coding and execution time."
          ]
        }
      },
      "a16,Y": {
        "bytes": "3",
        "syntax": "$nnnn,Y",
        "description": "Y-Indexed Absolute",
        "documentation": {
          "title": "Y-Indexed Absolute",
          "text": [
            "This form of addressing is used in conjunction with the Y index register. The effective address is formed by adding the contents of Y to the address contained in the second and third bytes of the instruction. This mode allows the index register to contain the index or count value and the instruction to contain the base address. This type of indexing allows any location referencing and the index to modify multiple fields resulting in reduced coding and execution time."
          ]
        }
      },
      "(a16)": {
        "bytes": "3",
        "syntax": "($nnnn)",
        "description": "Absolute Indirect",
        "documentation": {
          "title": "Absolute Indirect",
          "text": [
            "The second byte of the instruction contains the low order eight bits of a memory location. The high order eight bits of that memory location is contained in the third byte of the instruction. The contents of the fully specified memory location is the low order byte of the effective address. The next memory location contains the high order byte of the effective address which is loaded into the sixteen bits of the program counter."
          ]
        }
      },
      "r8": {
        "bytes": "2",
        "syntax": "$nnnn",
        "description": "Relative",
        "documentation": {
          "title": "Relative",
          "text": [
            "Relative addressing is used only with branch instructions and establishes a destination for the conditional branch.",
            "The second byte of-the instruction becomes the operand which is an “Offset\" added to the contents of the lower eight bits of the program counter when the counter is set at the next instruction. The range of the offset is —128 to +127 bytes from the next instruction."
          ]
        }
      },
      "(a8)": {
        "bytes": "2",
        "syntax": "($nn)",
        "description": "Zero Page Indirect",
        "documentation": {
          "title": "Zero Page Indirect",
          "text": [
            "With Zero Page Indirect addressing mode, the second byte of the instruction is a zero page indirect address that points to the low byte of a two byte effective address."
          ]
        }
      },
      "(a16,X)": {
        "bytes": "3",
        "syntax": "($nnnn,X)",
        "description": "Absolute X-Indexed Indirect",
        "documentation": {
          "title": "Absolute X-Indexed Indirect",
          "text": [
            "With the Absolute Indexed Indirect addressing mode, the X Index Register is added to the second and third byes of the instruction to form an address to a pointer. This address mode is only used with the JMP instruction and the program Counter is loaded with the first and second bytes at this pointer."
          ]
        }
      }
    },
    "all_mnemos": {
      "regular": [
        "ADC",
        "AND",
        "ASL",
        "BCC",
        "BCS",
        "BEQ",
        "BIT",
        "BMI",
        "BNE",
        "BPL",
        "BRA",
        "BRK",
        "BVC",
        "BVS",
        "CLC",
        "CLD",
        "CLI",
        "CLV",
        "CMP",
        "CPX",
        "CPY",
        "DEC",
        "DEX",
        "DEY",
        "EOR",
        "INC",
        "INX",
        "INY",
        "JMP",
        "JSR",
        "LDA",
        "LDX",
        "LDY",
        "LSR",
        "NOP",
        "ORA",
        "PHA",
        "PHP",
        "PHX",
        "PHY",
        "PLA",
        "PLP",
        "PLX",
        "PLY",
        "ROL",
        "ROR",
        "RTI",
        "RTS",
        "SBC",
        "SEC",
        "SED",
        "SEI",
        "STA",
        "STX",
        "STY",
        "STZ",
        "TAX",
        "TAY",
        "TRB",
        "TSB",
        "TSX",
        "TXA",
        "TXS",
        "TYA"
      ],
      "illegal": [
        "NOP"
      ],
      "all": [
        "ADC",
        "AND",
        "ASL",
        "BCC",
        "BCS",
        "BEQ",
        "BIT",
        "BMI",
        "BNE",
        "BPL",
        "BRA",
        "BRK",
        "BVC",
        "BVS",
        "CLC",
        "CLD",
        "CLI",
        "CLV",
        "CMP",
        "CPX",
        "CPY",
        "DEC",
        "DEX",
        "DEY",
        "EOR",
        "INC",
        "INX",
        "INY",
        "JMP",
        "JSR",
        "LDA",
        "LDX",
        "LDY",
        "LSR",
        "NOP",
        "ORA",
        "PHA",
        "PHP",
        "PHX",
        "PHY",
        "PLA",
        "PLP",
        "PLX",
        "PLY",
        "ROL",
        "ROR",
        "RTI",
        "RTS",
        "SBC",
        "SEC",
        "SED",
        "SEI",
        "STA",
        "STX",
        "STY",
        "STZ",
        "TAX",
        "TAY",
        "TRB",
        "TSB",
        "TSX",
        "TXA",
        "TXS",
        "TYA"
      ]
    },
    "all_addmodes": {
      "regular": [
        "-",
        "A",
        "#d8",
        "a16",
        "a16,X",
        "a16,Y",
        "(a16)",
        "(a16,X)",
        "a8",
        "a8,X",
        "a8,Y",
        "(a8)",
        "(a8,X)",
        "(a8),Y",
        "r8"
      ],
      "illegal": [
        "-",
        "#d8"
      ],
      "all": [
        "-",
        "A",
        "#d8",
        "a16",
        "a16,X",
        "a16,Y",
        "(a16)",
        "(a16,X)",
        "a8",
        "a8,X",
        "a8,Y",
        "(a8)",
        "(a8,X)",
        "(a8),Y",
        "r8"
      ]
    }
  },
  "r65c02": {
    "info": {
      "manufacturer": "Rockwell",
      "name": "R65C02",
      "year": "1983",
      "id": "r65c02",
      "basedon": "65c02",
      "description": "This is the Rockwell-variant of the WDC 65c02, which adds 32 new bit testing and manipulation opcodes."
    },
    "registers": {
      "registers": [
        "A",
        "X",
        "Y",
        "S",
        "P",
        "PC"
      ],
      "A": {
        "size": "8",
        "description": "Accumulator"
      },
      "X": {
        "size": "8",
        "description": "X Index Register"
      },
      "Y": {
        "size": "8",
        "description": "Y Index Register"
      },
      "S": {
        "size": "8",
        "description": "Stack Pointer"
      },
      "P": {
        "size": "8",
        "description": "Processor Status"
      },
      "PC": {
        "size": "16",
        "description": "Program Counter"
      }
    },
    "vectors": {
      "FFFA": "NMI",
      "FFFC": "RESET",
      "FFFE": "IRQ"
    },
    "flags": {
      "names": "NV-BDIZC",
      "N": "Negative",
      "V": "Overflow",
      "-": "(Expansion)",
      "B": "Break Command",
      "D": "Decimal",
      "I": "Interrupt Disable",
      "Z": "Zero",
      "C": "Carry"
    },
    "opcodes": [
      {
        "illegal": false,
        "mnemo": "BRK",
        "addmode": "-",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TSB",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB0",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHP",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TSB",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR0",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BPL",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TRB",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB1",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLC",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TRB",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR1",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "JSR",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB2",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PLP",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR2",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BMI",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a8,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB3",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SEC",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a16,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR3",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "RTI",
        "addmode": "-",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB4",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHA",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR4",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BVC",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB5",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLI",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PHY",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR5",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "RTS",
        "addmode": "-",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8,X)",
        "cycles": "6+d",
        "mincycles": 6,
        "maxcycles": 7,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STZ",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a8",
        "cycles": "3+d",
        "mincycles": 3,
        "maxcycles": 4,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB6",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PLA",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "#d8",
        "cycles": "2+d",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "(a16)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16",
        "cycles": "4+d",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR6",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BVS",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8),Y",
        "cycles": "5+p+d",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "p",
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8)",
        "cycles": "5+d",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STZ",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a8,X",
        "cycles": "4+d",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB7",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SEI",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16,Y",
        "cycles": "4+p+d",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "p",
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PLY",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "(a16,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16,X",
        "cycles": "4+p+d",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "p",
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR7",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BRA",
        "addmode": "r8",
        "cycles": "3+t+p",
        "mincycles": 3,
        "maxcycles": 5,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB0",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEY",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "#d8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TXA",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS0",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BCC",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8),Y",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a8,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB1",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TYA",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16,Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TXS",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STZ",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STZ",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS1",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB2",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TAY",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TAX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS2",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BCS",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a8,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB3",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLV",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "TSX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BBS3",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB4",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INY",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS4",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BNE",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB5",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLD",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PHX",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS5",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8,X)",
        "cycles": "6+d",
        "mincycles": 6,
        "maxcycles": 7,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a8",
        "cycles": "3+d",
        "mincycles": 3,
        "maxcycles": 4,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB6",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "#d8",
        "cycles": "2+d",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16",
        "cycles": "4+d",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS6",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BEQ",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8),Y",
        "cycles": "5+p+d",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "p",
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8)",
        "cycles": "5+d",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a8,X",
        "cycles": "4+d",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB7",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SED",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16,Y",
        "cycles": "4+p+d",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "p",
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PLX",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16,X",
        "cycles": "4+p+d",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "p",
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS7",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      }
    ],
    "operations": {
      "ADC": {
        "category": "arith",
        "flags": "NV----ZC",
        "description": "A + M + C → A, C",
        "documentation": {
          "title": "Add Memory to Accumulator with Carry",
          "text": [
            "This instruction adds the value of memory and carry from the previous operation to the value of the accumulator and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the carry flag when the sum of a binary add exceeds 255 or when the sum of a decimal add exceeds 99, otherwise carry is reset. The overflow flag is set when the sign or bit 7 is changed due to the result exceeding +127 or -128, otherwise overflow is reset. The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. The zero flag is set if the accumulator result is 0, otherwise the zero flag is reset."
          ]
        }
      },
      "AND": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ∧ M → A",
        "documentation": {
          "title": "\"AND\" Memory with Accumulator",
          "text": [
            "The AND instruction transfer the accumulator and memory to the adder which performs a bit-by-bit AND operation and stores the result back in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "ASL": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C ← /M7...M0/ ← 0",
        "documentation": {
          "title": "Arithmetic Shift Left",
          "text": [
            "The shift left instruction shifts either the accumulator or the address memory location 1 bit to the left, with the bit 0 always being set to 0 and the the input bit 7 being stored in the carry flag. ASL either shifts the accumulator left 1 bit or is a read/modify/write instruction that affects only memory.",
            "The instruction does not affect the overflow bit, sets N equal to the result bit 7 (bit 6 in the input), sets Z flag if the result is equal to 0, otherwise resets Z and stores the input bit 7 in the carry flag."
          ]
        }
      },
      "BCC": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on C = 0",
        "documentation": {
          "title": "Branch on Carry Clear",
          "text": [
            "This instruction tests the state of the carry bit and takes a conditional branch if the carry bit is reset.",
            "It affects no flags or registers other than the program counter and then only if the C flag is not on."
          ]
        }
      },
      "BCS": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on C = 1",
        "documentation": {
          "title": "Branch on Carry Set",
          "text": [
            "This instruction takes the conditional branch if the carry flag is on.",
            "BCS does not affect any of the flags or registers except for the program counter and only then if the carry flag is on."
          ]
        }
      },
      "BEQ": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on Z = 1",
        "documentation": {
          "title": "Branch on Result Zero",
          "text": [
            "This instruction could also be called \"Branch on Equal.\"",
            "It takes a conditional branch whenever the Z flag is on or the previ­ ous result is equal to 0.",
            "BEQ does not affect any of the flags or registers other than the program counter and only then when the Z flag is set."
          ]
        }
      },
      "BIT": {
        "category": "logic",
        "flags": "NV----Z-",
        "description": "A ∧ M, M7 → N, M6 → V",
        "documentation": {
          "title": "Test Bits in Memory with Accumulator",
          "text": [
            "This instruction performs an AND between a memory location and the accumulator but does not store the result of the AND into the accumulator.",
            "The bit instruction affects the N flag with N being set to the value of bit 7 of the memory being tested, the V flag with V being set equal to bit 6 of the memory being tested and Z being set by the result of the AND operation between the accumulator and the memory if the result is Zero, Z is reset otherwise. It does not affect the accumulator."
          ]
        }
      },
      "BMI": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on N = 1",
        "documentation": {
          "title": "Branch on Result Minus",
          "text": [
            "This instruction takes the conditional branch if the N bit is set.",
            "BMI does not affect any of the flags or any other part of the machine other than the program counter and then only if the N bit is on."
          ]
        }
      },
      "BNE": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on Z = 0",
        "documentation": {
          "title": "Branch on Result Not Zero",
          "text": [
            "This instruction could also be called \"Branch on Not Equal.\" It tests the Z flag and takes the conditional branch if the Z flag is not on, indicating that the previous result was not zero.",
            "BNE does not affect any of the flags or registers other than the program counter and only then if the Z flag is reset."
          ]
        }
      },
      "BPL": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on N = 0",
        "documentation": {
          "title": "Branch on Result Plus",
          "text": [
            "This instruction is the complementary branch to branch on result minus. It is a conditional branch which takes the branch when the N bit is reset (0). BPL is used to test if the previous result bit 7 was off (0) and branch on result minus is used to determine if the previous result was minus or bit 7 was on (1).",
            "The instruction affects no flags or other registers other than the P counter and only affects the P counter when the N bit is reset."
          ]
        }
      },
      "BRK": {
        "category": "ctrl",
        "flags": "-----1--",
        "description": "PC + 2↓, [FFFE] → PCL, [FFFF] → PCH",
        "documentation": {
          "title": "Break Command",
          "text": [
            "The break command causes the microprocessor to go through an inter­ rupt sequence under program control. This means that the program counter of the second byte after the BRK. is automatically stored on the stack along with the processor status at the beginning of the break instruction. The microprocessor then transfers control to the interrupt vector.",
            "Other than changing the program counter, the break instruction changes no values in either the registers or the flags."
          ]
        }
      },
      "BVC": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on V = 0",
        "documentation": {
          "title": "Branch on Overflow Clear",
          "text": [
            "This instruction tests the status of the V flag and takes the conditional branch if the flag is not set.",
            "BVC does not affect any of the flags and registers other than the program counter and only when the overflow flag is reset."
          ]
        }
      },
      "BVS": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on V = 1",
        "documentation": {
          "title": "Branch on Overflow Set",
          "text": [
            "This instruction tests the V flag and takes the conditional branch if V is on.",
            "BVS does not affect any flags or registers other than the program, counter and only when the overflow flag is set."
          ]
        }
      },
      "CLC": {
        "category": "flags",
        "flags": "-------0",
        "description": "0 → C",
        "documentation": {
          "title": "Clear Carry Flag",
          "text": [
            "This instruction initializes the carry flag to a 0. This op­ eration should normally precede an ADC loop. It is also useful when used with a R0L instruction to clear a bit in memory.",
            "This instruction affects no registers in the microprocessor and no flags other than the carry flag which is reset."
          ]
        }
      },
      "CLD": {
        "category": "flags",
        "flags": "----0---",
        "description": "0 → D",
        "documentation": {
          "title": "Clear Decimal Mode",
          "text": [
            "This instruction sets the decimal mode flag to a 0. This all subsequent ADC and SBC instructions to operate as simple operations.",
            "CLD affects no registers in the microprocessor and no flags other than the decimal mode flag which is set to a 0."
          ]
        }
      },
      "CLI": {
        "category": "flags",
        "flags": "-----0--",
        "description": "0 → I",
        "documentation": {
          "title": "Clear Interrupt Disable",
          "text": [
            "This instruction initializes the interrupt disable to a 0. This allows the microprocessor to receive interrupts.",
            "It affects no registers in the microprocessor and no flags other than the interrupt disable which is cleared."
          ]
        }
      },
      "CLV": {
        "category": "flags",
        "flags": "-0------",
        "description": "0 → V",
        "documentation": {
          "title": "Clear Overflow Flag",
          "text": [
            "This instruction clears the overflow flag to a 0. This com­ mand is used in conjunction with the set overflow pin which can change the state of the overflow flag with an external signal.",
            "CLV affects no registers in the microprocessor and no flags other than the overflow flag which is set to a 0."
          ]
        }
      },
      "CMP": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "A - M",
        "documentation": {
          "title": "Compare Memory and Accumulator",
          "text": [
            "This instruction subtracts the contents of memory from the contents of the accumulator.",
            "The use of the CMP affects the following flags: Z flag is set on an equal comparison, reset otherwise; the N flag is set or reset by the result bit 7, the carry flag is set when the value in memory is less than or equal to the accumulator, reset when it is greater than the accumulator. The accumulator is not affected."
          ]
        }
      },
      "CPX": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "X - M",
        "documentation": {
          "title": "Compare Index Register X To Memory",
          "text": [
            "This instruction subtracts the value of the addressed memory location from the content of index register X using the adder but does not store the result; therefore, its only use is to set the N, Z and C flags to allow for comparison between the index register X and the value in memory.",
            "The CPX instruction does not affect any register in the machine; it also does not affect the overflow flag. It causes the carry to be set on if the absolute value of the index register X is equal to or greater than the data from memory. If the value of the memory is greater than the content of the index register X, carry is reset. If the results of the subtraction contain a bit 7, then the N flag is set, if not, it is reset. If the value in memory is equal to the value in index register X, the Z flag is set, otherwise it is reset."
          ]
        }
      },
      "CPY": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "Y - M",
        "documentation": {
          "title": "Compare Index Register Y To Memory",
          "text": [
            "This instruction performs a two's complement subtraction between the index register Y and the specified memory location. The results of the subtraction are not stored anywhere. The instruction is strict­ly used to set the flags.",
            "CPY affects no registers in the microprocessor and also does not affect the overflow flag. If the value in the index register Y is equal to or greater than the value in the memory, the carry flag will be set, otherwise it will be cleared. If the results of the subtract- tion contain bit 7 on the N bit will be set, otherwise it will be cleared. If the value in the index register Y and the value in the memory are equal, the zero flag will be set, otherwise it will be cleared."
          ]
        }
      },
      "DEC": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "M - 1 → M",
        "documentation": {
          "title": "Decrement Memory By One",
          "text": [
            "This instruction subtracts 1, in two's complement, from the contents of the addressed memory location.",
            "The decrement instruction does not affect any internal register in the microprocessor. It does not affect the carry or overflow flags. If bit 7 is on as a result of the decrement, then the N flag is set, otherwise it is reset. If the result of the decrement is 0, the Z flag is set, other­wise it is reset."
          ]
        }
      },
      "DEX": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "X - 1 → X",
        "documentation": {
          "title": "Decrement Index Register X By One",
          "text": [
            "This instruction subtracts one from the current value of the index register X and stores the result in the index register X.",
            "DEX does not affect the carry or overflow flag, it sets the N flag if it has bit 7 on as a result of the decrement, otherwise it resets the N flag; sets the Z flag if X is a 0 as a result of the decrement, otherwise it resets the Z flag."
          ]
        }
      },
      "DEY": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "Y - 1 → Y",
        "documentation": {
          "title": "Decrement Index Register Y By One",
          "text": [
            "This instruction subtracts one from the current value in the in­ dex register Y and stores the result into the index register Y. The result does not affect or consider carry so that the value in the index register Y is decremented to 0 and then through 0 to FF.",
            "Decrement Y does not affect the carry or overflow flags; if the Y register contains bit 7 on as a result of the decrement the N flag is set, otherwise the N flag is reset. If the Y register is 0 as a result of the decrement, the Z flag is set otherwise the Z flag is reset. This instruction only affects the index register Y."
          ]
        }
      },
      "EOR": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ⊻ M → A",
        "documentation": {
          "title": "\"Exclusive OR\" Memory with Accumulator",
          "text": [
            "The EOR instruction transfers the memory and the accumulator to the adder which performs a binary \"EXCLUSIVE OR\" on a bit-by-bit basis and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "INC": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "M + 1 → M",
        "documentation": {
          "title": "Increment Memory By One",
          "text": [
            "This instruction adds 1 to the contents of the addressed memory loca­tion.",
            "The increment memory instruction does not affect any internal registers and does not affect the carry or overflow flags. If bit 7 is on as the result of the increment,N is set, otherwise it is reset; if the increment causes the result to become 0, the Z flag is set on, otherwise it is reset."
          ]
        }
      },
      "INX": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "X + 1 → X",
        "documentation": {
          "title": "Increment Index Register X By One",
          "text": [
            "Increment X adds 1 to the current value of the X register. This is an 8-bit increment which does not affect the carry operation, therefore, if the value of X before the increment was FF, the resulting value is 00.",
            "INX does not affect the carry or overflow flags; it sets the N flag if the result of the increment has a one in bit 7, otherwise resets N; sets the Z flag if the result of the increment is 0, otherwise it resets the Z flag.",
            "INX does not affect any other register other than the X register."
          ]
        }
      },
      "INY": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "Y + 1 → Y",
        "documentation": {
          "title": "Increment Index Register Y By One",
          "text": [
            "Increment Y increments or adds one to the current value in the Y register, storing the result in the Y register. As in the case of INX the primary application is to step thru a set of values using the Y register.",
            "The INY does not affect the carry or overflow flags, sets the N flag if the result of the increment has a one in bit 7, otherwise resets N, sets Z if as a result of the increment the Y register is zero otherwise resets the Z flag."
          ]
        }
      },
      "JMP": {
        "category": "ctrl",
        "flags": "--------",
        "description": "[PC + 1] → PCL, [PC + 2] → PCH",
        "documentation": {
          "title": "JMP Indirect",
          "text": [
            "This instruction establishes a new valne for the program counter.",
            "It affects only the program counter in the microprocessor and affects no flags in the status register."
          ]
        }
      },
      "JSR": {
        "category": "ctrl",
        "flags": "--------",
        "description": "PC + 2↓, [PC + 1] → PCL, [PC + 2] → PCH",
        "documentation": {
          "title": "Jump To Subroutine",
          "text": [
            "This instruction transfers control of the program counter to a subroutine location but leaves a return pointer on the stack to allow the user to return to perform the next instruction in the main program after the subroutine is complete. To accomplish this, JSR instruction stores the program counter address which points to the last byte of the jump instruc­ tion onto the stack using the stack pointer. The stack byte contains the program count high first, followed by program count low. The JSR then transfers the addresses following the jump instruction to the program counter low and the program counter high, thereby directing the program to begin at that new address.",
            "The JSR instruction affects no flags, causes the stack pointer to be decremented by 2 and substitutes new values into the program counter low and the program counter high."
          ]
        }
      },
      "LDA": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → A",
        "documentation": {
          "title": "Load Accumulator with Memory",
          "text": [
            "When instruction LDA is executed by the microprocessor, data is transferred from memory to the accumulator and stored in the accumulator.",
            "LDA affects the contents of the accumulator, does not affect the carry or overflow flags; sets the zero flag if the accumulator is zero as a result of the LDA, otherwise resets the zero flag; sets the negative flag if bit 7 of the accumulator is a 1, other­ wise resets the negative flag."
          ]
        }
      },
      "LDX": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → X",
        "documentation": {
          "title": "Load Index Register X From Memory",
          "text": [
            "Load the index register X from memory.",
            "LDX does not affect the C or V flags; sets Z if the value loaded was zero, otherwise resets it; sets N if the value loaded in bit 7 is a 1; otherwise N is reset, and affects only the X register."
          ]
        }
      },
      "LDY": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → Y",
        "documentation": {
          "title": "Load Index Register Y From Memory",
          "text": [
            "Load the index register Y from memory.",
            "LDY does not affect the C or V flags, sets the N flag if the value loaded in bit 7 is a 1, otherwise resets N, sets Z flag if the loaded value is zero otherwise resets Z and only affects the Y register."
          ]
        }
      },
      "LSR": {
        "category": "shift",
        "flags": "0-----ZC",
        "description": "0 → /M7...M0/ → C",
        "documentation": {
          "title": "Logical Shift Right",
          "text": [
            "This instruction shifts either the accumulator or a specified memory location 1 bit to the right, with the higher bit of the result always being set to 0, and the low bit which is shifted out of the field being stored in the carry flag.",
            "The shift right instruction either affects the accumulator by shift­ing it right 1 or is a read/modify/write instruction which changes a speci­fied memory location but does not affect any internal registers. The shift right does not affect the overflow flag. The N flag is always reset. The Z flag is set if the result of the shift is 0 and reset otherwise. The carry is set equal to bit 0 of the input."
          ]
        }
      },
      "NOP": {
        "category": "nop",
        "flags": "--------",
        "description": "No operation"
      },
      "ORA": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ∨ M → A",
        "documentation": {
          "title": "\"OR\" Memory with Accumulator",
          "text": [
            "The ORA instruction transfers the memory and the accumulator to the adder which performs a binary \"OR\" on a bit-by-bit basis and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "PHA": {
        "category": "stack",
        "flags": "--------",
        "description": "A↓",
        "documentation": {
          "title": "Push Accumulator On Stack",
          "text": [
            "This instruction transfers the current value of the accumulator to the next location on the stack, automatically decrementing the stack to point to the next empty location.",
            "The Push A instruction only affects the stack pointer register which is decremented by 1 as a result of the operation. It affects no flags."
          ]
        }
      },
      "PHP": {
        "category": "stack",
        "flags": "--------",
        "description": "P↓",
        "documentation": {
          "title": "Push Processor Status On Stack",
          "text": [
            "This instruction transfers the contents of the processor status reg­ ister unchanged to the stack, as governed by the stack pointer.",
            "The PHP instruction affects no registers or flags in the micropro­cessor."
          ]
        }
      },
      "PLA": {
        "category": "stack",
        "flags": "N-----Z-",
        "description": "A↑",
        "documentation": {
          "title": "Pull Accumulator From Stack",
          "text": [
            "This instruction adds 1 to the current value of the stack pointer and uses it to address the stack and loads the contents of the stack into the A register.",
            "The PLA instruction does not affect the carry or overflow flags. It sets N if the bit 7 is on in accumulator A as a result of instructions, otherwise it is reset. If accumulator A is zero as a result of the PLA, then the Z flag is set, otherwise it is reset. The PLA instruction changes content of the accumulator A to the contents of the memory location at stack register plus 1 and also increments the stack register."
          ]
        }
      },
      "PLP": {
        "category": "stack",
        "flags": "NV--DIZC",
        "description": "P↑",
        "documentation": {
          "title": "Pull Processor Status From Stack",
          "text": [
            "This instruction transfers the next value on the stack to the Proces­ sor Status register, thereby changing all of the flags and setting the mode switches to the values from the stack.",
            "The PLP instruction affects no registers in the processor other than the status register. This instruction could affect all flags in the status register."
          ]
        }
      },
      "ROL": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C ← /M7...M0/ ← C",
        "documentation": {
          "title": "Rotate Left",
          "text": [
            "The rotate left instruction shifts either the accumulator or addressed memory left 1 bit, with the input carry being stored in bit 0 and with the input bit 7 being stored in the carry flags.",
            "The ROL instruction either shifts the accumulator left 1 bit and stores the carry in accumulator bit 0 or does not affect the internal reg­isters at all. The ROL instruction sets carry equal to the input bit 7, sets N equal to the input bit 6 , sets the Z flag if the result of the ro­ tate is 0, otherwise it resets Z and does not affect the overflow flag at all."
          ]
        }
      },
      "ROR": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C → /M7...M0/ → C",
        "documentation": {
          "title": "Rotate Right",
          "text": [
            "The rotate right instruction shifts either the accumulator or addressed memory right 1 bit with bit 0 shifted into the carry and carry shifted into bit 7.",
            "The ROR instruction either shifts the accumulator right 1 bit and stores the carry in accumulator bit 7 or does not affect the internal regis­ ters at all. The ROR instruction sets carry equal to input bit 0, sets N equal to the input carry and sets the Z flag if the result of the rotate is 0; otherwise it resets Z and does not affect the overflow flag at all.",
            "(Available on Microprocessors after June, 1976)"
          ]
        }
      },
      "RTI": {
        "category": "ctrl",
        "flags": "NV--DIZC",
        "description": "P↑ PC↑",
        "documentation": {
          "title": "Return From Interrupt",
          "text": [
            "This instruction transfers from the stack into the microprocessor the processor status and the program counter location for the instruction which was interrupted. By virtue of the interrupt having stored this data before executing the instruction and thei fact that the RTI reinitializes the microprocessor to the same state as when it was interrupted, the combination of interrupt plus RTI allows truly reentrant coding.",
            "The RTI instruction reinitializes all flags to the position to the point they were at the time the interrupt was taken and sets the program counter back to its pre-interrupt state. It affects no other registers in the microprocessor."
          ]
        }
      },
      "RTS": {
        "category": "ctrl",
        "flags": "--------",
        "description": "PC↑, PC + 1 → PC",
        "documentation": {
          "title": "Return From Subroutme",
          "text": [
            "This instruction loads the program count low and program count high from the stack into the program counter and increments the program counter so that it points to the instruction following the JSR. The stack pointer is adjusted by incrementing it twice.",
            "The RTS instruction does not affect any flags and affects only PCL and PCH."
          ]
        }
      },
      "SBC": {
        "category": "arith",
        "flags": "NV----ZC",
        "description": "A - M - ~C → A",
        "documentation": {
          "title": "Subtract Memory from Accumulator with Borrow",
          "text": [
            "This instruction subtracts the value of memory and borrow from the value of the accumulator, using two's complement arithmetic, and stores the result in the accumulator. Borrow is defined as the carry flag complemented; therefore, a resultant carry flag indicates that a borrow has not occurred.",
            "This instruction affects the accumulator. The carry flag is set if the result is greater than or equal to 0. The carry flag is reset when the result is less than 0, indicating a borrow. The over­flow flag is set when the result exceeds +127 or -127, otherwise it is reset. The negative flag is set if the result in the accumulator has bit 7 on, otherwise it is reset. The Z flag is set if the result in the accumulator is 0, otherwise it is reset."
          ]
        }
      },
      "SEC": {
        "category": "flags",
        "flags": "-------1",
        "description": "1 → C",
        "documentation": {
          "title": "Set Carry Flag",
          "text": [
            "This instruction initializes the carry flag to a 1. This op eration should normally precede a SBC loop. It is also useful when used with a ROL instruction to initialize a bit in memory to a 1.",
            "This instruction affects no registers in the microprocessor and no flags other than the carry flag which is set."
          ]
        }
      },
      "SED": {
        "category": "flags",
        "flags": "----1---",
        "description": "1 → D",
        "documentation": {
          "title": "Set Decimal Mode",
          "text": [
            "This instruction sets the decimal mode flag D to a 1. This makes all subsequent ADC and SBC instructions operate as a decimal arithmetic operation.",
            "SED affects no registers in the microprocessor and no flags other than the decimal mode which is set to a 1."
          ]
        }
      },
      "SEI": {
        "category": "flags",
        "flags": "-----1--",
        "description": "1 → I",
        "documentation": {
          "title": "Set Interrupt Disable",
          "text": [
            "This instruction initializes the interrupt disable to a 1. It is used to mask interrupt requests during system reset operations and during interrupt commands.",
            "It affects no registers in the microprocessor and no flags other than the interrupt disable which is set."
          ]
        }
      },
      "STA": {
        "category": "load",
        "flags": "--------",
        "description": "A → M",
        "documentation": {
          "title": "Store Accumulator in Memory",
          "text": [
            "This instruction transfers the contents of the accumulator to memory.",
            "This instruction affects none of the flags in the processor status register and does not affect the accumulator."
          ]
        }
      },
      "STX": {
        "category": "load",
        "flags": "--------",
        "description": "X → M",
        "documentation": {
          "title": "Store Index Register X In Memory",
          "text": [
            "Transfers value of X register to addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "STY": {
        "category": "load",
        "flags": "--------",
        "description": "Y → M",
        "documentation": {
          "title": "Store Index Register Y In Memory",
          "text": [
            "Transfer the value of the Y register to the addressed memory location.",
            "STY does not affect any flags or registers in the microprocessor."
          ]
        }
      },
      "TAX": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "A → X",
        "documentation": {
          "title": "Transfer Accumulator To Index X",
          "text": [
            "This instruction takes the value from accumulator A and trans­ fers or loads it into the index register X without disturbing the content of the accumulator A.",
            "TAX only affects the index register X, does not affect the carry or overflow flags. The N flag is set if the resultant value in the index register X has bit 7 on, otherwise N is reset. The Z bit is set if the content of the register X is 0 as aresult of theopera­ tion, otherwise it is reset."
          ]
        }
      },
      "TAY": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "A → Y",
        "documentation": {
          "title": "Transfer Accumula Tor To Index Y",
          "text": [
            "This instruction moves the value of the accumulator into index register Y without affecting the accumulator.",
            "TAY instruction only affects the Y register and does not affect either the carry or overflow flags. If the index register Y has bit 7 on, then N is set, otherwise it is reset. If the content of the index register Y equals 0 as a result of the operation, Z is set on, otherwise it is reset."
          ]
        }
      },
      "TSX": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "S → X",
        "documentation": {
          "title": "Transfer Stack Pointer To Index X",
          "text": [
            "This instruction transfers the value in the stack pointer to the index register X.",
            "TSX does not affect the carry or overflow flags. It sets N if bit 7 is on in index X as a result of the instruction, otherwise it is reset. If index X is zero as a result of the TSX, the Z flag is set, other­ wise it is reset. TSX changes the value of index X, making it equal to the content of the stack pointer."
          ]
        }
      },
      "TXA": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "X → A",
        "documentation": {
          "title": "Transfer Index X To Accumulator",
          "text": [
            "This instruction moves the value that is in the index register X to the accumulator A without disturbing the content of the index register X.",
            "TXA does not affect any register other than the accumula­tor and does not affect the carry or overflow flag. If the result in A has bit 7 on, then the N flag is set, otherwise it is reset. If the resultant value in the accumulator is 0, then the Z flag is set, other­ wise it is reset."
          ]
        }
      },
      "TXS": {
        "category": "trans",
        "flags": "--------",
        "description": "X → S",
        "documentation": {
          "title": "Transfer Index X To Stack Pointer",
          "text": [
            "This instruction transfers the value in the index register X to the stack pointer.",
            "TXS changes only the stack pointer, making it equal to the content of the index register X. It does not affect any of the flags."
          ]
        }
      },
      "TYA": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "Y → A",
        "documentation": {
          "title": "Transfer Index Y To Accumulator",
          "text": [
            "This instruction moves the value that is in the index register Y to accumulator A without disturbing the content of the register Y.",
            "TYA does not affect any other register other than the accumula­ tor and does not affect the carry or overflow flag. If the result in the accumulator A has bit 7 on, the N flag is set, otherwise it is reset. If the resultant value in the accumulator A is 0, then the Z flag is set, otherwise it is reset."
          ]
        }
      },
      "#": {
        "category": "mnemos",
        "flags": "are",
        "description": "based on VICE"
      },
      "ANC": {
        "category": "arith",
        "flags": "*-----**",
        "description": "A ∧ M → A, N → C",
        "documentation": {
          "title": "\"AND\" Memory with Accumulator then Move Negative Flag to Carry Flag",
          "text": [
            "The undocumented ANC instruction performs a bit-by-bit AND operation of the accumulator and memory and stores the result back in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag and the carry flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag and the carry flag."
          ]
        }
      },
      "ARR": {
        "category": "arith",
        "flags": "**----**",
        "description": "(A ∧ M) / 2 → A",
        "documentation": {
          "title": "\"AND\" Accumulator then Rotate Right",
          "text": [
            "The undocumented ARR instruction performs a bit-by-bit \"AND\" operation of the accumulator and memory, then shifts the result right 1 bit with bit 0 shifted into the carry and carry shifted into bit 7. It then stores the result back in the accumulator.",
            "If bit 7 of the result is on, then the N flag is set, otherwise it is reset. The instruction sets the Z flag if the result is 0; otherwise it resets Z.",
            "The V and C flags depends on the Decimal Mode Flag:",
            "In decimal mode, the V flag is set if bit 6 is different than the original data's bit 6, otherwise the V flag is reset. The C flag is set if (operand & 0xF0) + (operand & 0x10) is greater than 0x50, otherwise the C flag is reset.",
            "In binary mode, the V flag is set if bit 6 of the result is different than bit 5 of the result, otherwise the V flag is reset. The C flag is set if the result in the accumulator has bit 6 on, otherwise it is reset."
          ]
        }
      },
      "ASR": {
        "category": "arith",
        "flags": "0-----**",
        "description": "(A ∧ M) / 2 → A",
        "documentation": {
          "title": "\"AND\" then Logical Shift Right",
          "text": [
            "The undocumented ASR instruction performs a bit-by-bit AND operation of the accumulator and memory, then shifts the accumulator 1 bit to the right, with the higher bit of the result always being set to 0, and the low bit which is shifted out of the field being stored in the carry flag.",
            "This instruction affects the accumulator. It does not affect the overflow flag. The N flag is always reset. The Z flag is set if the result of the shift is 0 and reset otherwise. The carry is set equal to bit 0 of the result of the \"AND\" operation."
          ]
        }
      },
      "DCP": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M - 1 → M, A - M",
        "documentation": {
          "title": "Decrement Memory By One then Compare with Accumulator",
          "text": [
            "This undocumented instruction subtracts 1, in two's complement, from the contents of the addressed memory location. It then subtracts the contents of memory from the contents of the accumulator.",
            "The DCP instruction does not affect any internal register in the microprocessor. It does not affect the overflow flag. Z flag is set on an equal comparison, reset otherwise; the N flag is set or reset by the result bit 7, the carry flag is set when the result in memory is less than or equal to the accumulator, reset when it is greater than the accumulator."
          ]
        }
      },
      "ISC": {
        "category": "arith",
        "flags": "**----**",
        "description": "M + 1 → M, A - M → A",
        "documentation": {
          "title": "Increment Memory By One then SBC then Subtract Memory from Accumulator with Borrow",
          "text": [
            "This undocumented instruction adds 1 to the contents of the addressed memory loca­tion. It then subtracts the value of the result in memory and borrow from the value of the accumulator, using two's complement arithmetic, and stores the result in the accumulator.",
            "This instruction affects the accumulator. The carry flag is set if the result is greater than or equal to 0. The carry flag is reset when the result is less than 0, indicating a borrow. The over­flow flag is set when the result exceeds +127 or -127, otherwise it is reset. The negative flag is set if the result in the accumulator has bit 7 on, otherwise it is reset. The Z flag is set if the result in the accumulator is 0, otherwise it is reset."
          ]
        }
      },
      "JAM": {
        "category": "kil",
        "flags": "--------",
        "description": "Stop execution",
        "documentation": {
          "title": "Halt the CPU",
          "text": [
            "This undocumented instruction stops execution. The microprocessor will not fetch further instructions, and will neither handle IRQs nor NMIs. It will handle a RESET though."
          ]
        }
      },
      "LAS": {
        "category": "load",
        "flags": "*-----*-",
        "description": "M ∧ S → A, X, S",
        "documentation": {
          "title": "\"AND\" Memory with Stack Pointer",
          "text": [
            "This undocumented instruction performs a bit-by-bit \"AND\" operation of the stack pointer and memory and stores the result back in the accumulator, the index register X and the stack pointer.",
            "The LAS instruction does not affect the carry or overflow flags. It sets N if the bit 7 of the result is on, otherwise it is reset. If the result is zero, then the Z flag is set, otherwise it is reset."
          ]
        }
      },
      "LAX": {
        "category": "load",
        "flags": "*-----*-",
        "description": "M → A, X",
        "documentation": {
          "title": "Load Accumulator and Index Register X From Memory",
          "text": [
            "The undocumented LAX instruction loads the accumulator and the index register X from memory.",
            "LAX does not affect the C or V flags; sets Z if the value loaded was zero, otherwise resets it; sets N if the value loaded in bit 7 is a 1; otherwise N is reset, and affects only the X register."
          ]
        }
      },
      "RLA": {
        "category": "arith",
        "flags": "*-----**",
        "description": "C ← /M7...M0/ ← C, A ∧ M → A",
        "documentation": {
          "title": "Rotate Left then \"AND\" with Accumulator",
          "text": [
            "The undocumented RLA instruction shifts the addressed memory left 1 bit, with the input carry being stored in bit 0 and with the input bit 7 being stored in the carry flags. It then performs a bit-by-bit AND operation of the result and the value of the accumulator and stores the result back in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "RRA": {
        "category": "arith",
        "flags": "**----**",
        "description": "C → /M7...M0/ → C, A + M + C → A",
        "documentation": {
          "title": "Rotate Right and Add Memory to Accumulator",
          "text": [
            "The undocumented RRA instruction shifts the addressed memory right 1 bit with bit 0 shifted into the carry and carry shifted into bit 7. It then adds the result and generated carry to the value of the accumulator and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the carry flag when the sum of a binary add exceeds 255 or when the sum of a decimal add exceeds 99, otherwise carry is reset. The overflow flag is set when the sign or bit 7 is changed due to the result exceeding +127 or -128, otherwise overflow is reset. The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. The zero flag is set if the accumulator result is 0, otherwise the zero flag is reset."
          ]
        }
      },
      "SAX": {
        "category": "load",
        "flags": "--------",
        "description": "A ∧ X → M",
        "documentation": {
          "title": "Store Accumulator \"AND\" Index Register X in Memory",
          "text": [
            "The undocumented SAX instruction performs a bit-by-bit AND operation of the value of the accumulator and the value of the index register X and stores the result in memory.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SBX": {
        "category": "arith",
        "flags": "*-----**",
        "description": "(A ∧ X) - M → X",
        "documentation": {
          "title": "Subtract Memory from Accumulator \"AND\" Index Register X",
          "text": [
            "This undocumented instruction performs a bit-by-bit \"AND\" of the value of the accumulator and the index register X and subtracts the value of memory from this result, using two's complement arithmetic, and stores the result in the index register X.",
            "This instruction affects the index register X. The carry flag is set if the result is greater than or equal to 0. The carry flag is reset when the result is less than 0, indicating a borrow. The negative flag is set if the result in index register X has bit 7 on, otherwise it is reset. The Z flag is set if the result in index register X is 0, otherwise it is reset. The over­flow flag not affected at all."
          ]
        }
      },
      "SHA": {
        "category": "load",
        "flags": "--------",
        "description": "A ∧ X ∧ V → M",
        "documentation": {
          "title": "Store Accumulator \"AND\" Index Register X \"AND\" Value",
          "text": [
            "The undocumented SHA instruction performs a bit-by-bit AND operation of the following three operands: The first two are the accumulator and the index register X.",
            "The third operand depends on the addressing mode. In the zero page indirect Y-indexed case, the third operand is the data in memory at the given zero page address (ignoring the the addressing mode's Y offset) plus 1. In the Y-indexed absolute case, it is the upper 8 bits of the given address (ignoring the the addressing mode's Y offset), plus 1.",
            "It then transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SHS": {
        "category": "trans",
        "flags": "--------",
        "description": "A ∧ X → S, S ∧ (H + 1) → M",
        "documentation": {
          "title": "Transfer Accumulator \"AND\" Index Register X to Stack Pointer then Store Stack Pointer \"AND\" Hi-Byte In Memory",
          "text": [
            "The undocumented SHS instruction performs a bit-by-bit AND operation of the value of the accumulator and the value of the index register X and stores the result in the stack pointer. It then performs a bit-by-bit AND operation of the resulting stack pointer and the upper 8 bits of the given address (ignoring the addressing mode's Y offset), plus 1, and transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SHX": {
        "category": "load",
        "flags": "--------",
        "description": "X ∧ (H + 1) → M",
        "documentation": {
          "title": "Store Index Register X \"AND\" Value",
          "text": [
            "The undocumented SHX instruction performs a bit-by-bit AND operation of the index register X and the upper 8 bits of the given address (ignoring the the addressing mode's Y offset), plus 1. It then transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SHY": {
        "category": "load",
        "flags": "--------",
        "description": "Y ∧ (H + 1) → M",
        "documentation": {
          "title": "Store Index Register Y \"AND\" Value",
          "text": [
            "The undocumented SHY instruction performs a bit-by-bit AND operation of the index register Y and the upper 8 bits of the given address (ignoring the the addressing mode's X offset), plus 1. It then transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SLO": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M * 2 → M, A ∨ M → A",
        "documentation": {
          "title": "Arithmetic Shift Left then \"OR\" Memory with Accumulator",
          "text": [
            "The undocumented SLO instruction shifts the address memory location 1 bit to the left, with the bit 0 always being set to 0 and the bit 7 output always being contained in the carry flag. It then performs a bit-by-bit \"OR\" operation on the result and the accumulator and stores the result in the accumulator.",
            "The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. It sets Z flag if the result is equal to 0, otherwise resets Z and stores the input bit 7 in the carry flag."
          ]
        }
      },
      "SRE": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M / 2 → M, A ⊻ M → A",
        "documentation": {
          "title": "Logical Shift Right then \"Exclusive OR\" Memory with Accumulator",
          "text": [
            "The undocumented SRE instruction shifts the specified memory location 1 bit to the right, with the higher bit of the result always being set to 0, and the low bit which is shifted out of the field being stored in the carry flag. It then performs a bit-by-bit \"EXCLUSIVE OR\" of the result and the value of the accumulator and stores the result in the accumulator.",
            "This instruction affects the accumulator. It does not affect the overflow flag. The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. The Z flag is set if the result is 0 and reset otherwise. The carry is set equal to input bit 0."
          ]
        }
      },
      "XAA": {
        "category": "arith",
        "flags": "*-----*-",
        "description": "(A ∨ V) ∧ X ∧ M → A",
        "documentation": {
          "title": "Non-deterministic Operation of Accumulator, Index Register X, Memory and Bus Contents",
          "text": [
            "The operation of the undocumented XAA instruction depends on the individual microprocessor. On most machines, it performs a bit-by-bit AND operation of the following three operands: The first two are the index register X and memory.",
            "The third operand is the result of a bit-by-bit AND operation of the accumulator and a magic component. This magic component depends on the individual microprocessor and is usually one of $00, $EE, $EF, $FE and $FF, and may be influenced by the RDY pin, leftover contents of the data bus, the temperature of the microprocessor, the supplied voltage, and other factors.",
            "On some machines, additional bits of the result may be set or reset depending on non-deterministic factors.",
            "It then transfers the result to the accumulator.",
            "XAA does not affect the C or V flags; sets Z if the value loaded was zero, otherwise resets it; sets N if the result in bit 7 is a 1; otherwise N is reset."
          ]
        }
      },
      "BRA": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch Always",
        "documentation": {
          "title": "Branch Always",
          "text": [
            "This instruction takes an unconditional branch.",
            "BRA does not affect any of the flags or any other part of the machine other than the program counter."
          ]
        }
      },
      "PHX": {
        "category": "stack",
        "flags": "--------",
        "description": "X↓",
        "documentation": {
          "title": "Push Index Register X On Stack",
          "text": [
            "This instruction transfers the current value of the index register X to the next location on the stack, automatically decrementing the stack to point to the next empty location.",
            "The Push X instruction only affects the stack pointer register which is decremented by 1 as a result of the operation. It affects no flags."
          ]
        }
      },
      "PHY": {
        "category": "stack",
        "flags": "--------",
        "description": "Y↑",
        "documentation": {
          "title": "Push Index Register Y On Stack",
          "text": [
            "This instruction transfers the current value of the index register Y to the next location on the stack, automatically decrementing the stack to point to the next empty location.",
            "The Push Y instruction only affects the stack pointer register which is decremented by 1 as a result of the operation. It affects no flags."
          ]
        }
      },
      "PLX": {
        "category": "stack",
        "flags": "N-----Z-",
        "description": "X↑",
        "documentation": {
          "title": "Pull Index Register X From Stack",
          "text": [
            "This instruction adds 1 to the current value of the stack pointer and uses it to address the stack and loads the contents of the stack into the X register.",
            "The PLX instruction does not affect the carry or overflow flags. It sets N if the bit 7 is on in index register X as a result of instructions, otherwise it is reset. If index register X is zero as a result of the PLA, then the Z flag is set, otherwise it is reset. The PLX instruction changes content of the index register X to the contents of the memory location at stack register plus 1 and also increments the stack register."
          ]
        }
      },
      "PLY": {
        "category": "stack",
        "flags": "N-----Z-",
        "description": "Y↑",
        "documentation": {
          "title": "Pull Index Register Y From Stack",
          "text": [
            "This instruction adds 1 to the current value of the stack pointer and uses it to address the stack and loads the contents of the stack into the Y register.",
            "The PLY instruction does not affect the carry or overflow flags. It sets N if the bit 7 is on in index register Y as a result of instructions, otherwise it is reset. If index register Y is zero as a result of the PLA, then the Z flag is set, otherwise it is reset. The PLY instruction changes content of the index register Y to the contents of the memory location at stack register plus 1 and also increments the stack register."
          ]
        }
      },
      "STZ": {
        "category": "load",
        "flags": "--------",
        "description": "0 → M",
        "documentation": {
          "title": "Store Zero In Memory",
          "text": [
            "Transfers the value 0 to addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "TRB": {
        "category": "logic",
        "flags": "------Z-",
        "description": "~A ∧ M → M",
        "documentation": {
          "title": "Test And Reset Memory Bits With Accumulator",
          "text": [
            "This instruction tests and resets bits in memory, using the accumulator for both a test mask, and a reset mask. It performs a logical AND between the inverted bits of the accumulator and the bits in memory, storing the result back into memory.",
            "The zero flag is set if all bits of the result of the AND are zero, otherwise it is reset."
          ]
        }
      },
      "TSB": {
        "category": "logic",
        "flags": "------Z-",
        "description": "A ∨ M → M",
        "documentation": {
          "title": "Test And Set Memory Bits With Accumulator",
          "text": [
            "This instruction tests and sets bits in memory, using the accumulator for both a test mask, and a set mask. It performs a logical OR between the bits of the accumulator and the bits in memory, storing the result back into memory.",
            "The zero flag is set if all bits of the result of the OR are zero, otherwise it is reset."
          ]
        }
      },
      "BBR0": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M0 = 0",
        "documentation": {
          "title": "Branch on Bit 0 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 0 is clear."
          ]
        }
      },
      "BBR1": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M1 = 0",
        "documentation": {
          "title": "Branch on Bit 1 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 1 is clear."
          ]
        }
      },
      "BBR2": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M2 = 0",
        "documentation": {
          "title": "Branch on Bit 2 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 2 is clear."
          ]
        }
      },
      "BBR3": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M3 = 0",
        "documentation": {
          "title": "Branch on Bit 3 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 3 is clear."
          ]
        }
      },
      "BBR4": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M4 = 0",
        "documentation": {
          "title": "Branch on Bit 4 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 4 is clear."
          ]
        }
      },
      "BBR5": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M5 = 0",
        "documentation": {
          "title": "Branch on Bit 5 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 5 is clear."
          ]
        }
      },
      "BBR6": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M6 = 0",
        "documentation": {
          "title": "Branch on Bit 6 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 6 is clear."
          ]
        }
      },
      "BBR7": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M7 = 0",
        "documentation": {
          "title": "Branch on Bit 7 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 7 is clear."
          ]
        }
      },
      "BBS0": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M0 = 1",
        "documentation": {
          "title": "Branch on Bit 0 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 0 is set."
          ]
        }
      },
      "BBS1": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M1 = 1",
        "documentation": {
          "title": "Branch on Bit 1 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 1 is set."
          ]
        }
      },
      "BBS2": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M2 = 1",
        "documentation": {
          "title": "Branch on Bit 2 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 2 is set."
          ]
        }
      },
      "BBS3": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M3 = 1",
        "documentation": {
          "title": "Branch on Bit 3 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 3 is set."
          ]
        }
      },
      "BBS4": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M4 = 1",
        "documentation": {
          "title": "Branch on Bit 4 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 4 is set."
          ]
        }
      },
      "BBS5": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M5 = 1",
        "documentation": {
          "title": "Branch on Bit 5 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 5 is set."
          ]
        }
      },
      "BBS6": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M6 = 1",
        "documentation": {
          "title": "Branch on Bit 6 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 6 is set."
          ]
        }
      },
      "BBS7": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M7 = 1",
        "documentation": {
          "title": "Branch on Bit 7 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 7 is set."
          ]
        }
      },
      "RMB0": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M0",
        "documentation": {
          "title": "Reset Memory Bit 0",
          "text": [
            "This instruction clears bit 0 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "RMB1": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M1",
        "documentation": {
          "title": "Reset Memory Bit 1",
          "text": [
            "This instruction clears bit 1 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "RMB2": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M2",
        "documentation": {
          "title": "Reset Memory Bit 2",
          "text": [
            "This instruction clears bit 2 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "RMB3": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M3",
        "documentation": {
          "title": "Reset Memory Bit 3",
          "text": [
            "This instruction clears bit 3 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "RMB4": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M4",
        "documentation": {
          "title": "Reset Memory Bit 4",
          "text": [
            "This instruction clears bit 4 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "RMB5": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M5",
        "documentation": {
          "title": "Reset Memory Bit 5",
          "text": [
            "This instruction clears bit 5 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "RMB6": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M6",
        "documentation": {
          "title": "Reset Memory Bit 6",
          "text": [
            "This instruction clears bit 6 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "RMB7": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M7",
        "documentation": {
          "title": "Reset Memory Bit 7",
          "text": [
            "This instruction clears bit 7 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB0": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M0",
        "documentation": {
          "title": "Set Memory Bit 0",
          "text": [
            "This instruction sets bit 0 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB1": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M1",
        "documentation": {
          "title": "Set Memory Bit 1",
          "text": [
            "This instruction sets bit 1 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB2": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M2",
        "documentation": {
          "title": "Set Memory Bit 2",
          "text": [
            "This instruction sets bit 2 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB3": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M3",
        "documentation": {
          "title": "Set Memory Bit 3",
          "text": [
            "This instruction sets bit 3 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB4": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M4",
        "documentation": {
          "title": "Set Memory Bit 4",
          "text": [
            "This instruction sets bit 4 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB5": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M5",
        "documentation": {
          "title": "Set Memory Bit 5",
          "text": [
            "This instruction sets bit 5 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB6": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M6",
        "documentation": {
          "title": "Set Memory Bit 6",
          "text": [
            "This instruction sets bit 6 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB7": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M7",
        "documentation": {
          "title": "Set Memory Bit 7",
          "text": [
            "This instruction sets bit 7 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      }
    },
    "mnemos": {
      "ADC": {
        "description": "Add with Carry"
      },
      "AND": {
        "description": "Logical AND"
      },
      "ASL": {
        "description": "Arithmetic Shift Left"
      },
      "BCC": {
        "description": "Branch if Carry Clear"
      },
      "BCS": {
        "description": "Branch if Carry Set"
      },
      "BEQ": {
        "description": "Branch if Equal"
      },
      "BIT": {
        "description": "Bit Test"
      },
      "BMI": {
        "description": "Branch if Minus"
      },
      "BNE": {
        "description": "Branch if Not Equal"
      },
      "BPL": {
        "description": "Branch if Plus"
      },
      "BRK": {
        "description": "Force Interrupt"
      },
      "BVC": {
        "description": "Branch if Overflow Clear"
      },
      "BVS": {
        "description": "Branch if Overflow Set"
      },
      "CLC": {
        "description": "Clear Carry Flag"
      },
      "CLD": {
        "description": "Clear Decimal Mode"
      },
      "CLI": {
        "description": "Clear Interrupt Disable"
      },
      "CLV": {
        "description": "Clear Overflow Flag"
      },
      "CMP": {
        "description": "Compare"
      },
      "CPX": {
        "description": "Compare X Register"
      },
      "CPY": {
        "description": "Compare Y Register"
      },
      "DEC": {
        "description": "Decrement Memory"
      },
      "DEX": {
        "description": "Decrement X Register"
      },
      "DEY": {
        "description": "Decrement Y Register"
      },
      "EOR": {
        "description": "Exclusive OR"
      },
      "INC": {
        "description": "Increment Memory"
      },
      "INX": {
        "description": "Increment X Register"
      },
      "INY": {
        "description": "Increment Y Register"
      },
      "JMP": {
        "description": "Jump"
      },
      "JSR": {
        "description": "Jump to Subroutine"
      },
      "LDA": {
        "description": "Load Accumulator"
      },
      "LDX": {
        "description": "Load X Register"
      },
      "LDY": {
        "description": "Load Y Register"
      },
      "LSR": {
        "description": "Logical Shift Right"
      },
      "NOP": {
        "description": "No Operation"
      },
      "ORA": {
        "description": "Logical OR"
      },
      "PHA": {
        "description": "Push Accumulator"
      },
      "PHP": {
        "description": "Push Processor Status"
      },
      "PLA": {
        "description": "Pull Accumulator"
      },
      "PLP": {
        "description": "Pull Processor Status"
      },
      "ROL": {
        "description": "Rotate Left"
      },
      "ROR": {
        "description": "Rotate Right"
      },
      "RTI": {
        "description": "Return from Interrupt"
      },
      "RTS": {
        "description": "Return from Subroutine"
      },
      "SBC": {
        "description": "Subtract with Carry"
      },
      "SEC": {
        "description": "Set Carry Flag"
      },
      "SED": {
        "description": "Set Decimal Flag"
      },
      "SEI": {
        "description": "Set Interrupt Disable"
      },
      "STA": {
        "description": "Store Accumulator"
      },
      "STX": {
        "description": "Store X Register"
      },
      "STY": {
        "description": "Store Y Register"
      },
      "TAX": {
        "description": "Transfer Accumulator to X"
      },
      "TAY": {
        "description": "Transfer Accumulator to Y"
      },
      "TSX": {
        "description": "Transfer Stack Pointer to X"
      },
      "TXA": {
        "description": "Transfer X to Accumulator"
      },
      "TXS": {
        "description": "Transfer X to Stack Pointer"
      },
      "TYA": {
        "description": "Transfer Y to Accumulator"
      },
      "BRA": {
        "description": "Branch Always"
      },
      "PHX": {
        "description": "Push X Register"
      },
      "PHY": {
        "description": "Push Y Register"
      },
      "PLX": {
        "description": "Pull X Register"
      },
      "PLY": {
        "description": "Pull Y Register"
      },
      "STZ": {
        "description": "Store Zero"
      },
      "TRB": {
        "description": "Test and Reset Memory Bits"
      },
      "TSB": {
        "description": "Test and Set Memory Bits"
      },
      "BBR0": {
        "description": "Branch on Bit 0 Reset"
      },
      "BBR1": {
        "description": "Branch on Bit 1 Reset"
      },
      "BBR2": {
        "description": "Branch on Bit 2 Reset"
      },
      "BBR3": {
        "description": "Branch on Bit 3 Reset"
      },
      "BBR4": {
        "description": "Branch on Bit 4 Reset"
      },
      "BBR5": {
        "description": "Branch on Bit 5 Reset"
      },
      "BBR6": {
        "description": "Branch on Bit 6 Reset"
      },
      "BBR7": {
        "description": "Branch on Bit 7 Reset"
      },
      "BBS0": {
        "description": "Branch on Bit 0 Set"
      },
      "BBS1": {
        "description": "Branch on Bit 1 Set"
      },
      "BBS2": {
        "description": "Branch on Bit 2 Set"
      },
      "BBS3": {
        "description": "Branch on Bit 3 Set"
      },
      "BBS4": {
        "description": "Branch on Bit 4 Set"
      },
      "BBS5": {
        "description": "Branch on Bit 5 Set"
      },
      "BBS6": {
        "description": "Branch on Bit 6 Set"
      },
      "BBS7": {
        "description": "Branch on Bit 7 Set"
      },
      "RMB0": {
        "description": "Reset Memory Bit 0"
      },
      "RMB1": {
        "description": "Reset Memory Bit 1"
      },
      "RMB2": {
        "description": "Reset Memory Bit 2"
      },
      "RMB3": {
        "description": "Reset Memory Bit 3"
      },
      "RMB4": {
        "description": "Reset Memory Bit 4"
      },
      "RMB5": {
        "description": "Reset Memory Bit 5"
      },
      "RMB6": {
        "description": "Reset Memory Bit 6"
      },
      "RMB7": {
        "description": "Reset Memory Bit 7"
      },
      "SMB0": {
        "description": "Set Memory Bit 0"
      },
      "SMB1": {
        "description": "Set Memory Bit 1"
      },
      "SMB2": {
        "description": "Set Memory Bit 2"
      },
      "SMB3": {
        "description": "Set Memory Bit 3"
      },
      "SMB4": {
        "description": "Set Memory Bit 4"
      },
      "SMB5": {
        "description": "Set Memory Bit 5"
      },
      "SMB6": {
        "description": "Set Memory Bit 6"
      },
      "SMB7": {
        "description": "Set Memory Bit 7"
      }
    },
    "addmodes": {
      "-": {
        "bytes": "1",
        "syntax": "",
        "description": "Implied",
        "documentation": {
          "title": "Implied",
          "text": [
            "In the implied addressing mode, the address containing the operand is implicitly stated in the operation code of the instruction."
          ]
        }
      },
      "A": {
        "bytes": "1",
        "syntax": "A",
        "description": "Accumulator",
        "documentation": {
          "title": "Accumulator",
          "text": [
            "This form of addressing is represented with a one byte instruction, implying an operation on the accumulator."
          ]
        }
      },
      "#d8": {
        "bytes": "2",
        "syntax": "#$nn",
        "description": "Immediate",
        "documentation": {
          "title": "Immediate",
          "text": [
            "In immediate addressing, the operand is contained in the second byte of the instruction, with no further memory addressing required."
          ]
        }
      },
      "a8": {
        "bytes": "2",
        "syntax": "$nn",
        "description": "Zero Page",
        "documentation": {
          "title": "Zero Page",
          "text": [
            "The zero page instructions allow for shorter code and execution times by only fetching the second byte of the instruction and assuming a zero high address byte. Careful use of the zero page can result in significant increase in code efficiency."
          ]
        }
      },
      "a8,X": {
        "bytes": "2",
        "syntax": "$nn,X",
        "description": "X-Indexed Zero Page",
        "documentation": {
          "title": "X-Indexed Zero Page",
          "text": [
            "This form of addressing is used in conjunction with the X index register. The effective address is calculated by adding the second byte to the contents of the index register. Since this is a form of \"Zero Page\" addressing, the content of the second byte references a location in page zero. Additionally, due to the “Zero Page\" addressing nature of this mode, no carry is added to the high order 8 bits of memory and crossing of page boundaries does not occur."
          ]
        }
      },
      "a8,Y": {
        "bytes": "2",
        "syntax": "$nn,Y",
        "description": "Y-Indexed Zero Page",
        "documentation": {
          "title": "Y-Indexed Zero Page",
          "text": [
            "This form of addressing is used in conjunction with the Y index register. The effective address is calculated by adding the second byte to the contents of the index register. Since this is a form of \"Zero Page\" addressing, the content of the second byte references a location in page zero. Additionally, due to the “Zero Page\" addressing nature of this mode, no carry is added to the high order 8 bits of memory and crossing of page boundaries does not occur."
          ]
        }
      },
      "(a8,X)": {
        "bytes": "2",
        "syntax": "($nn,X)",
        "description": "X-Indexed Zero Page Indirect",
        "documentation": {
          "title": "X-Indexed Zero Page Indirect",
          "text": [
            "In indexed indirect addressing, the second byte of the instruction is added to the contents of the X index register, discarding the carry. The result of this addition points to a memory location on page zero whose contents is the low order eight bits of the effective address. The next memory location in page zero contains the high order eight bits of the effective address. Both memory locations specifying the high and low order bytes of the effective address must be in page zero."
          ]
        }
      },
      "(a8),Y": {
        "bytes": "2",
        "syntax": "($nn),Y",
        "description": "Zero Page Indirect Y-Indexed",
        "documentation": {
          "title": "Zero Page Indirect Y-Indexed",
          "text": [
            "In indirect indexed addressing, the second byte of the instruction points to a memory location in page zero. The contents of this memory location is added to the contents of the Y index register, the result being the low order eight bits of the effective address. The carry from this addition is added to the contents of the next page zero memory location, the result being the high order eight bits of the effective address."
          ]
        }
      },
      "a16": {
        "bytes": "3",
        "syntax": "$nnnn",
        "description": "Absolute",
        "documentation": {
          "title": "Absolute",
          "text": [
            "In absolute addressing, the second byte of the instruction specifies the eight low order bits of the effective address while the third byte specifies the eight high order bits. Thus, the absolute addressing mode allows access to the entire 65 K bytes of addressable memory."
          ]
        }
      },
      "a16,X": {
        "bytes": "3",
        "syntax": "$nnnn,X",
        "description": "X-Indexed Absolute",
        "documentation": {
          "title": "X-Indexed Absolute",
          "text": [
            "This form of addressing is used in conjunction with the X index register. The effective address is formed by adding the contents of X to the address contained in the second and third bytes of the instruction. This mode allows the index register to contain the index or count value and the instruction to contain the base address. This type of indexing allows any location referencing and the index to modify multiple fields resulting in reduced coding and execution time."
          ]
        }
      },
      "a16,Y": {
        "bytes": "3",
        "syntax": "$nnnn,Y",
        "description": "Y-Indexed Absolute",
        "documentation": {
          "title": "Y-Indexed Absolute",
          "text": [
            "This form of addressing is used in conjunction with the Y index register. The effective address is formed by adding the contents of Y to the address contained in the second and third bytes of the instruction. This mode allows the index register to contain the index or count value and the instruction to contain the base address. This type of indexing allows any location referencing and the index to modify multiple fields resulting in reduced coding and execution time."
          ]
        }
      },
      "(a16)": {
        "bytes": "3",
        "syntax": "($nnnn)",
        "description": "Absolute Indirect",
        "documentation": {
          "title": "Absolute Indirect",
          "text": [
            "The second byte of the instruction contains the low order eight bits of a memory location. The high order eight bits of that memory location is contained in the third byte of the instruction. The contents of the fully specified memory location is the low order byte of the effective address. The next memory location contains the high order byte of the effective address which is loaded into the sixteen bits of the program counter."
          ]
        }
      },
      "r8": {
        "bytes": "2",
        "syntax": "$nnnn",
        "description": "Relative",
        "documentation": {
          "title": "Relative",
          "text": [
            "Relative addressing is used only with branch instructions and establishes a destination for the conditional branch.",
            "The second byte of-the instruction becomes the operand which is an “Offset\" added to the contents of the lower eight bits of the program counter when the counter is set at the next instruction. The range of the offset is —128 to +127 bytes from the next instruction."
          ]
        }
      },
      "(a8)": {
        "bytes": "2",
        "syntax": "($nn)",
        "description": "Zero Page Indirect",
        "documentation": {
          "title": "Zero Page Indirect",
          "text": [
            "With Zero Page Indirect addressing mode, the second byte of the instruction is a zero page indirect address that points to the low byte of a two byte effective address."
          ]
        }
      },
      "(a16,X)": {
        "bytes": "3",
        "syntax": "($nnnn,X)",
        "description": "Absolute X-Indexed Indirect",
        "documentation": {
          "title": "Absolute X-Indexed Indirect",
          "text": [
            "With the Absolute Indexed Indirect addressing mode, the X Index Register is added to the second and third byes of the instruction to form an address to a pointer. This address mode is only used with the JMP instruction and the program Counter is loaded with the first and second bytes at this pointer."
          ]
        }
      },
      "a8,r8": {
        "bytes": "3",
        "syntax": "$nn,$nnnn",
        "description": "Zero Page, Relative",
        "documentation": {
          "title": "Zero Page, Relative",
          "text": [
            "This mode is used only with the bit-test branch instructions (BBS and BCC). The second byte of the instruction specifies the zero page memory to be tested. The third byte of the instruction is the offset, whose range is -128 to 127 bytes, referenced to the location of the next instruction."
          ]
        }
      }
    },
    "all_mnemos": {
      "regular": [
        "ADC",
        "AND",
        "ASL",
        "BBR0",
        "BBR1",
        "BBR2",
        "BBR3",
        "BBR4",
        "BBR5",
        "BBR6",
        "BBR7",
        "BBS0",
        "BBS1",
        "BBS2",
        "BBS3",
        "BBS4",
        "BBS5",
        "BBS6",
        "BBS7",
        "BCC",
        "BCS",
        "BEQ",
        "BIT",
        "BMI",
        "BNE",
        "BPL",
        "BRA",
        "BRK",
        "BVC",
        "BVS",
        "CLC",
        "CLD",
        "CLI",
        "CLV",
        "CMP",
        "CPX",
        "CPY",
        "DEC",
        "DEX",
        "DEY",
        "EOR",
        "INC",
        "INX",
        "INY",
        "JMP",
        "JSR",
        "LDA",
        "LDX",
        "LDY",
        "LSR",
        "NOP",
        "ORA",
        "PHA",
        "PHP",
        "PHX",
        "PHY",
        "PLA",
        "PLP",
        "PLX",
        "PLY",
        "RMB0",
        "RMB1",
        "RMB2",
        "RMB3",
        "RMB4",
        "RMB5",
        "RMB6",
        "RMB7",
        "ROL",
        "ROR",
        "RTI",
        "RTS",
        "SBC",
        "SEC",
        "SED",
        "SEI",
        "SMB0",
        "SMB1",
        "SMB2",
        "SMB3",
        "SMB4",
        "SMB5",
        "SMB6",
        "SMB7",
        "STA",
        "STX",
        "STY",
        "STZ",
        "TAX",
        "TAY",
        "TRB",
        "TSB",
        "TSX",
        "TXA",
        "TXS",
        "TYA"
      ],
      "illegal": [
        "NOP"
      ],
      "all": [
        "ADC",
        "AND",
        "ASL",
        "BBR0",
        "BBR1",
        "BBR2",
        "BBR3",
        "BBR4",
        "BBR5",
        "BBR6",
        "BBR7",
        "BBS0",
        "BBS1",
        "BBS2",
        "BBS3",
        "BBS4",
        "BBS5",
        "BBS6",
        "BBS7",
        "BCC",
        "BCS",
        "BEQ",
        "BIT",
        "BMI",
        "BNE",
        "BPL",
        "BRA",
        "BRK",
        "BVC",
        "BVS",
        "CLC",
        "CLD",
        "CLI",
        "CLV",
        "CMP",
        "CPX",
        "CPY",
        "DEC",
        "DEX",
        "DEY",
        "EOR",
        "INC",
        "INX",
        "INY",
        "JMP",
        "JSR",
        "LDA",
        "LDX",
        "LDY",
        "LSR",
        "NOP",
        "ORA",
        "PHA",
        "PHP",
        "PHX",
        "PHY",
        "PLA",
        "PLP",
        "PLX",
        "PLY",
        "RMB0",
        "RMB1",
        "RMB2",
        "RMB3",
        "RMB4",
        "RMB5",
        "RMB6",
        "RMB7",
        "ROL",
        "ROR",
        "RTI",
        "RTS",
        "SBC",
        "SEC",
        "SED",
        "SEI",
        "SMB0",
        "SMB1",
        "SMB2",
        "SMB3",
        "SMB4",
        "SMB5",
        "SMB6",
        "SMB7",
        "STA",
        "STX",
        "STY",
        "STZ",
        "TAX",
        "TAY",
        "TRB",
        "TSB",
        "TSX",
        "TXA",
        "TXS",
        "TYA"
      ]
    },
    "all_addmodes": {
      "regular": [
        "-",
        "A",
        "#d8",
        "a16",
        "a16,X",
        "a16,Y",
        "(a16)",
        "(a16,X)",
        "a8",
        "a8,X",
        "a8,Y",
        "(a8)",
        "(a8,X)",
        "(a8),Y",
        "r8",
        "a8,r8"
      ],
      "illegal": [
        "-",
        "#d8"
      ],
      "all": [
        "-",
        "A",
        "#d8",
        "a16",
        "a16,X",
        "a16,Y",
        "(a16)",
        "(a16,X)",
        "a8",
        "a8,X",
        "a8,Y",
        "(a8)",
        "(a8,X)",
        "(a8),Y",
        "r8",
        "a8,r8"
      ]
    }
  },
  "65c02s": {
    "info": {
      "manufacturer": "WDC",
      "name": "65C02S",
      "year": "1986",
      "id": "65c02s",
      "basedon": "r65c02",
      "description": "This is the later version of Western Design Center's 65C02, which supports the Rockwell extensions and adds two power saving opcodes borrowed from the 65c816."
    },
    "registers": {
      "registers": [
        "A",
        "X",
        "Y",
        "S",
        "P",
        "PC"
      ],
      "A": {
        "size": "8",
        "description": "Accumulator"
      },
      "X": {
        "size": "8",
        "description": "X Index Register"
      },
      "Y": {
        "size": "8",
        "description": "Y Index Register"
      },
      "S": {
        "size": "8",
        "description": "Stack Pointer"
      },
      "P": {
        "size": "8",
        "description": "Processor Status"
      },
      "PC": {
        "size": "16",
        "description": "Program Counter"
      }
    },
    "vectors": {
      "FFFA": "NMI",
      "FFFC": "RESET",
      "FFFE": "IRQ"
    },
    "flags": {
      "names": "NV-BDIZC",
      "N": "Negative",
      "V": "Overflow",
      "-": "(Expansion)",
      "B": "Break Command",
      "D": "Decimal",
      "I": "Interrupt Disable",
      "Z": "Zero",
      "C": "Carry"
    },
    "opcodes": [
      {
        "illegal": false,
        "mnemo": "BRK",
        "addmode": "-",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TSB",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB0",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHP",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TSB",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR0",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BPL",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TRB",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB1",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLC",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TRB",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR1",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "JSR",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB2",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PLP",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR2",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BMI",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a8,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB3",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SEC",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a16,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR3",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "RTI",
        "addmode": "-",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB4",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHA",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR4",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BVC",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB5",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLI",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PHY",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR5",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "RTS",
        "addmode": "-",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8,X)",
        "cycles": "6+d",
        "mincycles": 6,
        "maxcycles": 7,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STZ",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a8",
        "cycles": "3+d",
        "mincycles": 3,
        "maxcycles": 4,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB6",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PLA",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "#d8",
        "cycles": "2+d",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "(a16)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16",
        "cycles": "4+d",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR6",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BVS",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8),Y",
        "cycles": "5+p+d",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "p",
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8)",
        "cycles": "5+d",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STZ",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a8,X",
        "cycles": "4+d",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB7",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SEI",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16,Y",
        "cycles": "4+p+d",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "p",
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PLY",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "(a16,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16,X",
        "cycles": "4+p+d",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "p",
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR7",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BRA",
        "addmode": "r8",
        "cycles": "3+t+p",
        "mincycles": 3,
        "maxcycles": 5,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB0",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEY",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "#d8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TXA",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS0",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BCC",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8),Y",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a8,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB1",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TYA",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16,Y",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TXS",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STZ",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STZ",
        "addmode": "a16,X",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS1",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB2",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TAY",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TAX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS2",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BCS",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a8,Y",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB3",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLV",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "TSX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BBS3",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB4",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INY",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "WAI",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS4",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BNE",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8),Y",
        "cycles": "5+p",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a8,X",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB5",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLD",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16,Y",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PHX",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STP",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16,X",
        "cycles": "4+p",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS5",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8,X)",
        "cycles": "6+d",
        "mincycles": 6,
        "maxcycles": 7,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "a8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a8",
        "cycles": "3+d",
        "mincycles": 3,
        "maxcycles": 4,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB6",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "#d8",
        "cycles": "2+d",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "a16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16",
        "cycles": "4+d",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS6",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BEQ",
        "addmode": "r8",
        "cycles": "2+t+p",
        "mincycles": 2,
        "maxcycles": 4,
        "cyclesymbols": [
          "t",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8),Y",
        "cycles": "5+p+d",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "p",
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8)",
        "cycles": "5+d",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "#d8",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a8,X",
        "cycles": "4+d",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a8,X",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB7",
        "addmode": "a8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SED",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16,Y",
        "cycles": "4+p+d",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "p",
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PLX",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": true,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16,X",
        "cycles": "4+p+d",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "p",
          "d"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a16,X",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS7",
        "addmode": "a8,r8",
        "cycles": "5+t+p",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "t",
          "p"
        ]
      }
    ],
    "operations": {
      "ADC": {
        "category": "arith",
        "flags": "NV----ZC",
        "description": "A + M + C → A, C",
        "documentation": {
          "title": "Add Memory to Accumulator with Carry",
          "text": [
            "This instruction adds the value of memory and carry from the previous operation to the value of the accumulator and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the carry flag when the sum of a binary add exceeds 255 or when the sum of a decimal add exceeds 99, otherwise carry is reset. The overflow flag is set when the sign or bit 7 is changed due to the result exceeding +127 or -128, otherwise overflow is reset. The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. The zero flag is set if the accumulator result is 0, otherwise the zero flag is reset."
          ]
        }
      },
      "AND": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ∧ M → A",
        "documentation": {
          "title": "\"AND\" Memory with Accumulator",
          "text": [
            "The AND instruction transfer the accumulator and memory to the adder which performs a bit-by-bit AND operation and stores the result back in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "ASL": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C ← /M7...M0/ ← 0",
        "documentation": {
          "title": "Arithmetic Shift Left",
          "text": [
            "The shift left instruction shifts either the accumulator or the address memory location 1 bit to the left, with the bit 0 always being set to 0 and the the input bit 7 being stored in the carry flag. ASL either shifts the accumulator left 1 bit or is a read/modify/write instruction that affects only memory.",
            "The instruction does not affect the overflow bit, sets N equal to the result bit 7 (bit 6 in the input), sets Z flag if the result is equal to 0, otherwise resets Z and stores the input bit 7 in the carry flag."
          ]
        }
      },
      "BCC": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on C = 0",
        "documentation": {
          "title": "Branch on Carry Clear",
          "text": [
            "This instruction tests the state of the carry bit and takes a conditional branch if the carry bit is reset.",
            "It affects no flags or registers other than the program counter and then only if the C flag is not on."
          ]
        }
      },
      "BCS": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on C = 1",
        "documentation": {
          "title": "Branch on Carry Set",
          "text": [
            "This instruction takes the conditional branch if the carry flag is on.",
            "BCS does not affect any of the flags or registers except for the program counter and only then if the carry flag is on."
          ]
        }
      },
      "BEQ": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on Z = 1",
        "documentation": {
          "title": "Branch on Result Zero",
          "text": [
            "This instruction could also be called \"Branch on Equal.\"",
            "It takes a conditional branch whenever the Z flag is on or the previ­ ous result is equal to 0.",
            "BEQ does not affect any of the flags or registers other than the program counter and only then when the Z flag is set."
          ]
        }
      },
      "BIT": {
        "category": "logic",
        "flags": "NV----Z-",
        "description": "A ∧ M, M7 → N, M6 → V",
        "documentation": {
          "title": "Test Bits in Memory with Accumulator",
          "text": [
            "This instruction performs an AND between a memory location and the accumulator but does not store the result of the AND into the accumulator.",
            "The bit instruction affects the N flag with N being set to the value of bit 7 of the memory being tested, the V flag with V being set equal to bit 6 of the memory being tested and Z being set by the result of the AND operation between the accumulator and the memory if the result is Zero, Z is reset otherwise. It does not affect the accumulator."
          ]
        }
      },
      "BMI": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on N = 1",
        "documentation": {
          "title": "Branch on Result Minus",
          "text": [
            "This instruction takes the conditional branch if the N bit is set.",
            "BMI does not affect any of the flags or any other part of the machine other than the program counter and then only if the N bit is on."
          ]
        }
      },
      "BNE": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on Z = 0",
        "documentation": {
          "title": "Branch on Result Not Zero",
          "text": [
            "This instruction could also be called \"Branch on Not Equal.\" It tests the Z flag and takes the conditional branch if the Z flag is not on, indicating that the previous result was not zero.",
            "BNE does not affect any of the flags or registers other than the program counter and only then if the Z flag is reset."
          ]
        }
      },
      "BPL": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on N = 0",
        "documentation": {
          "title": "Branch on Result Plus",
          "text": [
            "This instruction is the complementary branch to branch on result minus. It is a conditional branch which takes the branch when the N bit is reset (0). BPL is used to test if the previous result bit 7 was off (0) and branch on result minus is used to determine if the previous result was minus or bit 7 was on (1).",
            "The instruction affects no flags or other registers other than the P counter and only affects the P counter when the N bit is reset."
          ]
        }
      },
      "BRK": {
        "category": "ctrl",
        "flags": "-----1--",
        "description": "PC + 2↓, [FFFE] → PCL, [FFFF] → PCH",
        "documentation": {
          "title": "Break Command",
          "text": [
            "The break command causes the microprocessor to go through an inter­ rupt sequence under program control. This means that the program counter of the second byte after the BRK. is automatically stored on the stack along with the processor status at the beginning of the break instruction. The microprocessor then transfers control to the interrupt vector.",
            "Other than changing the program counter, the break instruction changes no values in either the registers or the flags."
          ]
        }
      },
      "BVC": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on V = 0",
        "documentation": {
          "title": "Branch on Overflow Clear",
          "text": [
            "This instruction tests the status of the V flag and takes the conditional branch if the flag is not set.",
            "BVC does not affect any of the flags and registers other than the program counter and only when the overflow flag is reset."
          ]
        }
      },
      "BVS": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on V = 1",
        "documentation": {
          "title": "Branch on Overflow Set",
          "text": [
            "This instruction tests the V flag and takes the conditional branch if V is on.",
            "BVS does not affect any flags or registers other than the program, counter and only when the overflow flag is set."
          ]
        }
      },
      "CLC": {
        "category": "flags",
        "flags": "-------0",
        "description": "0 → C",
        "documentation": {
          "title": "Clear Carry Flag",
          "text": [
            "This instruction initializes the carry flag to a 0. This op­ eration should normally precede an ADC loop. It is also useful when used with a R0L instruction to clear a bit in memory.",
            "This instruction affects no registers in the microprocessor and no flags other than the carry flag which is reset."
          ]
        }
      },
      "CLD": {
        "category": "flags",
        "flags": "----0---",
        "description": "0 → D",
        "documentation": {
          "title": "Clear Decimal Mode",
          "text": [
            "This instruction sets the decimal mode flag to a 0. This all subsequent ADC and SBC instructions to operate as simple operations.",
            "CLD affects no registers in the microprocessor and no flags other than the decimal mode flag which is set to a 0."
          ]
        }
      },
      "CLI": {
        "category": "flags",
        "flags": "-----0--",
        "description": "0 → I",
        "documentation": {
          "title": "Clear Interrupt Disable",
          "text": [
            "This instruction initializes the interrupt disable to a 0. This allows the microprocessor to receive interrupts.",
            "It affects no registers in the microprocessor and no flags other than the interrupt disable which is cleared."
          ]
        }
      },
      "CLV": {
        "category": "flags",
        "flags": "-0------",
        "description": "0 → V",
        "documentation": {
          "title": "Clear Overflow Flag",
          "text": [
            "This instruction clears the overflow flag to a 0. This com­ mand is used in conjunction with the set overflow pin which can change the state of the overflow flag with an external signal.",
            "CLV affects no registers in the microprocessor and no flags other than the overflow flag which is set to a 0."
          ]
        }
      },
      "CMP": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "A - M",
        "documentation": {
          "title": "Compare Memory and Accumulator",
          "text": [
            "This instruction subtracts the contents of memory from the contents of the accumulator.",
            "The use of the CMP affects the following flags: Z flag is set on an equal comparison, reset otherwise; the N flag is set or reset by the result bit 7, the carry flag is set when the value in memory is less than or equal to the accumulator, reset when it is greater than the accumulator. The accumulator is not affected."
          ]
        }
      },
      "CPX": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "X - M",
        "documentation": {
          "title": "Compare Index Register X To Memory",
          "text": [
            "This instruction subtracts the value of the addressed memory location from the content of index register X using the adder but does not store the result; therefore, its only use is to set the N, Z and C flags to allow for comparison between the index register X and the value in memory.",
            "The CPX instruction does not affect any register in the machine; it also does not affect the overflow flag. It causes the carry to be set on if the absolute value of the index register X is equal to or greater than the data from memory. If the value of the memory is greater than the content of the index register X, carry is reset. If the results of the subtraction contain a bit 7, then the N flag is set, if not, it is reset. If the value in memory is equal to the value in index register X, the Z flag is set, otherwise it is reset."
          ]
        }
      },
      "CPY": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "Y - M",
        "documentation": {
          "title": "Compare Index Register Y To Memory",
          "text": [
            "This instruction performs a two's complement subtraction between the index register Y and the specified memory location. The results of the subtraction are not stored anywhere. The instruction is strict­ly used to set the flags.",
            "CPY affects no registers in the microprocessor and also does not affect the overflow flag. If the value in the index register Y is equal to or greater than the value in the memory, the carry flag will be set, otherwise it will be cleared. If the results of the subtract- tion contain bit 7 on the N bit will be set, otherwise it will be cleared. If the value in the index register Y and the value in the memory are equal, the zero flag will be set, otherwise it will be cleared."
          ]
        }
      },
      "DEC": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "M - 1 → M",
        "documentation": {
          "title": "Decrement Memory By One",
          "text": [
            "This instruction subtracts 1, in two's complement, from the contents of the addressed memory location.",
            "The decrement instruction does not affect any internal register in the microprocessor. It does not affect the carry or overflow flags. If bit 7 is on as a result of the decrement, then the N flag is set, otherwise it is reset. If the result of the decrement is 0, the Z flag is set, other­wise it is reset."
          ]
        }
      },
      "DEX": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "X - 1 → X",
        "documentation": {
          "title": "Decrement Index Register X By One",
          "text": [
            "This instruction subtracts one from the current value of the index register X and stores the result in the index register X.",
            "DEX does not affect the carry or overflow flag, it sets the N flag if it has bit 7 on as a result of the decrement, otherwise it resets the N flag; sets the Z flag if X is a 0 as a result of the decrement, otherwise it resets the Z flag."
          ]
        }
      },
      "DEY": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "Y - 1 → Y",
        "documentation": {
          "title": "Decrement Index Register Y By One",
          "text": [
            "This instruction subtracts one from the current value in the in­ dex register Y and stores the result into the index register Y. The result does not affect or consider carry so that the value in the index register Y is decremented to 0 and then through 0 to FF.",
            "Decrement Y does not affect the carry or overflow flags; if the Y register contains bit 7 on as a result of the decrement the N flag is set, otherwise the N flag is reset. If the Y register is 0 as a result of the decrement, the Z flag is set otherwise the Z flag is reset. This instruction only affects the index register Y."
          ]
        }
      },
      "EOR": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ⊻ M → A",
        "documentation": {
          "title": "\"Exclusive OR\" Memory with Accumulator",
          "text": [
            "The EOR instruction transfers the memory and the accumulator to the adder which performs a binary \"EXCLUSIVE OR\" on a bit-by-bit basis and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "INC": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "M + 1 → M",
        "documentation": {
          "title": "Increment Memory By One",
          "text": [
            "This instruction adds 1 to the contents of the addressed memory loca­tion.",
            "The increment memory instruction does not affect any internal registers and does not affect the carry or overflow flags. If bit 7 is on as the result of the increment,N is set, otherwise it is reset; if the increment causes the result to become 0, the Z flag is set on, otherwise it is reset."
          ]
        }
      },
      "INX": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "X + 1 → X",
        "documentation": {
          "title": "Increment Index Register X By One",
          "text": [
            "Increment X adds 1 to the current value of the X register. This is an 8-bit increment which does not affect the carry operation, therefore, if the value of X before the increment was FF, the resulting value is 00.",
            "INX does not affect the carry or overflow flags; it sets the N flag if the result of the increment has a one in bit 7, otherwise resets N; sets the Z flag if the result of the increment is 0, otherwise it resets the Z flag.",
            "INX does not affect any other register other than the X register."
          ]
        }
      },
      "INY": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "Y + 1 → Y",
        "documentation": {
          "title": "Increment Index Register Y By One",
          "text": [
            "Increment Y increments or adds one to the current value in the Y register, storing the result in the Y register. As in the case of INX the primary application is to step thru a set of values using the Y register.",
            "The INY does not affect the carry or overflow flags, sets the N flag if the result of the increment has a one in bit 7, otherwise resets N, sets Z if as a result of the increment the Y register is zero otherwise resets the Z flag."
          ]
        }
      },
      "JMP": {
        "category": "ctrl",
        "flags": "--------",
        "description": "[PC + 1] → PCL, [PC + 2] → PCH",
        "documentation": {
          "title": "JMP Indirect",
          "text": [
            "This instruction establishes a new valne for the program counter.",
            "It affects only the program counter in the microprocessor and affects no flags in the status register."
          ]
        }
      },
      "JSR": {
        "category": "ctrl",
        "flags": "--------",
        "description": "PC + 2↓, [PC + 1] → PCL, [PC + 2] → PCH",
        "documentation": {
          "title": "Jump To Subroutine",
          "text": [
            "This instruction transfers control of the program counter to a subroutine location but leaves a return pointer on the stack to allow the user to return to perform the next instruction in the main program after the subroutine is complete. To accomplish this, JSR instruction stores the program counter address which points to the last byte of the jump instruc­ tion onto the stack using the stack pointer. The stack byte contains the program count high first, followed by program count low. The JSR then transfers the addresses following the jump instruction to the program counter low and the program counter high, thereby directing the program to begin at that new address.",
            "The JSR instruction affects no flags, causes the stack pointer to be decremented by 2 and substitutes new values into the program counter low and the program counter high."
          ]
        }
      },
      "LDA": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → A",
        "documentation": {
          "title": "Load Accumulator with Memory",
          "text": [
            "When instruction LDA is executed by the microprocessor, data is transferred from memory to the accumulator and stored in the accumulator.",
            "LDA affects the contents of the accumulator, does not affect the carry or overflow flags; sets the zero flag if the accumulator is zero as a result of the LDA, otherwise resets the zero flag; sets the negative flag if bit 7 of the accumulator is a 1, other­ wise resets the negative flag."
          ]
        }
      },
      "LDX": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → X",
        "documentation": {
          "title": "Load Index Register X From Memory",
          "text": [
            "Load the index register X from memory.",
            "LDX does not affect the C or V flags; sets Z if the value loaded was zero, otherwise resets it; sets N if the value loaded in bit 7 is a 1; otherwise N is reset, and affects only the X register."
          ]
        }
      },
      "LDY": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → Y",
        "documentation": {
          "title": "Load Index Register Y From Memory",
          "text": [
            "Load the index register Y from memory.",
            "LDY does not affect the C or V flags, sets the N flag if the value loaded in bit 7 is a 1, otherwise resets N, sets Z flag if the loaded value is zero otherwise resets Z and only affects the Y register."
          ]
        }
      },
      "LSR": {
        "category": "shift",
        "flags": "0-----ZC",
        "description": "0 → /M7...M0/ → C",
        "documentation": {
          "title": "Logical Shift Right",
          "text": [
            "This instruction shifts either the accumulator or a specified memory location 1 bit to the right, with the higher bit of the result always being set to 0, and the low bit which is shifted out of the field being stored in the carry flag.",
            "The shift right instruction either affects the accumulator by shift­ing it right 1 or is a read/modify/write instruction which changes a speci­fied memory location but does not affect any internal registers. The shift right does not affect the overflow flag. The N flag is always reset. The Z flag is set if the result of the shift is 0 and reset otherwise. The carry is set equal to bit 0 of the input."
          ]
        }
      },
      "NOP": {
        "category": "nop",
        "flags": "--------",
        "description": "No operation"
      },
      "ORA": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ∨ M → A",
        "documentation": {
          "title": "\"OR\" Memory with Accumulator",
          "text": [
            "The ORA instruction transfers the memory and the accumulator to the adder which performs a binary \"OR\" on a bit-by-bit basis and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "PHA": {
        "category": "stack",
        "flags": "--------",
        "description": "A↓",
        "documentation": {
          "title": "Push Accumulator On Stack",
          "text": [
            "This instruction transfers the current value of the accumulator to the next location on the stack, automatically decrementing the stack to point to the next empty location.",
            "The Push A instruction only affects the stack pointer register which is decremented by 1 as a result of the operation. It affects no flags."
          ]
        }
      },
      "PHP": {
        "category": "stack",
        "flags": "--------",
        "description": "P↓",
        "documentation": {
          "title": "Push Processor Status On Stack",
          "text": [
            "This instruction transfers the contents of the processor status reg­ ister unchanged to the stack, as governed by the stack pointer.",
            "The PHP instruction affects no registers or flags in the micropro­cessor."
          ]
        }
      },
      "PLA": {
        "category": "stack",
        "flags": "N-----Z-",
        "description": "A↑",
        "documentation": {
          "title": "Pull Accumulator From Stack",
          "text": [
            "This instruction adds 1 to the current value of the stack pointer and uses it to address the stack and loads the contents of the stack into the A register.",
            "The PLA instruction does not affect the carry or overflow flags. It sets N if the bit 7 is on in accumulator A as a result of instructions, otherwise it is reset. If accumulator A is zero as a result of the PLA, then the Z flag is set, otherwise it is reset. The PLA instruction changes content of the accumulator A to the contents of the memory location at stack register plus 1 and also increments the stack register."
          ]
        }
      },
      "PLP": {
        "category": "stack",
        "flags": "NV--DIZC",
        "description": "P↑",
        "documentation": {
          "title": "Pull Processor Status From Stack",
          "text": [
            "This instruction transfers the next value on the stack to the Proces­ sor Status register, thereby changing all of the flags and setting the mode switches to the values from the stack.",
            "The PLP instruction affects no registers in the processor other than the status register. This instruction could affect all flags in the status register."
          ]
        }
      },
      "ROL": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C ← /M7...M0/ ← C",
        "documentation": {
          "title": "Rotate Left",
          "text": [
            "The rotate left instruction shifts either the accumulator or addressed memory left 1 bit, with the input carry being stored in bit 0 and with the input bit 7 being stored in the carry flags.",
            "The ROL instruction either shifts the accumulator left 1 bit and stores the carry in accumulator bit 0 or does not affect the internal reg­isters at all. The ROL instruction sets carry equal to the input bit 7, sets N equal to the input bit 6 , sets the Z flag if the result of the ro­ tate is 0, otherwise it resets Z and does not affect the overflow flag at all."
          ]
        }
      },
      "ROR": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C → /M7...M0/ → C",
        "documentation": {
          "title": "Rotate Right",
          "text": [
            "The rotate right instruction shifts either the accumulator or addressed memory right 1 bit with bit 0 shifted into the carry and carry shifted into bit 7.",
            "The ROR instruction either shifts the accumulator right 1 bit and stores the carry in accumulator bit 7 or does not affect the internal regis­ ters at all. The ROR instruction sets carry equal to input bit 0, sets N equal to the input carry and sets the Z flag if the result of the rotate is 0; otherwise it resets Z and does not affect the overflow flag at all.",
            "(Available on Microprocessors after June, 1976)"
          ]
        }
      },
      "RTI": {
        "category": "ctrl",
        "flags": "NV--DIZC",
        "description": "P↑ PC↑",
        "documentation": {
          "title": "Return From Interrupt",
          "text": [
            "This instruction transfers from the stack into the microprocessor the processor status and the program counter location for the instruction which was interrupted. By virtue of the interrupt having stored this data before executing the instruction and thei fact that the RTI reinitializes the microprocessor to the same state as when it was interrupted, the combination of interrupt plus RTI allows truly reentrant coding.",
            "The RTI instruction reinitializes all flags to the position to the point they were at the time the interrupt was taken and sets the program counter back to its pre-interrupt state. It affects no other registers in the microprocessor."
          ]
        }
      },
      "RTS": {
        "category": "ctrl",
        "flags": "--------",
        "description": "PC↑, PC + 1 → PC",
        "documentation": {
          "title": "Return From Subroutme",
          "text": [
            "This instruction loads the program count low and program count high from the stack into the program counter and increments the program counter so that it points to the instruction following the JSR. The stack pointer is adjusted by incrementing it twice.",
            "The RTS instruction does not affect any flags and affects only PCL and PCH."
          ]
        }
      },
      "SBC": {
        "category": "arith",
        "flags": "NV----ZC",
        "description": "A - M - ~C → A",
        "documentation": {
          "title": "Subtract Memory from Accumulator with Borrow",
          "text": [
            "This instruction subtracts the value of memory and borrow from the value of the accumulator, using two's complement arithmetic, and stores the result in the accumulator. Borrow is defined as the carry flag complemented; therefore, a resultant carry flag indicates that a borrow has not occurred.",
            "This instruction affects the accumulator. The carry flag is set if the result is greater than or equal to 0. The carry flag is reset when the result is less than 0, indicating a borrow. The over­flow flag is set when the result exceeds +127 or -127, otherwise it is reset. The negative flag is set if the result in the accumulator has bit 7 on, otherwise it is reset. The Z flag is set if the result in the accumulator is 0, otherwise it is reset."
          ]
        }
      },
      "SEC": {
        "category": "flags",
        "flags": "-------1",
        "description": "1 → C",
        "documentation": {
          "title": "Set Carry Flag",
          "text": [
            "This instruction initializes the carry flag to a 1. This op eration should normally precede a SBC loop. It is also useful when used with a ROL instruction to initialize a bit in memory to a 1.",
            "This instruction affects no registers in the microprocessor and no flags other than the carry flag which is set."
          ]
        }
      },
      "SED": {
        "category": "flags",
        "flags": "----1---",
        "description": "1 → D",
        "documentation": {
          "title": "Set Decimal Mode",
          "text": [
            "This instruction sets the decimal mode flag D to a 1. This makes all subsequent ADC and SBC instructions operate as a decimal arithmetic operation.",
            "SED affects no registers in the microprocessor and no flags other than the decimal mode which is set to a 1."
          ]
        }
      },
      "SEI": {
        "category": "flags",
        "flags": "-----1--",
        "description": "1 → I",
        "documentation": {
          "title": "Set Interrupt Disable",
          "text": [
            "This instruction initializes the interrupt disable to a 1. It is used to mask interrupt requests during system reset operations and during interrupt commands.",
            "It affects no registers in the microprocessor and no flags other than the interrupt disable which is set."
          ]
        }
      },
      "STA": {
        "category": "load",
        "flags": "--------",
        "description": "A → M",
        "documentation": {
          "title": "Store Accumulator in Memory",
          "text": [
            "This instruction transfers the contents of the accumulator to memory.",
            "This instruction affects none of the flags in the processor status register and does not affect the accumulator."
          ]
        }
      },
      "STX": {
        "category": "load",
        "flags": "--------",
        "description": "X → M",
        "documentation": {
          "title": "Store Index Register X In Memory",
          "text": [
            "Transfers value of X register to addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "STY": {
        "category": "load",
        "flags": "--------",
        "description": "Y → M",
        "documentation": {
          "title": "Store Index Register Y In Memory",
          "text": [
            "Transfer the value of the Y register to the addressed memory location.",
            "STY does not affect any flags or registers in the microprocessor."
          ]
        }
      },
      "TAX": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "A → X",
        "documentation": {
          "title": "Transfer Accumulator To Index X",
          "text": [
            "This instruction takes the value from accumulator A and trans­ fers or loads it into the index register X without disturbing the content of the accumulator A.",
            "TAX only affects the index register X, does not affect the carry or overflow flags. The N flag is set if the resultant value in the index register X has bit 7 on, otherwise N is reset. The Z bit is set if the content of the register X is 0 as aresult of theopera­ tion, otherwise it is reset."
          ]
        }
      },
      "TAY": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "A → Y",
        "documentation": {
          "title": "Transfer Accumula Tor To Index Y",
          "text": [
            "This instruction moves the value of the accumulator into index register Y without affecting the accumulator.",
            "TAY instruction only affects the Y register and does not affect either the carry or overflow flags. If the index register Y has bit 7 on, then N is set, otherwise it is reset. If the content of the index register Y equals 0 as a result of the operation, Z is set on, otherwise it is reset."
          ]
        }
      },
      "TSX": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "S → X",
        "documentation": {
          "title": "Transfer Stack Pointer To Index X",
          "text": [
            "This instruction transfers the value in the stack pointer to the index register X.",
            "TSX does not affect the carry or overflow flags. It sets N if bit 7 is on in index X as a result of the instruction, otherwise it is reset. If index X is zero as a result of the TSX, the Z flag is set, other­ wise it is reset. TSX changes the value of index X, making it equal to the content of the stack pointer."
          ]
        }
      },
      "TXA": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "X → A",
        "documentation": {
          "title": "Transfer Index X To Accumulator",
          "text": [
            "This instruction moves the value that is in the index register X to the accumulator A without disturbing the content of the index register X.",
            "TXA does not affect any register other than the accumula­tor and does not affect the carry or overflow flag. If the result in A has bit 7 on, then the N flag is set, otherwise it is reset. If the resultant value in the accumulator is 0, then the Z flag is set, other­ wise it is reset."
          ]
        }
      },
      "TXS": {
        "category": "trans",
        "flags": "--------",
        "description": "X → S",
        "documentation": {
          "title": "Transfer Index X To Stack Pointer",
          "text": [
            "This instruction transfers the value in the index register X to the stack pointer.",
            "TXS changes only the stack pointer, making it equal to the content of the index register X. It does not affect any of the flags."
          ]
        }
      },
      "TYA": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "Y → A",
        "documentation": {
          "title": "Transfer Index Y To Accumulator",
          "text": [
            "This instruction moves the value that is in the index register Y to accumulator A without disturbing the content of the register Y.",
            "TYA does not affect any other register other than the accumula­ tor and does not affect the carry or overflow flag. If the result in the accumulator A has bit 7 on, the N flag is set, otherwise it is reset. If the resultant value in the accumulator A is 0, then the Z flag is set, otherwise it is reset."
          ]
        }
      },
      "#": {
        "category": "mnemos",
        "flags": "are",
        "description": "based on VICE"
      },
      "ANC": {
        "category": "arith",
        "flags": "*-----**",
        "description": "A ∧ M → A, N → C",
        "documentation": {
          "title": "\"AND\" Memory with Accumulator then Move Negative Flag to Carry Flag",
          "text": [
            "The undocumented ANC instruction performs a bit-by-bit AND operation of the accumulator and memory and stores the result back in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag and the carry flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag and the carry flag."
          ]
        }
      },
      "ARR": {
        "category": "arith",
        "flags": "**----**",
        "description": "(A ∧ M) / 2 → A",
        "documentation": {
          "title": "\"AND\" Accumulator then Rotate Right",
          "text": [
            "The undocumented ARR instruction performs a bit-by-bit \"AND\" operation of the accumulator and memory, then shifts the result right 1 bit with bit 0 shifted into the carry and carry shifted into bit 7. It then stores the result back in the accumulator.",
            "If bit 7 of the result is on, then the N flag is set, otherwise it is reset. The instruction sets the Z flag if the result is 0; otherwise it resets Z.",
            "The V and C flags depends on the Decimal Mode Flag:",
            "In decimal mode, the V flag is set if bit 6 is different than the original data's bit 6, otherwise the V flag is reset. The C flag is set if (operand & 0xF0) + (operand & 0x10) is greater than 0x50, otherwise the C flag is reset.",
            "In binary mode, the V flag is set if bit 6 of the result is different than bit 5 of the result, otherwise the V flag is reset. The C flag is set if the result in the accumulator has bit 6 on, otherwise it is reset."
          ]
        }
      },
      "ASR": {
        "category": "arith",
        "flags": "0-----**",
        "description": "(A ∧ M) / 2 → A",
        "documentation": {
          "title": "\"AND\" then Logical Shift Right",
          "text": [
            "The undocumented ASR instruction performs a bit-by-bit AND operation of the accumulator and memory, then shifts the accumulator 1 bit to the right, with the higher bit of the result always being set to 0, and the low bit which is shifted out of the field being stored in the carry flag.",
            "This instruction affects the accumulator. It does not affect the overflow flag. The N flag is always reset. The Z flag is set if the result of the shift is 0 and reset otherwise. The carry is set equal to bit 0 of the result of the \"AND\" operation."
          ]
        }
      },
      "DCP": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M - 1 → M, A - M",
        "documentation": {
          "title": "Decrement Memory By One then Compare with Accumulator",
          "text": [
            "This undocumented instruction subtracts 1, in two's complement, from the contents of the addressed memory location. It then subtracts the contents of memory from the contents of the accumulator.",
            "The DCP instruction does not affect any internal register in the microprocessor. It does not affect the overflow flag. Z flag is set on an equal comparison, reset otherwise; the N flag is set or reset by the result bit 7, the carry flag is set when the result in memory is less than or equal to the accumulator, reset when it is greater than the accumulator."
          ]
        }
      },
      "ISC": {
        "category": "arith",
        "flags": "**----**",
        "description": "M + 1 → M, A - M → A",
        "documentation": {
          "title": "Increment Memory By One then SBC then Subtract Memory from Accumulator with Borrow",
          "text": [
            "This undocumented instruction adds 1 to the contents of the addressed memory loca­tion. It then subtracts the value of the result in memory and borrow from the value of the accumulator, using two's complement arithmetic, and stores the result in the accumulator.",
            "This instruction affects the accumulator. The carry flag is set if the result is greater than or equal to 0. The carry flag is reset when the result is less than 0, indicating a borrow. The over­flow flag is set when the result exceeds +127 or -127, otherwise it is reset. The negative flag is set if the result in the accumulator has bit 7 on, otherwise it is reset. The Z flag is set if the result in the accumulator is 0, otherwise it is reset."
          ]
        }
      },
      "JAM": {
        "category": "kil",
        "flags": "--------",
        "description": "Stop execution",
        "documentation": {
          "title": "Halt the CPU",
          "text": [
            "This undocumented instruction stops execution. The microprocessor will not fetch further instructions, and will neither handle IRQs nor NMIs. It will handle a RESET though."
          ]
        }
      },
      "LAS": {
        "category": "load",
        "flags": "*-----*-",
        "description": "M ∧ S → A, X, S",
        "documentation": {
          "title": "\"AND\" Memory with Stack Pointer",
          "text": [
            "This undocumented instruction performs a bit-by-bit \"AND\" operation of the stack pointer and memory and stores the result back in the accumulator, the index register X and the stack pointer.",
            "The LAS instruction does not affect the carry or overflow flags. It sets N if the bit 7 of the result is on, otherwise it is reset. If the result is zero, then the Z flag is set, otherwise it is reset."
          ]
        }
      },
      "LAX": {
        "category": "load",
        "flags": "*-----*-",
        "description": "M → A, X",
        "documentation": {
          "title": "Load Accumulator and Index Register X From Memory",
          "text": [
            "The undocumented LAX instruction loads the accumulator and the index register X from memory.",
            "LAX does not affect the C or V flags; sets Z if the value loaded was zero, otherwise resets it; sets N if the value loaded in bit 7 is a 1; otherwise N is reset, and affects only the X register."
          ]
        }
      },
      "RLA": {
        "category": "arith",
        "flags": "*-----**",
        "description": "C ← /M7...M0/ ← C, A ∧ M → A",
        "documentation": {
          "title": "Rotate Left then \"AND\" with Accumulator",
          "text": [
            "The undocumented RLA instruction shifts the addressed memory left 1 bit, with the input carry being stored in bit 0 and with the input bit 7 being stored in the carry flags. It then performs a bit-by-bit AND operation of the result and the value of the accumulator and stores the result back in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "RRA": {
        "category": "arith",
        "flags": "**----**",
        "description": "C → /M7...M0/ → C, A + M + C → A",
        "documentation": {
          "title": "Rotate Right and Add Memory to Accumulator",
          "text": [
            "The undocumented RRA instruction shifts the addressed memory right 1 bit with bit 0 shifted into the carry and carry shifted into bit 7. It then adds the result and generated carry to the value of the accumulator and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the carry flag when the sum of a binary add exceeds 255 or when the sum of a decimal add exceeds 99, otherwise carry is reset. The overflow flag is set when the sign or bit 7 is changed due to the result exceeding +127 or -128, otherwise overflow is reset. The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. The zero flag is set if the accumulator result is 0, otherwise the zero flag is reset."
          ]
        }
      },
      "SAX": {
        "category": "load",
        "flags": "--------",
        "description": "A ∧ X → M",
        "documentation": {
          "title": "Store Accumulator \"AND\" Index Register X in Memory",
          "text": [
            "The undocumented SAX instruction performs a bit-by-bit AND operation of the value of the accumulator and the value of the index register X and stores the result in memory.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SBX": {
        "category": "arith",
        "flags": "*-----**",
        "description": "(A ∧ X) - M → X",
        "documentation": {
          "title": "Subtract Memory from Accumulator \"AND\" Index Register X",
          "text": [
            "This undocumented instruction performs a bit-by-bit \"AND\" of the value of the accumulator and the index register X and subtracts the value of memory from this result, using two's complement arithmetic, and stores the result in the index register X.",
            "This instruction affects the index register X. The carry flag is set if the result is greater than or equal to 0. The carry flag is reset when the result is less than 0, indicating a borrow. The negative flag is set if the result in index register X has bit 7 on, otherwise it is reset. The Z flag is set if the result in index register X is 0, otherwise it is reset. The over­flow flag not affected at all."
          ]
        }
      },
      "SHA": {
        "category": "load",
        "flags": "--------",
        "description": "A ∧ X ∧ V → M",
        "documentation": {
          "title": "Store Accumulator \"AND\" Index Register X \"AND\" Value",
          "text": [
            "The undocumented SHA instruction performs a bit-by-bit AND operation of the following three operands: The first two are the accumulator and the index register X.",
            "The third operand depends on the addressing mode. In the zero page indirect Y-indexed case, the third operand is the data in memory at the given zero page address (ignoring the the addressing mode's Y offset) plus 1. In the Y-indexed absolute case, it is the upper 8 bits of the given address (ignoring the the addressing mode's Y offset), plus 1.",
            "It then transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SHS": {
        "category": "trans",
        "flags": "--------",
        "description": "A ∧ X → S, S ∧ (H + 1) → M",
        "documentation": {
          "title": "Transfer Accumulator \"AND\" Index Register X to Stack Pointer then Store Stack Pointer \"AND\" Hi-Byte In Memory",
          "text": [
            "The undocumented SHS instruction performs a bit-by-bit AND operation of the value of the accumulator and the value of the index register X and stores the result in the stack pointer. It then performs a bit-by-bit AND operation of the resulting stack pointer and the upper 8 bits of the given address (ignoring the addressing mode's Y offset), plus 1, and transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SHX": {
        "category": "load",
        "flags": "--------",
        "description": "X ∧ (H + 1) → M",
        "documentation": {
          "title": "Store Index Register X \"AND\" Value",
          "text": [
            "The undocumented SHX instruction performs a bit-by-bit AND operation of the index register X and the upper 8 bits of the given address (ignoring the the addressing mode's Y offset), plus 1. It then transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SHY": {
        "category": "load",
        "flags": "--------",
        "description": "Y ∧ (H + 1) → M",
        "documentation": {
          "title": "Store Index Register Y \"AND\" Value",
          "text": [
            "The undocumented SHY instruction performs a bit-by-bit AND operation of the index register Y and the upper 8 bits of the given address (ignoring the the addressing mode's X offset), plus 1. It then transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SLO": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M * 2 → M, A ∨ M → A",
        "documentation": {
          "title": "Arithmetic Shift Left then \"OR\" Memory with Accumulator",
          "text": [
            "The undocumented SLO instruction shifts the address memory location 1 bit to the left, with the bit 0 always being set to 0 and the bit 7 output always being contained in the carry flag. It then performs a bit-by-bit \"OR\" operation on the result and the accumulator and stores the result in the accumulator.",
            "The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. It sets Z flag if the result is equal to 0, otherwise resets Z and stores the input bit 7 in the carry flag."
          ]
        }
      },
      "SRE": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M / 2 → M, A ⊻ M → A",
        "documentation": {
          "title": "Logical Shift Right then \"Exclusive OR\" Memory with Accumulator",
          "text": [
            "The undocumented SRE instruction shifts the specified memory location 1 bit to the right, with the higher bit of the result always being set to 0, and the low bit which is shifted out of the field being stored in the carry flag. It then performs a bit-by-bit \"EXCLUSIVE OR\" of the result and the value of the accumulator and stores the result in the accumulator.",
            "This instruction affects the accumulator. It does not affect the overflow flag. The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. The Z flag is set if the result is 0 and reset otherwise. The carry is set equal to input bit 0."
          ]
        }
      },
      "XAA": {
        "category": "arith",
        "flags": "*-----*-",
        "description": "(A ∨ V) ∧ X ∧ M → A",
        "documentation": {
          "title": "Non-deterministic Operation of Accumulator, Index Register X, Memory and Bus Contents",
          "text": [
            "The operation of the undocumented XAA instruction depends on the individual microprocessor. On most machines, it performs a bit-by-bit AND operation of the following three operands: The first two are the index register X and memory.",
            "The third operand is the result of a bit-by-bit AND operation of the accumulator and a magic component. This magic component depends on the individual microprocessor and is usually one of $00, $EE, $EF, $FE and $FF, and may be influenced by the RDY pin, leftover contents of the data bus, the temperature of the microprocessor, the supplied voltage, and other factors.",
            "On some machines, additional bits of the result may be set or reset depending on non-deterministic factors.",
            "It then transfers the result to the accumulator.",
            "XAA does not affect the C or V flags; sets Z if the value loaded was zero, otherwise resets it; sets N if the result in bit 7 is a 1; otherwise N is reset."
          ]
        }
      },
      "BRA": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch Always",
        "documentation": {
          "title": "Branch Always",
          "text": [
            "This instruction takes an unconditional branch.",
            "BRA does not affect any of the flags or any other part of the machine other than the program counter."
          ]
        }
      },
      "PHX": {
        "category": "stack",
        "flags": "--------",
        "description": "X↓",
        "documentation": {
          "title": "Push Index Register X On Stack",
          "text": [
            "This instruction transfers the current value of the index register X to the next location on the stack, automatically decrementing the stack to point to the next empty location.",
            "The Push X instruction only affects the stack pointer register which is decremented by 1 as a result of the operation. It affects no flags."
          ]
        }
      },
      "PHY": {
        "category": "stack",
        "flags": "--------",
        "description": "Y↑",
        "documentation": {
          "title": "Push Index Register Y On Stack",
          "text": [
            "This instruction transfers the current value of the index register Y to the next location on the stack, automatically decrementing the stack to point to the next empty location.",
            "The Push Y instruction only affects the stack pointer register which is decremented by 1 as a result of the operation. It affects no flags."
          ]
        }
      },
      "PLX": {
        "category": "stack",
        "flags": "N-----Z-",
        "description": "X↑",
        "documentation": {
          "title": "Pull Index Register X From Stack",
          "text": [
            "This instruction adds 1 to the current value of the stack pointer and uses it to address the stack and loads the contents of the stack into the X register.",
            "The PLX instruction does not affect the carry or overflow flags. It sets N if the bit 7 is on in index register X as a result of instructions, otherwise it is reset. If index register X is zero as a result of the PLA, then the Z flag is set, otherwise it is reset. The PLX instruction changes content of the index register X to the contents of the memory location at stack register plus 1 and also increments the stack register."
          ]
        }
      },
      "PLY": {
        "category": "stack",
        "flags": "N-----Z-",
        "description": "Y↑",
        "documentation": {
          "title": "Pull Index Register Y From Stack",
          "text": [
            "This instruction adds 1 to the current value of the stack pointer and uses it to address the stack and loads the contents of the stack into the Y register.",
            "The PLY instruction does not affect the carry or overflow flags. It sets N if the bit 7 is on in index register Y as a result of instructions, otherwise it is reset. If index register Y is zero as a result of the PLA, then the Z flag is set, otherwise it is reset. The PLY instruction changes content of the index register Y to the contents of the memory location at stack register plus 1 and also increments the stack register."
          ]
        }
      },
      "STZ": {
        "category": "load",
        "flags": "--------",
        "description": "0 → M",
        "documentation": {
          "title": "Store Zero In Memory",
          "text": [
            "Transfers the value 0 to addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "TRB": {
        "category": "logic",
        "flags": "------Z-",
        "description": "~A ∧ M → M",
        "documentation": {
          "title": "Test And Reset Memory Bits With Accumulator",
          "text": [
            "This instruction tests and resets bits in memory, using the accumulator for both a test mask, and a reset mask. It performs a logical AND between the inverted bits of the accumulator and the bits in memory, storing the result back into memory.",
            "The zero flag is set if all bits of the result of the AND are zero, otherwise it is reset."
          ]
        }
      },
      "TSB": {
        "category": "logic",
        "flags": "------Z-",
        "description": "A ∨ M → M",
        "documentation": {
          "title": "Test And Set Memory Bits With Accumulator",
          "text": [
            "This instruction tests and sets bits in memory, using the accumulator for both a test mask, and a set mask. It performs a logical OR between the bits of the accumulator and the bits in memory, storing the result back into memory.",
            "The zero flag is set if all bits of the result of the OR are zero, otherwise it is reset."
          ]
        }
      },
      "BBR0": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M0 = 0",
        "documentation": {
          "title": "Branch on Bit 0 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 0 is clear."
          ]
        }
      },
      "BBR1": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M1 = 0",
        "documentation": {
          "title": "Branch on Bit 1 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 1 is clear."
          ]
        }
      },
      "BBR2": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M2 = 0",
        "documentation": {
          "title": "Branch on Bit 2 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 2 is clear."
          ]
        }
      },
      "BBR3": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M3 = 0",
        "documentation": {
          "title": "Branch on Bit 3 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 3 is clear."
          ]
        }
      },
      "BBR4": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M4 = 0",
        "documentation": {
          "title": "Branch on Bit 4 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 4 is clear."
          ]
        }
      },
      "BBR5": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M5 = 0",
        "documentation": {
          "title": "Branch on Bit 5 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 5 is clear."
          ]
        }
      },
      "BBR6": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M6 = 0",
        "documentation": {
          "title": "Branch on Bit 6 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 6 is clear."
          ]
        }
      },
      "BBR7": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M7 = 0",
        "documentation": {
          "title": "Branch on Bit 7 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 7 is clear."
          ]
        }
      },
      "BBS0": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M0 = 1",
        "documentation": {
          "title": "Branch on Bit 0 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 0 is set."
          ]
        }
      },
      "BBS1": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M1 = 1",
        "documentation": {
          "title": "Branch on Bit 1 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 1 is set."
          ]
        }
      },
      "BBS2": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M2 = 1",
        "documentation": {
          "title": "Branch on Bit 2 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 2 is set."
          ]
        }
      },
      "BBS3": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M3 = 1",
        "documentation": {
          "title": "Branch on Bit 3 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 3 is set."
          ]
        }
      },
      "BBS4": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M4 = 1",
        "documentation": {
          "title": "Branch on Bit 4 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 4 is set."
          ]
        }
      },
      "BBS5": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M5 = 1",
        "documentation": {
          "title": "Branch on Bit 5 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 5 is set."
          ]
        }
      },
      "BBS6": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M6 = 1",
        "documentation": {
          "title": "Branch on Bit 6 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 6 is set."
          ]
        }
      },
      "BBS7": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M7 = 1",
        "documentation": {
          "title": "Branch on Bit 7 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 7 is set."
          ]
        }
      },
      "RMB0": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M0",
        "documentation": {
          "title": "Reset Memory Bit 0",
          "text": [
            "This instruction clears bit 0 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "RMB1": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M1",
        "documentation": {
          "title": "Reset Memory Bit 1",
          "text": [
            "This instruction clears bit 1 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "RMB2": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M2",
        "documentation": {
          "title": "Reset Memory Bit 2",
          "text": [
            "This instruction clears bit 2 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "RMB3": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M3",
        "documentation": {
          "title": "Reset Memory Bit 3",
          "text": [
            "This instruction clears bit 3 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "RMB4": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M4",
        "documentation": {
          "title": "Reset Memory Bit 4",
          "text": [
            "This instruction clears bit 4 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "RMB5": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M5",
        "documentation": {
          "title": "Reset Memory Bit 5",
          "text": [
            "This instruction clears bit 5 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "RMB6": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M6",
        "documentation": {
          "title": "Reset Memory Bit 6",
          "text": [
            "This instruction clears bit 6 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "RMB7": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M7",
        "documentation": {
          "title": "Reset Memory Bit 7",
          "text": [
            "This instruction clears bit 7 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB0": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M0",
        "documentation": {
          "title": "Set Memory Bit 0",
          "text": [
            "This instruction sets bit 0 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB1": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M1",
        "documentation": {
          "title": "Set Memory Bit 1",
          "text": [
            "This instruction sets bit 1 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB2": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M2",
        "documentation": {
          "title": "Set Memory Bit 2",
          "text": [
            "This instruction sets bit 2 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB3": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M3",
        "documentation": {
          "title": "Set Memory Bit 3",
          "text": [
            "This instruction sets bit 3 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB4": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M4",
        "documentation": {
          "title": "Set Memory Bit 4",
          "text": [
            "This instruction sets bit 4 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB5": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M5",
        "documentation": {
          "title": "Set Memory Bit 5",
          "text": [
            "This instruction sets bit 5 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB6": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M6",
        "documentation": {
          "title": "Set Memory Bit 6",
          "text": [
            "This instruction sets bit 6 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB7": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M7",
        "documentation": {
          "title": "Set Memory Bit 7",
          "text": [
            "This instruction sets bit 7 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "STP": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Stop the Clock",
        "documentation": {
          "title": "Stop the Clock",
          "text": [
            "The processor halts until a hardware reset is applied. Power-supply current drops to nearly zero."
          ]
        }
      },
      "WAI": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Wait for Interrupt",
        "documentation": {
          "title": "Wait for Interrupt",
          "text": [
            "The processor pauses at the current location until the next interrupt occurs. This allows for zero latency interrupt response."
          ]
        }
      }
    },
    "mnemos": {
      "ADC": {
        "description": "Add with Carry"
      },
      "AND": {
        "description": "Logical AND"
      },
      "ASL": {
        "description": "Arithmetic Shift Left"
      },
      "BCC": {
        "description": "Branch if Carry Clear"
      },
      "BCS": {
        "description": "Branch if Carry Set"
      },
      "BEQ": {
        "description": "Branch if Equal"
      },
      "BIT": {
        "description": "Bit Test"
      },
      "BMI": {
        "description": "Branch if Minus"
      },
      "BNE": {
        "description": "Branch if Not Equal"
      },
      "BPL": {
        "description": "Branch if Plus"
      },
      "BRK": {
        "description": "Force Interrupt"
      },
      "BVC": {
        "description": "Branch if Overflow Clear"
      },
      "BVS": {
        "description": "Branch if Overflow Set"
      },
      "CLC": {
        "description": "Clear Carry Flag"
      },
      "CLD": {
        "description": "Clear Decimal Mode"
      },
      "CLI": {
        "description": "Clear Interrupt Disable"
      },
      "CLV": {
        "description": "Clear Overflow Flag"
      },
      "CMP": {
        "description": "Compare"
      },
      "CPX": {
        "description": "Compare X Register"
      },
      "CPY": {
        "description": "Compare Y Register"
      },
      "DEC": {
        "description": "Decrement Memory"
      },
      "DEX": {
        "description": "Decrement X Register"
      },
      "DEY": {
        "description": "Decrement Y Register"
      },
      "EOR": {
        "description": "Exclusive OR"
      },
      "INC": {
        "description": "Increment Memory"
      },
      "INX": {
        "description": "Increment X Register"
      },
      "INY": {
        "description": "Increment Y Register"
      },
      "JMP": {
        "description": "Jump"
      },
      "JSR": {
        "description": "Jump to Subroutine"
      },
      "LDA": {
        "description": "Load Accumulator"
      },
      "LDX": {
        "description": "Load X Register"
      },
      "LDY": {
        "description": "Load Y Register"
      },
      "LSR": {
        "description": "Logical Shift Right"
      },
      "NOP": {
        "description": "No Operation"
      },
      "ORA": {
        "description": "Logical OR"
      },
      "PHA": {
        "description": "Push Accumulator"
      },
      "PHP": {
        "description": "Push Processor Status"
      },
      "PLA": {
        "description": "Pull Accumulator"
      },
      "PLP": {
        "description": "Pull Processor Status"
      },
      "ROL": {
        "description": "Rotate Left"
      },
      "ROR": {
        "description": "Rotate Right"
      },
      "RTI": {
        "description": "Return from Interrupt"
      },
      "RTS": {
        "description": "Return from Subroutine"
      },
      "SBC": {
        "description": "Subtract with Carry"
      },
      "SEC": {
        "description": "Set Carry Flag"
      },
      "SED": {
        "description": "Set Decimal Flag"
      },
      "SEI": {
        "description": "Set Interrupt Disable"
      },
      "STA": {
        "description": "Store Accumulator"
      },
      "STX": {
        "description": "Store X Register"
      },
      "STY": {
        "description": "Store Y Register"
      },
      "TAX": {
        "description": "Transfer Accumulator to X"
      },
      "TAY": {
        "description": "Transfer Accumulator to Y"
      },
      "TSX": {
        "description": "Transfer Stack Pointer to X"
      },
      "TXA": {
        "description": "Transfer X to Accumulator"
      },
      "TXS": {
        "description": "Transfer X to Stack Pointer"
      },
      "TYA": {
        "description": "Transfer Y to Accumulator"
      },
      "BRA": {
        "description": "Branch Always"
      },
      "PHX": {
        "description": "Push X Register"
      },
      "PHY": {
        "description": "Push Y Register"
      },
      "PLX": {
        "description": "Pull X Register"
      },
      "PLY": {
        "description": "Pull Y Register"
      },
      "STZ": {
        "description": "Store Zero"
      },
      "TRB": {
        "description": "Test and Reset Memory Bits"
      },
      "TSB": {
        "description": "Test and Set Memory Bits"
      },
      "BBR0": {
        "description": "Branch on Bit 0 Reset"
      },
      "BBR1": {
        "description": "Branch on Bit 1 Reset"
      },
      "BBR2": {
        "description": "Branch on Bit 2 Reset"
      },
      "BBR3": {
        "description": "Branch on Bit 3 Reset"
      },
      "BBR4": {
        "description": "Branch on Bit 4 Reset"
      },
      "BBR5": {
        "description": "Branch on Bit 5 Reset"
      },
      "BBR6": {
        "description": "Branch on Bit 6 Reset"
      },
      "BBR7": {
        "description": "Branch on Bit 7 Reset"
      },
      "BBS0": {
        "description": "Branch on Bit 0 Set"
      },
      "BBS1": {
        "description": "Branch on Bit 1 Set"
      },
      "BBS2": {
        "description": "Branch on Bit 2 Set"
      },
      "BBS3": {
        "description": "Branch on Bit 3 Set"
      },
      "BBS4": {
        "description": "Branch on Bit 4 Set"
      },
      "BBS5": {
        "description": "Branch on Bit 5 Set"
      },
      "BBS6": {
        "description": "Branch on Bit 6 Set"
      },
      "BBS7": {
        "description": "Branch on Bit 7 Set"
      },
      "RMB0": {
        "description": "Reset Memory Bit 0"
      },
      "RMB1": {
        "description": "Reset Memory Bit 1"
      },
      "RMB2": {
        "description": "Reset Memory Bit 2"
      },
      "RMB3": {
        "description": "Reset Memory Bit 3"
      },
      "RMB4": {
        "description": "Reset Memory Bit 4"
      },
      "RMB5": {
        "description": "Reset Memory Bit 5"
      },
      "RMB6": {
        "description": "Reset Memory Bit 6"
      },
      "RMB7": {
        "description": "Reset Memory Bit 7"
      },
      "SMB0": {
        "description": "Set Memory Bit 0"
      },
      "SMB1": {
        "description": "Set Memory Bit 1"
      },
      "SMB2": {
        "description": "Set Memory Bit 2"
      },
      "SMB3": {
        "description": "Set Memory Bit 3"
      },
      "SMB4": {
        "description": "Set Memory Bit 4"
      },
      "SMB5": {
        "description": "Set Memory Bit 5"
      },
      "SMB6": {
        "description": "Set Memory Bit 6"
      },
      "SMB7": {
        "description": "Set Memory Bit 7"
      },
      "STP": {
        "description": "Stop the Clock"
      },
      "WAI": {
        "description": "Wait for Interrupt"
      }
    },
    "addmodes": {
      "-": {
        "bytes": "1",
        "syntax": "",
        "description": "Implied",
        "documentation": {
          "title": "Implied",
          "text": [
            "In the implied addressing mode, the address containing the operand is implicitly stated in the operation code of the instruction."
          ]
        }
      },
      "A": {
        "bytes": "1",
        "syntax": "A",
        "description": "Accumulator",
        "documentation": {
          "title": "Accumulator",
          "text": [
            "This form of addressing is represented with a one byte instruction, implying an operation on the accumulator."
          ]
        }
      },
      "#d8": {
        "bytes": "2",
        "syntax": "#$nn",
        "description": "Immediate",
        "documentation": {
          "title": "Immediate",
          "text": [
            "In immediate addressing, the operand is contained in the second byte of the instruction, with no further memory addressing required."
          ]
        }
      },
      "a8": {
        "bytes": "2",
        "syntax": "$nn",
        "description": "Zero Page",
        "documentation": {
          "title": "Zero Page",
          "text": [
            "The zero page instructions allow for shorter code and execution times by only fetching the second byte of the instruction and assuming a zero high address byte. Careful use of the zero page can result in significant increase in code efficiency."
          ]
        }
      },
      "a8,X": {
        "bytes": "2",
        "syntax": "$nn,X",
        "description": "X-Indexed Zero Page",
        "documentation": {
          "title": "X-Indexed Zero Page",
          "text": [
            "This form of addressing is used in conjunction with the X index register. The effective address is calculated by adding the second byte to the contents of the index register. Since this is a form of \"Zero Page\" addressing, the content of the second byte references a location in page zero. Additionally, due to the “Zero Page\" addressing nature of this mode, no carry is added to the high order 8 bits of memory and crossing of page boundaries does not occur."
          ]
        }
      },
      "a8,Y": {
        "bytes": "2",
        "syntax": "$nn,Y",
        "description": "Y-Indexed Zero Page",
        "documentation": {
          "title": "Y-Indexed Zero Page",
          "text": [
            "This form of addressing is used in conjunction with the Y index register. The effective address is calculated by adding the second byte to the contents of the index register. Since this is a form of \"Zero Page\" addressing, the content of the second byte references a location in page zero. Additionally, due to the “Zero Page\" addressing nature of this mode, no carry is added to the high order 8 bits of memory and crossing of page boundaries does not occur."
          ]
        }
      },
      "(a8,X)": {
        "bytes": "2",
        "syntax": "($nn,X)",
        "description": "X-Indexed Zero Page Indirect",
        "documentation": {
          "title": "X-Indexed Zero Page Indirect",
          "text": [
            "In indexed indirect addressing, the second byte of the instruction is added to the contents of the X index register, discarding the carry. The result of this addition points to a memory location on page zero whose contents is the low order eight bits of the effective address. The next memory location in page zero contains the high order eight bits of the effective address. Both memory locations specifying the high and low order bytes of the effective address must be in page zero."
          ]
        }
      },
      "(a8),Y": {
        "bytes": "2",
        "syntax": "($nn),Y",
        "description": "Zero Page Indirect Y-Indexed",
        "documentation": {
          "title": "Zero Page Indirect Y-Indexed",
          "text": [
            "In indirect indexed addressing, the second byte of the instruction points to a memory location in page zero. The contents of this memory location is added to the contents of the Y index register, the result being the low order eight bits of the effective address. The carry from this addition is added to the contents of the next page zero memory location, the result being the high order eight bits of the effective address."
          ]
        }
      },
      "a16": {
        "bytes": "3",
        "syntax": "$nnnn",
        "description": "Absolute",
        "documentation": {
          "title": "Absolute",
          "text": [
            "In absolute addressing, the second byte of the instruction specifies the eight low order bits of the effective address while the third byte specifies the eight high order bits. Thus, the absolute addressing mode allows access to the entire 65 K bytes of addressable memory."
          ]
        }
      },
      "a16,X": {
        "bytes": "3",
        "syntax": "$nnnn,X",
        "description": "X-Indexed Absolute",
        "documentation": {
          "title": "X-Indexed Absolute",
          "text": [
            "This form of addressing is used in conjunction with the X index register. The effective address is formed by adding the contents of X to the address contained in the second and third bytes of the instruction. This mode allows the index register to contain the index or count value and the instruction to contain the base address. This type of indexing allows any location referencing and the index to modify multiple fields resulting in reduced coding and execution time."
          ]
        }
      },
      "a16,Y": {
        "bytes": "3",
        "syntax": "$nnnn,Y",
        "description": "Y-Indexed Absolute",
        "documentation": {
          "title": "Y-Indexed Absolute",
          "text": [
            "This form of addressing is used in conjunction with the Y index register. The effective address is formed by adding the contents of Y to the address contained in the second and third bytes of the instruction. This mode allows the index register to contain the index or count value and the instruction to contain the base address. This type of indexing allows any location referencing and the index to modify multiple fields resulting in reduced coding and execution time."
          ]
        }
      },
      "(a16)": {
        "bytes": "3",
        "syntax": "($nnnn)",
        "description": "Absolute Indirect",
        "documentation": {
          "title": "Absolute Indirect",
          "text": [
            "The second byte of the instruction contains the low order eight bits of a memory location. The high order eight bits of that memory location is contained in the third byte of the instruction. The contents of the fully specified memory location is the low order byte of the effective address. The next memory location contains the high order byte of the effective address which is loaded into the sixteen bits of the program counter."
          ]
        }
      },
      "r8": {
        "bytes": "2",
        "syntax": "$nnnn",
        "description": "Relative",
        "documentation": {
          "title": "Relative",
          "text": [
            "Relative addressing is used only with branch instructions and establishes a destination for the conditional branch.",
            "The second byte of-the instruction becomes the operand which is an “Offset\" added to the contents of the lower eight bits of the program counter when the counter is set at the next instruction. The range of the offset is —128 to +127 bytes from the next instruction."
          ]
        }
      },
      "(a8)": {
        "bytes": "2",
        "syntax": "($nn)",
        "description": "Zero Page Indirect",
        "documentation": {
          "title": "Zero Page Indirect",
          "text": [
            "With Zero Page Indirect addressing mode, the second byte of the instruction is a zero page indirect address that points to the low byte of a two byte effective address."
          ]
        }
      },
      "(a16,X)": {
        "bytes": "3",
        "syntax": "($nnnn,X)",
        "description": "Absolute X-Indexed Indirect",
        "documentation": {
          "title": "Absolute X-Indexed Indirect",
          "text": [
            "With the Absolute Indexed Indirect addressing mode, the X Index Register is added to the second and third byes of the instruction to form an address to a pointer. This address mode is only used with the JMP instruction and the program Counter is loaded with the first and second bytes at this pointer."
          ]
        }
      },
      "a8,r8": {
        "bytes": "3",
        "syntax": "$nn,$nnnn",
        "description": "Zero Page, Relative",
        "documentation": {
          "title": "Zero Page, Relative",
          "text": [
            "This mode is used only with the bit-test branch instructions (BBS and BCC). The second byte of the instruction specifies the zero page memory to be tested. The third byte of the instruction is the offset, whose range is -128 to 127 bytes, referenced to the location of the next instruction."
          ]
        }
      }
    },
    "all_mnemos": {
      "regular": [
        "ADC",
        "AND",
        "ASL",
        "BBR0",
        "BBR1",
        "BBR2",
        "BBR3",
        "BBR4",
        "BBR5",
        "BBR6",
        "BBR7",
        "BBS0",
        "BBS1",
        "BBS2",
        "BBS3",
        "BBS4",
        "BBS5",
        "BBS6",
        "BBS7",
        "BCC",
        "BCS",
        "BEQ",
        "BIT",
        "BMI",
        "BNE",
        "BPL",
        "BRA",
        "BRK",
        "BVC",
        "BVS",
        "CLC",
        "CLD",
        "CLI",
        "CLV",
        "CMP",
        "CPX",
        "CPY",
        "DEC",
        "DEX",
        "DEY",
        "EOR",
        "INC",
        "INX",
        "INY",
        "JMP",
        "JSR",
        "LDA",
        "LDX",
        "LDY",
        "LSR",
        "NOP",
        "ORA",
        "PHA",
        "PHP",
        "PHX",
        "PHY",
        "PLA",
        "PLP",
        "PLX",
        "PLY",
        "RMB0",
        "RMB1",
        "RMB2",
        "RMB3",
        "RMB4",
        "RMB5",
        "RMB6",
        "RMB7",
        "ROL",
        "ROR",
        "RTI",
        "RTS",
        "SBC",
        "SEC",
        "SED",
        "SEI",
        "SMB0",
        "SMB1",
        "SMB2",
        "SMB3",
        "SMB4",
        "SMB5",
        "SMB6",
        "SMB7",
        "STA",
        "STP",
        "STX",
        "STY",
        "STZ",
        "TAX",
        "TAY",
        "TRB",
        "TSB",
        "TSX",
        "TXA",
        "TXS",
        "TYA",
        "WAI"
      ],
      "illegal": [
        "NOP"
      ],
      "all": [
        "ADC",
        "AND",
        "ASL",
        "BBR0",
        "BBR1",
        "BBR2",
        "BBR3",
        "BBR4",
        "BBR5",
        "BBR6",
        "BBR7",
        "BBS0",
        "BBS1",
        "BBS2",
        "BBS3",
        "BBS4",
        "BBS5",
        "BBS6",
        "BBS7",
        "BCC",
        "BCS",
        "BEQ",
        "BIT",
        "BMI",
        "BNE",
        "BPL",
        "BRA",
        "BRK",
        "BVC",
        "BVS",
        "CLC",
        "CLD",
        "CLI",
        "CLV",
        "CMP",
        "CPX",
        "CPY",
        "DEC",
        "DEX",
        "DEY",
        "EOR",
        "INC",
        "INX",
        "INY",
        "JMP",
        "JSR",
        "LDA",
        "LDX",
        "LDY",
        "LSR",
        "NOP",
        "ORA",
        "PHA",
        "PHP",
        "PHX",
        "PHY",
        "PLA",
        "PLP",
        "PLX",
        "PLY",
        "RMB0",
        "RMB1",
        "RMB2",
        "RMB3",
        "RMB4",
        "RMB5",
        "RMB6",
        "RMB7",
        "ROL",
        "ROR",
        "RTI",
        "RTS",
        "SBC",
        "SEC",
        "SED",
        "SEI",
        "SMB0",
        "SMB1",
        "SMB2",
        "SMB3",
        "SMB4",
        "SMB5",
        "SMB6",
        "SMB7",
        "STA",
        "STP",
        "STX",
        "STY",
        "STZ",
        "TAX",
        "TAY",
        "TRB",
        "TSB",
        "TSX",
        "TXA",
        "TXS",
        "TYA",
        "WAI"
      ]
    },
    "all_addmodes": {
      "regular": [
        "-",
        "A",
        "#d8",
        "a16",
        "a16,X",
        "a16,Y",
        "(a16)",
        "(a16,X)",
        "a8",
        "a8,X",
        "a8,Y",
        "(a8)",
        "(a8,X)",
        "(a8),Y",
        "r8",
        "a8,r8"
      ],
      "illegal": [
        "-",
        "#d8"
      ],
      "all": [
        "-",
        "A",
        "#d8",
        "a16",
        "a16,X",
        "a16,Y",
        "(a16)",
        "(a16,X)",
        "a8",
        "a8,X",
        "a8,Y",
        "(a8)",
        "(a8,X)",
        "(a8),Y",
        "r8",
        "a8,r8"
      ]
    }
  },
  "65ce02": {
    "info": {
      "manufacturer": "CSG",
      "name": "65CE02",
      "year": "1988",
      "id": "65ce02",
      "basedon": "r65c02",
      "description": "This is the CMOS-based reimplementation of the 6502 designed by Bill Gardei at Commodore/CSG/MOS. It supports all instructions of the Rockwell 65C02, and adds index register Z as well as support for a relocatable zero page, a 16 bit stack pointer and stack-relative addressing, filling all 256 opcodes."
    },
    "registers": {
      "registers": [
        "A",
        "X",
        "Y",
        "Z",
        "S",
        "P",
        "B",
        "PC"
      ],
      "A": {
        "size": "8",
        "description": "Accumulator"
      },
      "X": {
        "size": "8",
        "description": "X Index Register"
      },
      "Y": {
        "size": "8",
        "description": "Y Index Register"
      },
      "S": {
        "size": "16",
        "description": "Stack Pointer"
      },
      "P": {
        "size": "8",
        "description": "Processor Status"
      },
      "PC": {
        "size": "16",
        "description": "Program Counter"
      },
      "Z": {
        "size": "8",
        "description": "Z Index Register"
      },
      "B": {
        "size": "8",
        "description": "Base Page Register"
      }
    },
    "vectors": {
      "FFFA": "NMI",
      "FFFC": "RESET",
      "FFFE": "IRQ"
    },
    "flags": {
      "names": "NVEBDIZC",
      "N": "Negative",
      "V": "Overflow",
      "E": "Extended Stack Disable",
      "B": "Break Command",
      "D": "Decimal",
      "I": "Interrupt Disable",
      "Z": "Zero",
      "C": "Carry"
    },
    "opcodes": [
      {
        "illegal": false,
        "mnemo": "BRK",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8,X)",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLE",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SEE",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TSB",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB0",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "A",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TSY",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TSB",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR0",
        "addmode": "a8,r8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BPL",
        "addmode": "r8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8),Y",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8),Z",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BPL",
        "addmode": "r16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TRB",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a8,X",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a8,X",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB1",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLC",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16,Y",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "A",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INZ",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TRB",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a16,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR1",
        "addmode": "a8,r8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JSR",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8,X)",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JSR",
        "addmode": "(a16)",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JSR",
        "addmode": "(a16,X)",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB2",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PLP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "A",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TYS",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR2",
        "addmode": "a8,r8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BMI",
        "addmode": "r8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8),Y",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8),Z",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BMI",
        "addmode": "r16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a8,X",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a8,X",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a8,X",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB3",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SEC",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16,Y",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "A",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEZ",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a16,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a16,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR3",
        "addmode": "a8,r8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RTI",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8,X)",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "NEG",
        "addmode": "A",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASR",
        "addmode": "A",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASR",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB4",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHA",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "A",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TAZ",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR4",
        "addmode": "a8,r8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BVC",
        "addmode": "r8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8),Y",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8),Z",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BVC",
        "addmode": "r16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASR",
        "addmode": "a8,X",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a8,X",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a8,X",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB5",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLI",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16,Y",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHY",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TAB",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AUG",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a16,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR5",
        "addmode": "a8,r8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RTS",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8,X)",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RTN",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BSR",
        "addmode": "r16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STZ",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB6",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PLA",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "A",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TZA",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "(a16)",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR6",
        "addmode": "a8,r8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BVS",
        "addmode": "r8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8),Y",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8),Z",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BVS",
        "addmode": "r16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STZ",
        "addmode": "a8,X",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a8,X",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a8,X",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RMB7",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SEI",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16,Y",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PLY",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TBA",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "(a16,X)",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a16,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBR7",
        "addmode": "a8,r8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BRA",
        "addmode": "r8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8,X)",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8,S),Y",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BRA",
        "addmode": "r16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB0",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEY",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TXA",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a16,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS0",
        "addmode": "a8,r8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BCC",
        "addmode": "r8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8),Y",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8),Z",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BCC",
        "addmode": "r16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a8,X",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a8,X",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a8,Y",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB1",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TYA",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16,Y",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TXS",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a16,Y",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STZ",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STZ",
        "addmode": "a16,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS1",
        "addmode": "a8,r8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8,X)",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDZ",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB2",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TAY",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TAX",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDZ",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS2",
        "addmode": "a8,r8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BCS",
        "addmode": "r8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8),Y",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8),Z",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BCS",
        "addmode": "r16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a8,X",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a8,X",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a8,Y",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB3",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLV",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16,Y",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TSX",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDZ",
        "addmode": "a16,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a16,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a16,Y",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS3",
        "addmode": "a8,r8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8,X)",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPZ",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEW",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB4",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INY",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEX",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ASW",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS4",
        "addmode": "a8,r8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BNE",
        "addmode": "r8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8),Y",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8),Z",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BNE",
        "addmode": "r16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPZ",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a8,X",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a8,X",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB5",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CLD",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16,Y",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHX",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHZ",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPZ",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a16,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS5",
        "addmode": "a8,r8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8,X)",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8,S),Y",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INW",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB6",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INX",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ROW",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS6",
        "addmode": "a8,r8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BEQ",
        "addmode": "r8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8),Y",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8),Z",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BEQ",
        "addmode": "r16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHW",
        "addmode": "#d16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a8,X",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a8,X",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SMB7",
        "addmode": "a8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SED",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16,Y",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PLX",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PLZ",
        "addmode": "-",
        "cycles": "1",
        "mincycles": 1,
        "maxcycles": 1,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHW",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a16,X",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BBS7",
        "addmode": "a8,r8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      }
    ],
    "operations": {
      "ADC": {
        "category": "arith",
        "flags": "NV----ZC",
        "description": "A + M + C → A, C",
        "documentation": {
          "title": "Add Memory to Accumulator with Carry",
          "text": [
            "This instruction adds the value of memory and carry from the previous operation to the value of the accumulator and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the carry flag when the sum of a binary add exceeds 255 or when the sum of a decimal add exceeds 99, otherwise carry is reset. The overflow flag is set when the sign or bit 7 is changed due to the result exceeding +127 or -128, otherwise overflow is reset. The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. The zero flag is set if the accumulator result is 0, otherwise the zero flag is reset."
          ]
        }
      },
      "AND": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ∧ M → A",
        "documentation": {
          "title": "\"AND\" Memory with Accumulator",
          "text": [
            "The AND instruction transfer the accumulator and memory to the adder which performs a bit-by-bit AND operation and stores the result back in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "ASL": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C ← /M7...M0/ ← 0",
        "documentation": {
          "title": "Arithmetic Shift Left",
          "text": [
            "The shift left instruction shifts either the accumulator or the address memory location 1 bit to the left, with the bit 0 always being set to 0 and the the input bit 7 being stored in the carry flag. ASL either shifts the accumulator left 1 bit or is a read/modify/write instruction that affects only memory.",
            "The instruction does not affect the overflow bit, sets N equal to the result bit 7 (bit 6 in the input), sets Z flag if the result is equal to 0, otherwise resets Z and stores the input bit 7 in the carry flag."
          ]
        }
      },
      "BCC": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on C = 0",
        "documentation": {
          "title": "Branch on Carry Clear",
          "text": [
            "This instruction tests the state of the carry bit and takes a conditional branch if the carry bit is reset.",
            "It affects no flags or registers other than the program counter and then only if the C flag is not on."
          ]
        }
      },
      "BCS": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on C = 1",
        "documentation": {
          "title": "Branch on Carry Set",
          "text": [
            "This instruction takes the conditional branch if the carry flag is on.",
            "BCS does not affect any of the flags or registers except for the program counter and only then if the carry flag is on."
          ]
        }
      },
      "BEQ": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on Z = 1",
        "documentation": {
          "title": "Branch on Result Zero",
          "text": [
            "This instruction could also be called \"Branch on Equal.\"",
            "It takes a conditional branch whenever the Z flag is on or the previ­ ous result is equal to 0.",
            "BEQ does not affect any of the flags or registers other than the program counter and only then when the Z flag is set."
          ]
        }
      },
      "BIT": {
        "category": "logic",
        "flags": "NV----Z-",
        "description": "A ∧ M, M7 → N, M6 → V",
        "documentation": {
          "title": "Test Bits in Memory with Accumulator",
          "text": [
            "This instruction performs an AND between a memory location and the accumulator but does not store the result of the AND into the accumulator.",
            "The bit instruction affects the N flag with N being set to the value of bit 7 of the memory being tested, the V flag with V being set equal to bit 6 of the memory being tested and Z being set by the result of the AND operation between the accumulator and the memory if the result is Zero, Z is reset otherwise. It does not affect the accumulator."
          ]
        }
      },
      "BMI": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on N = 1",
        "documentation": {
          "title": "Branch on Result Minus",
          "text": [
            "This instruction takes the conditional branch if the N bit is set.",
            "BMI does not affect any of the flags or any other part of the machine other than the program counter and then only if the N bit is on."
          ]
        }
      },
      "BNE": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on Z = 0",
        "documentation": {
          "title": "Branch on Result Not Zero",
          "text": [
            "This instruction could also be called \"Branch on Not Equal.\" It tests the Z flag and takes the conditional branch if the Z flag is not on, indicating that the previous result was not zero.",
            "BNE does not affect any of the flags or registers other than the program counter and only then if the Z flag is reset."
          ]
        }
      },
      "BPL": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on N = 0",
        "documentation": {
          "title": "Branch on Result Plus",
          "text": [
            "This instruction is the complementary branch to branch on result minus. It is a conditional branch which takes the branch when the N bit is reset (0). BPL is used to test if the previous result bit 7 was off (0) and branch on result minus is used to determine if the previous result was minus or bit 7 was on (1).",
            "The instruction affects no flags or other registers other than the P counter and only affects the P counter when the N bit is reset."
          ]
        }
      },
      "BRK": {
        "category": "ctrl",
        "flags": "-----1--",
        "description": "PC + 2↓, [FFFE] → PCL, [FFFF] → PCH",
        "documentation": {
          "title": "Break Command",
          "text": [
            "The break command causes the microprocessor to go through an inter­ rupt sequence under program control. This means that the program counter of the second byte after the BRK. is automatically stored on the stack along with the processor status at the beginning of the break instruction. The microprocessor then transfers control to the interrupt vector.",
            "Other than changing the program counter, the break instruction changes no values in either the registers or the flags."
          ]
        }
      },
      "BVC": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on V = 0",
        "documentation": {
          "title": "Branch on Overflow Clear",
          "text": [
            "This instruction tests the status of the V flag and takes the conditional branch if the flag is not set.",
            "BVC does not affect any of the flags and registers other than the program counter and only when the overflow flag is reset."
          ]
        }
      },
      "BVS": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on V = 1",
        "documentation": {
          "title": "Branch on Overflow Set",
          "text": [
            "This instruction tests the V flag and takes the conditional branch if V is on.",
            "BVS does not affect any flags or registers other than the program, counter and only when the overflow flag is set."
          ]
        }
      },
      "CLC": {
        "category": "flags",
        "flags": "-------0",
        "description": "0 → C",
        "documentation": {
          "title": "Clear Carry Flag",
          "text": [
            "This instruction initializes the carry flag to a 0. This op­ eration should normally precede an ADC loop. It is also useful when used with a R0L instruction to clear a bit in memory.",
            "This instruction affects no registers in the microprocessor and no flags other than the carry flag which is reset."
          ]
        }
      },
      "CLD": {
        "category": "flags",
        "flags": "----0---",
        "description": "0 → D",
        "documentation": {
          "title": "Clear Decimal Mode",
          "text": [
            "This instruction sets the decimal mode flag to a 0. This all subsequent ADC and SBC instructions to operate as simple operations.",
            "CLD affects no registers in the microprocessor and no flags other than the decimal mode flag which is set to a 0."
          ]
        }
      },
      "CLI": {
        "category": "flags",
        "flags": "-----0--",
        "description": "0 → I",
        "documentation": {
          "title": "Clear Interrupt Disable",
          "text": [
            "This instruction initializes the interrupt disable to a 0. This allows the microprocessor to receive interrupts.",
            "It affects no registers in the microprocessor and no flags other than the interrupt disable which is cleared."
          ]
        }
      },
      "CLV": {
        "category": "flags",
        "flags": "-0------",
        "description": "0 → V",
        "documentation": {
          "title": "Clear Overflow Flag",
          "text": [
            "This instruction clears the overflow flag to a 0. This com­ mand is used in conjunction with the set overflow pin which can change the state of the overflow flag with an external signal.",
            "CLV affects no registers in the microprocessor and no flags other than the overflow flag which is set to a 0."
          ]
        }
      },
      "CMP": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "A - M",
        "documentation": {
          "title": "Compare Memory and Accumulator",
          "text": [
            "This instruction subtracts the contents of memory from the contents of the accumulator.",
            "The use of the CMP affects the following flags: Z flag is set on an equal comparison, reset otherwise; the N flag is set or reset by the result bit 7, the carry flag is set when the value in memory is less than or equal to the accumulator, reset when it is greater than the accumulator. The accumulator is not affected."
          ]
        }
      },
      "CPX": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "X - M",
        "documentation": {
          "title": "Compare Index Register X To Memory",
          "text": [
            "This instruction subtracts the value of the addressed memory location from the content of index register X using the adder but does not store the result; therefore, its only use is to set the N, Z and C flags to allow for comparison between the index register X and the value in memory.",
            "The CPX instruction does not affect any register in the machine; it also does not affect the overflow flag. It causes the carry to be set on if the absolute value of the index register X is equal to or greater than the data from memory. If the value of the memory is greater than the content of the index register X, carry is reset. If the results of the subtraction contain a bit 7, then the N flag is set, if not, it is reset. If the value in memory is equal to the value in index register X, the Z flag is set, otherwise it is reset."
          ]
        }
      },
      "CPY": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "Y - M",
        "documentation": {
          "title": "Compare Index Register Y To Memory",
          "text": [
            "This instruction performs a two's complement subtraction between the index register Y and the specified memory location. The results of the subtraction are not stored anywhere. The instruction is strict­ly used to set the flags.",
            "CPY affects no registers in the microprocessor and also does not affect the overflow flag. If the value in the index register Y is equal to or greater than the value in the memory, the carry flag will be set, otherwise it will be cleared. If the results of the subtract- tion contain bit 7 on the N bit will be set, otherwise it will be cleared. If the value in the index register Y and the value in the memory are equal, the zero flag will be set, otherwise it will be cleared."
          ]
        }
      },
      "DEC": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "M - 1 → M",
        "documentation": {
          "title": "Decrement Memory By One",
          "text": [
            "This instruction subtracts 1, in two's complement, from the contents of the addressed memory location.",
            "The decrement instruction does not affect any internal register in the microprocessor. It does not affect the carry or overflow flags. If bit 7 is on as a result of the decrement, then the N flag is set, otherwise it is reset. If the result of the decrement is 0, the Z flag is set, other­wise it is reset."
          ]
        }
      },
      "DEX": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "X - 1 → X",
        "documentation": {
          "title": "Decrement Index Register X By One",
          "text": [
            "This instruction subtracts one from the current value of the index register X and stores the result in the index register X.",
            "DEX does not affect the carry or overflow flag, it sets the N flag if it has bit 7 on as a result of the decrement, otherwise it resets the N flag; sets the Z flag if X is a 0 as a result of the decrement, otherwise it resets the Z flag."
          ]
        }
      },
      "DEY": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "Y - 1 → Y",
        "documentation": {
          "title": "Decrement Index Register Y By One",
          "text": [
            "This instruction subtracts one from the current value in the in­ dex register Y and stores the result into the index register Y. The result does not affect or consider carry so that the value in the index register Y is decremented to 0 and then through 0 to FF.",
            "Decrement Y does not affect the carry or overflow flags; if the Y register contains bit 7 on as a result of the decrement the N flag is set, otherwise the N flag is reset. If the Y register is 0 as a result of the decrement, the Z flag is set otherwise the Z flag is reset. This instruction only affects the index register Y."
          ]
        }
      },
      "EOR": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ⊻ M → A",
        "documentation": {
          "title": "\"Exclusive OR\" Memory with Accumulator",
          "text": [
            "The EOR instruction transfers the memory and the accumulator to the adder which performs a binary \"EXCLUSIVE OR\" on a bit-by-bit basis and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "INC": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "M + 1 → M",
        "documentation": {
          "title": "Increment Memory By One",
          "text": [
            "This instruction adds 1 to the contents of the addressed memory loca­tion.",
            "The increment memory instruction does not affect any internal registers and does not affect the carry or overflow flags. If bit 7 is on as the result of the increment,N is set, otherwise it is reset; if the increment causes the result to become 0, the Z flag is set on, otherwise it is reset."
          ]
        }
      },
      "INX": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "X + 1 → X",
        "documentation": {
          "title": "Increment Index Register X By One",
          "text": [
            "Increment X adds 1 to the current value of the X register. This is an 8-bit increment which does not affect the carry operation, therefore, if the value of X before the increment was FF, the resulting value is 00.",
            "INX does not affect the carry or overflow flags; it sets the N flag if the result of the increment has a one in bit 7, otherwise resets N; sets the Z flag if the result of the increment is 0, otherwise it resets the Z flag.",
            "INX does not affect any other register other than the X register."
          ]
        }
      },
      "INY": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "Y + 1 → Y",
        "documentation": {
          "title": "Increment Index Register Y By One",
          "text": [
            "Increment Y increments or adds one to the current value in the Y register, storing the result in the Y register. As in the case of INX the primary application is to step thru a set of values using the Y register.",
            "The INY does not affect the carry or overflow flags, sets the N flag if the result of the increment has a one in bit 7, otherwise resets N, sets Z if as a result of the increment the Y register is zero otherwise resets the Z flag."
          ]
        }
      },
      "JMP": {
        "category": "ctrl",
        "flags": "--------",
        "description": "[PC + 1] → PCL, [PC + 2] → PCH",
        "documentation": {
          "title": "JMP Indirect",
          "text": [
            "This instruction establishes a new valne for the program counter.",
            "It affects only the program counter in the microprocessor and affects no flags in the status register."
          ]
        }
      },
      "JSR": {
        "category": "ctrl",
        "flags": "--------",
        "description": "PC + 2↓, [PC + 1] → PCL, [PC + 2] → PCH",
        "documentation": {
          "title": "Jump To Subroutine",
          "text": [
            "This instruction transfers control of the program counter to a subroutine location but leaves a return pointer on the stack to allow the user to return to perform the next instruction in the main program after the subroutine is complete. To accomplish this, JSR instruction stores the program counter address which points to the last byte of the jump instruc­ tion onto the stack using the stack pointer. The stack byte contains the program count high first, followed by program count low. The JSR then transfers the addresses following the jump instruction to the program counter low and the program counter high, thereby directing the program to begin at that new address.",
            "The JSR instruction affects no flags, causes the stack pointer to be decremented by 2 and substitutes new values into the program counter low and the program counter high."
          ]
        }
      },
      "LDA": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → A",
        "documentation": {
          "title": "Load Accumulator with Memory",
          "text": [
            "When instruction LDA is executed by the microprocessor, data is transferred from memory to the accumulator and stored in the accumulator.",
            "LDA affects the contents of the accumulator, does not affect the carry or overflow flags; sets the zero flag if the accumulator is zero as a result of the LDA, otherwise resets the zero flag; sets the negative flag if bit 7 of the accumulator is a 1, other­ wise resets the negative flag."
          ]
        }
      },
      "LDX": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → X",
        "documentation": {
          "title": "Load Index Register X From Memory",
          "text": [
            "Load the index register X from memory.",
            "LDX does not affect the C or V flags; sets Z if the value loaded was zero, otherwise resets it; sets N if the value loaded in bit 7 is a 1; otherwise N is reset, and affects only the X register."
          ]
        }
      },
      "LDY": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → Y",
        "documentation": {
          "title": "Load Index Register Y From Memory",
          "text": [
            "Load the index register Y from memory.",
            "LDY does not affect the C or V flags, sets the N flag if the value loaded in bit 7 is a 1, otherwise resets N, sets Z flag if the loaded value is zero otherwise resets Z and only affects the Y register."
          ]
        }
      },
      "LSR": {
        "category": "shift",
        "flags": "0-----ZC",
        "description": "0 → /M7...M0/ → C",
        "documentation": {
          "title": "Logical Shift Right",
          "text": [
            "This instruction shifts either the accumulator or a specified memory location 1 bit to the right, with the higher bit of the result always being set to 0, and the low bit which is shifted out of the field being stored in the carry flag.",
            "The shift right instruction either affects the accumulator by shift­ing it right 1 or is a read/modify/write instruction which changes a speci­fied memory location but does not affect any internal registers. The shift right does not affect the overflow flag. The N flag is always reset. The Z flag is set if the result of the shift is 0 and reset otherwise. The carry is set equal to bit 0 of the input."
          ]
        }
      },
      "NOP": {
        "category": "nop",
        "flags": "--------",
        "description": "No operation"
      },
      "ORA": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ∨ M → A",
        "documentation": {
          "title": "\"OR\" Memory with Accumulator",
          "text": [
            "The ORA instruction transfers the memory and the accumulator to the adder which performs a binary \"OR\" on a bit-by-bit basis and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "PHA": {
        "category": "stack",
        "flags": "--------",
        "description": "A↓",
        "documentation": {
          "title": "Push Accumulator On Stack",
          "text": [
            "This instruction transfers the current value of the accumulator to the next location on the stack, automatically decrementing the stack to point to the next empty location.",
            "The Push A instruction only affects the stack pointer register which is decremented by 1 as a result of the operation. It affects no flags."
          ]
        }
      },
      "PHP": {
        "category": "stack",
        "flags": "--------",
        "description": "P↓",
        "documentation": {
          "title": "Push Processor Status On Stack",
          "text": [
            "This instruction transfers the contents of the processor status reg­ ister unchanged to the stack, as governed by the stack pointer.",
            "The PHP instruction affects no registers or flags in the micropro­cessor."
          ]
        }
      },
      "PLA": {
        "category": "stack",
        "flags": "N-----Z-",
        "description": "A↑",
        "documentation": {
          "title": "Pull Accumulator From Stack",
          "text": [
            "This instruction adds 1 to the current value of the stack pointer and uses it to address the stack and loads the contents of the stack into the A register.",
            "The PLA instruction does not affect the carry or overflow flags. It sets N if the bit 7 is on in accumulator A as a result of instructions, otherwise it is reset. If accumulator A is zero as a result of the PLA, then the Z flag is set, otherwise it is reset. The PLA instruction changes content of the accumulator A to the contents of the memory location at stack register plus 1 and also increments the stack register."
          ]
        }
      },
      "PLP": {
        "category": "stack",
        "flags": "NV--DIZC",
        "description": "P↑",
        "documentation": {
          "title": "Pull Processor Status From Stack",
          "text": [
            "This instruction transfers the next value on the stack to the Proces­ sor Status register, thereby changing all of the flags and setting the mode switches to the values from the stack.",
            "The PLP instruction affects no registers in the processor other than the status register. This instruction could affect all flags in the status register."
          ]
        }
      },
      "ROL": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C ← /M7...M0/ ← C",
        "documentation": {
          "title": "Rotate Left",
          "text": [
            "The rotate left instruction shifts either the accumulator or addressed memory left 1 bit, with the input carry being stored in bit 0 and with the input bit 7 being stored in the carry flags.",
            "The ROL instruction either shifts the accumulator left 1 bit and stores the carry in accumulator bit 0 or does not affect the internal reg­isters at all. The ROL instruction sets carry equal to the input bit 7, sets N equal to the input bit 6 , sets the Z flag if the result of the ro­ tate is 0, otherwise it resets Z and does not affect the overflow flag at all."
          ]
        }
      },
      "ROR": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C → /M7...M0/ → C",
        "documentation": {
          "title": "Rotate Right",
          "text": [
            "The rotate right instruction shifts either the accumulator or addressed memory right 1 bit with bit 0 shifted into the carry and carry shifted into bit 7.",
            "The ROR instruction either shifts the accumulator right 1 bit and stores the carry in accumulator bit 7 or does not affect the internal regis­ ters at all. The ROR instruction sets carry equal to input bit 0, sets N equal to the input carry and sets the Z flag if the result of the rotate is 0; otherwise it resets Z and does not affect the overflow flag at all.",
            "(Available on Microprocessors after June, 1976)"
          ]
        }
      },
      "RTI": {
        "category": "ctrl",
        "flags": "NV--DIZC",
        "description": "P↑ PC↑",
        "documentation": {
          "title": "Return From Interrupt",
          "text": [
            "This instruction transfers from the stack into the microprocessor the processor status and the program counter location for the instruction which was interrupted. By virtue of the interrupt having stored this data before executing the instruction and thei fact that the RTI reinitializes the microprocessor to the same state as when it was interrupted, the combination of interrupt plus RTI allows truly reentrant coding.",
            "The RTI instruction reinitializes all flags to the position to the point they were at the time the interrupt was taken and sets the program counter back to its pre-interrupt state. It affects no other registers in the microprocessor."
          ]
        }
      },
      "RTS": {
        "category": "ctrl",
        "flags": "--------",
        "description": "PC↑, PC + 1 → PC",
        "documentation": {
          "title": "Return From Subroutme",
          "text": [
            "This instruction loads the program count low and program count high from the stack into the program counter and increments the program counter so that it points to the instruction following the JSR. The stack pointer is adjusted by incrementing it twice.",
            "The RTS instruction does not affect any flags and affects only PCL and PCH."
          ]
        }
      },
      "SBC": {
        "category": "arith",
        "flags": "NV----ZC",
        "description": "A - M - ~C → A",
        "documentation": {
          "title": "Subtract Memory from Accumulator with Borrow",
          "text": [
            "This instruction subtracts the value of memory and borrow from the value of the accumulator, using two's complement arithmetic, and stores the result in the accumulator. Borrow is defined as the carry flag complemented; therefore, a resultant carry flag indicates that a borrow has not occurred.",
            "This instruction affects the accumulator. The carry flag is set if the result is greater than or equal to 0. The carry flag is reset when the result is less than 0, indicating a borrow. The over­flow flag is set when the result exceeds +127 or -127, otherwise it is reset. The negative flag is set if the result in the accumulator has bit 7 on, otherwise it is reset. The Z flag is set if the result in the accumulator is 0, otherwise it is reset."
          ]
        }
      },
      "SEC": {
        "category": "flags",
        "flags": "-------1",
        "description": "1 → C",
        "documentation": {
          "title": "Set Carry Flag",
          "text": [
            "This instruction initializes the carry flag to a 1. This op eration should normally precede a SBC loop. It is also useful when used with a ROL instruction to initialize a bit in memory to a 1.",
            "This instruction affects no registers in the microprocessor and no flags other than the carry flag which is set."
          ]
        }
      },
      "SED": {
        "category": "flags",
        "flags": "----1---",
        "description": "1 → D",
        "documentation": {
          "title": "Set Decimal Mode",
          "text": [
            "This instruction sets the decimal mode flag D to a 1. This makes all subsequent ADC and SBC instructions operate as a decimal arithmetic operation.",
            "SED affects no registers in the microprocessor and no flags other than the decimal mode which is set to a 1."
          ]
        }
      },
      "SEI": {
        "category": "flags",
        "flags": "-----1--",
        "description": "1 → I",
        "documentation": {
          "title": "Set Interrupt Disable",
          "text": [
            "This instruction initializes the interrupt disable to a 1. It is used to mask interrupt requests during system reset operations and during interrupt commands.",
            "It affects no registers in the microprocessor and no flags other than the interrupt disable which is set."
          ]
        }
      },
      "STA": {
        "category": "load",
        "flags": "--------",
        "description": "A → M",
        "documentation": {
          "title": "Store Accumulator in Memory",
          "text": [
            "This instruction transfers the contents of the accumulator to memory.",
            "This instruction affects none of the flags in the processor status register and does not affect the accumulator."
          ]
        }
      },
      "STX": {
        "category": "load",
        "flags": "--------",
        "description": "X → M",
        "documentation": {
          "title": "Store Index Register X In Memory",
          "text": [
            "Transfers value of X register to addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "STY": {
        "category": "load",
        "flags": "--------",
        "description": "Y → M",
        "documentation": {
          "title": "Store Index Register Y In Memory",
          "text": [
            "Transfer the value of the Y register to the addressed memory location.",
            "STY does not affect any flags or registers in the microprocessor."
          ]
        }
      },
      "TAX": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "A → X",
        "documentation": {
          "title": "Transfer Accumulator To Index X",
          "text": [
            "This instruction takes the value from accumulator A and trans­ fers or loads it into the index register X without disturbing the content of the accumulator A.",
            "TAX only affects the index register X, does not affect the carry or overflow flags. The N flag is set if the resultant value in the index register X has bit 7 on, otherwise N is reset. The Z bit is set if the content of the register X is 0 as aresult of theopera­ tion, otherwise it is reset."
          ]
        }
      },
      "TAY": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "A → Y",
        "documentation": {
          "title": "Transfer Accumula Tor To Index Y",
          "text": [
            "This instruction moves the value of the accumulator into index register Y without affecting the accumulator.",
            "TAY instruction only affects the Y register and does not affect either the carry or overflow flags. If the index register Y has bit 7 on, then N is set, otherwise it is reset. If the content of the index register Y equals 0 as a result of the operation, Z is set on, otherwise it is reset."
          ]
        }
      },
      "TSX": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "S → X",
        "documentation": {
          "title": "Transfer Stack Pointer To Index X",
          "text": [
            "This instruction transfers the value in the stack pointer to the index register X.",
            "TSX does not affect the carry or overflow flags. It sets N if bit 7 is on in index X as a result of the instruction, otherwise it is reset. If index X is zero as a result of the TSX, the Z flag is set, other­ wise it is reset. TSX changes the value of index X, making it equal to the content of the stack pointer."
          ]
        }
      },
      "TXA": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "X → A",
        "documentation": {
          "title": "Transfer Index X To Accumulator",
          "text": [
            "This instruction moves the value that is in the index register X to the accumulator A without disturbing the content of the index register X.",
            "TXA does not affect any register other than the accumula­tor and does not affect the carry or overflow flag. If the result in A has bit 7 on, then the N flag is set, otherwise it is reset. If the resultant value in the accumulator is 0, then the Z flag is set, other­ wise it is reset."
          ]
        }
      },
      "TXS": {
        "category": "trans",
        "flags": "--------",
        "description": "X → S",
        "documentation": {
          "title": "Transfer Index X To Stack Pointer",
          "text": [
            "This instruction transfers the value in the index register X to the stack pointer.",
            "TXS changes only the stack pointer, making it equal to the content of the index register X. It does not affect any of the flags."
          ]
        }
      },
      "TYA": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "Y → A",
        "documentation": {
          "title": "Transfer Index Y To Accumulator",
          "text": [
            "This instruction moves the value that is in the index register Y to accumulator A without disturbing the content of the register Y.",
            "TYA does not affect any other register other than the accumula­ tor and does not affect the carry or overflow flag. If the result in the accumulator A has bit 7 on, the N flag is set, otherwise it is reset. If the resultant value in the accumulator A is 0, then the Z flag is set, otherwise it is reset."
          ]
        }
      },
      "#": {
        "category": "mnemos",
        "flags": "are",
        "description": "based on VICE"
      },
      "ANC": {
        "category": "arith",
        "flags": "*-----**",
        "description": "A ∧ M → A, N → C",
        "documentation": {
          "title": "\"AND\" Memory with Accumulator then Move Negative Flag to Carry Flag",
          "text": [
            "The undocumented ANC instruction performs a bit-by-bit AND operation of the accumulator and memory and stores the result back in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag and the carry flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag and the carry flag."
          ]
        }
      },
      "ARR": {
        "category": "arith",
        "flags": "**----**",
        "description": "(A ∧ M) / 2 → A",
        "documentation": {
          "title": "\"AND\" Accumulator then Rotate Right",
          "text": [
            "The undocumented ARR instruction performs a bit-by-bit \"AND\" operation of the accumulator and memory, then shifts the result right 1 bit with bit 0 shifted into the carry and carry shifted into bit 7. It then stores the result back in the accumulator.",
            "If bit 7 of the result is on, then the N flag is set, otherwise it is reset. The instruction sets the Z flag if the result is 0; otherwise it resets Z.",
            "The V and C flags depends on the Decimal Mode Flag:",
            "In decimal mode, the V flag is set if bit 6 is different than the original data's bit 6, otherwise the V flag is reset. The C flag is set if (operand & 0xF0) + (operand & 0x10) is greater than 0x50, otherwise the C flag is reset.",
            "In binary mode, the V flag is set if bit 6 of the result is different than bit 5 of the result, otherwise the V flag is reset. The C flag is set if the result in the accumulator has bit 6 on, otherwise it is reset."
          ]
        }
      },
      "ASR": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "M7 → /M7...M0/ → C",
        "documentation": {
          "title": "Arithmetic Shift Right",
          "text": [
            "This instruction shifts either the accumulator or a specified memory location 1 bit to the right, with the higher bit retaining its value, and the low bit which is shifted out of the field being stored in the carry flag.",
            "ASR does not affect the overflow bit, sets N equal to the result bit 7 (bit 7 in the input), sets Z flag if the result is equal to 0, otherwise resets Z and stores the input bit 0 in the carry flag."
          ]
        }
      },
      "DCP": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M - 1 → M, A - M",
        "documentation": {
          "title": "Decrement Memory By One then Compare with Accumulator",
          "text": [
            "This undocumented instruction subtracts 1, in two's complement, from the contents of the addressed memory location. It then subtracts the contents of memory from the contents of the accumulator.",
            "The DCP instruction does not affect any internal register in the microprocessor. It does not affect the overflow flag. Z flag is set on an equal comparison, reset otherwise; the N flag is set or reset by the result bit 7, the carry flag is set when the result in memory is less than or equal to the accumulator, reset when it is greater than the accumulator."
          ]
        }
      },
      "ISC": {
        "category": "arith",
        "flags": "**----**",
        "description": "M + 1 → M, A - M → A",
        "documentation": {
          "title": "Increment Memory By One then SBC then Subtract Memory from Accumulator with Borrow",
          "text": [
            "This undocumented instruction adds 1 to the contents of the addressed memory loca­tion. It then subtracts the value of the result in memory and borrow from the value of the accumulator, using two's complement arithmetic, and stores the result in the accumulator.",
            "This instruction affects the accumulator. The carry flag is set if the result is greater than or equal to 0. The carry flag is reset when the result is less than 0, indicating a borrow. The over­flow flag is set when the result exceeds +127 or -127, otherwise it is reset. The negative flag is set if the result in the accumulator has bit 7 on, otherwise it is reset. The Z flag is set if the result in the accumulator is 0, otherwise it is reset."
          ]
        }
      },
      "JAM": {
        "category": "kil",
        "flags": "--------",
        "description": "Stop execution",
        "documentation": {
          "title": "Halt the CPU",
          "text": [
            "This undocumented instruction stops execution. The microprocessor will not fetch further instructions, and will neither handle IRQs nor NMIs. It will handle a RESET though."
          ]
        }
      },
      "LAS": {
        "category": "load",
        "flags": "*-----*-",
        "description": "M ∧ S → A, X, S",
        "documentation": {
          "title": "\"AND\" Memory with Stack Pointer",
          "text": [
            "This undocumented instruction performs a bit-by-bit \"AND\" operation of the stack pointer and memory and stores the result back in the accumulator, the index register X and the stack pointer.",
            "The LAS instruction does not affect the carry or overflow flags. It sets N if the bit 7 of the result is on, otherwise it is reset. If the result is zero, then the Z flag is set, otherwise it is reset."
          ]
        }
      },
      "LAX": {
        "category": "load",
        "flags": "*-----*-",
        "description": "M → A, X",
        "documentation": {
          "title": "Load Accumulator and Index Register X From Memory",
          "text": [
            "The undocumented LAX instruction loads the accumulator and the index register X from memory.",
            "LAX does not affect the C or V flags; sets Z if the value loaded was zero, otherwise resets it; sets N if the value loaded in bit 7 is a 1; otherwise N is reset, and affects only the X register."
          ]
        }
      },
      "RLA": {
        "category": "arith",
        "flags": "*-----**",
        "description": "C ← /M7...M0/ ← C, A ∧ M → A",
        "documentation": {
          "title": "Rotate Left then \"AND\" with Accumulator",
          "text": [
            "The undocumented RLA instruction shifts the addressed memory left 1 bit, with the input carry being stored in bit 0 and with the input bit 7 being stored in the carry flags. It then performs a bit-by-bit AND operation of the result and the value of the accumulator and stores the result back in the accumulator.",
            "This instruction affects the accumulator; sets the zero flag if the result in the accumulator is 0, otherwise resets the zero flag; sets the negative flag if the result in the accumulator has bit 7 on, otherwise resets the negative flag."
          ]
        }
      },
      "RRA": {
        "category": "arith",
        "flags": "**----**",
        "description": "C → /M7...M0/ → C, A + M + C → A",
        "documentation": {
          "title": "Rotate Right and Add Memory to Accumulator",
          "text": [
            "The undocumented RRA instruction shifts the addressed memory right 1 bit with bit 0 shifted into the carry and carry shifted into bit 7. It then adds the result and generated carry to the value of the accumulator and stores the result in the accumulator.",
            "This instruction affects the accumulator; sets the carry flag when the sum of a binary add exceeds 255 or when the sum of a decimal add exceeds 99, otherwise carry is reset. The overflow flag is set when the sign or bit 7 is changed due to the result exceeding +127 or -128, otherwise overflow is reset. The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. The zero flag is set if the accumulator result is 0, otherwise the zero flag is reset."
          ]
        }
      },
      "SAX": {
        "category": "load",
        "flags": "--------",
        "description": "A ∧ X → M",
        "documentation": {
          "title": "Store Accumulator \"AND\" Index Register X in Memory",
          "text": [
            "The undocumented SAX instruction performs a bit-by-bit AND operation of the value of the accumulator and the value of the index register X and stores the result in memory.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SBX": {
        "category": "arith",
        "flags": "*-----**",
        "description": "(A ∧ X) - M → X",
        "documentation": {
          "title": "Subtract Memory from Accumulator \"AND\" Index Register X",
          "text": [
            "This undocumented instruction performs a bit-by-bit \"AND\" of the value of the accumulator and the index register X and subtracts the value of memory from this result, using two's complement arithmetic, and stores the result in the index register X.",
            "This instruction affects the index register X. The carry flag is set if the result is greater than or equal to 0. The carry flag is reset when the result is less than 0, indicating a borrow. The negative flag is set if the result in index register X has bit 7 on, otherwise it is reset. The Z flag is set if the result in index register X is 0, otherwise it is reset. The over­flow flag not affected at all."
          ]
        }
      },
      "SHA": {
        "category": "load",
        "flags": "--------",
        "description": "A ∧ X ∧ V → M",
        "documentation": {
          "title": "Store Accumulator \"AND\" Index Register X \"AND\" Value",
          "text": [
            "The undocumented SHA instruction performs a bit-by-bit AND operation of the following three operands: The first two are the accumulator and the index register X.",
            "The third operand depends on the addressing mode. In the zero page indirect Y-indexed case, the third operand is the data in memory at the given zero page address (ignoring the the addressing mode's Y offset) plus 1. In the Y-indexed absolute case, it is the upper 8 bits of the given address (ignoring the the addressing mode's Y offset), plus 1.",
            "It then transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SHS": {
        "category": "trans",
        "flags": "--------",
        "description": "A ∧ X → S, S ∧ (H + 1) → M",
        "documentation": {
          "title": "Transfer Accumulator \"AND\" Index Register X to Stack Pointer then Store Stack Pointer \"AND\" Hi-Byte In Memory",
          "text": [
            "The undocumented SHS instruction performs a bit-by-bit AND operation of the value of the accumulator and the value of the index register X and stores the result in the stack pointer. It then performs a bit-by-bit AND operation of the resulting stack pointer and the upper 8 bits of the given address (ignoring the addressing mode's Y offset), plus 1, and transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SHX": {
        "category": "load",
        "flags": "--------",
        "description": "X ∧ (H + 1) → M",
        "documentation": {
          "title": "Store Index Register X \"AND\" Value",
          "text": [
            "The undocumented SHX instruction performs a bit-by-bit AND operation of the index register X and the upper 8 bits of the given address (ignoring the the addressing mode's Y offset), plus 1. It then transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SHY": {
        "category": "load",
        "flags": "--------",
        "description": "Y ∧ (H + 1) → M",
        "documentation": {
          "title": "Store Index Register Y \"AND\" Value",
          "text": [
            "The undocumented SHY instruction performs a bit-by-bit AND operation of the index register Y and the upper 8 bits of the given address (ignoring the the addressing mode's X offset), plus 1. It then transfers the result to the addressed memory location.",
            "No flags or registers in the microprocessor are affected by the store operation."
          ]
        }
      },
      "SLO": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M * 2 → M, A ∨ M → A",
        "documentation": {
          "title": "Arithmetic Shift Left then \"OR\" Memory with Accumulator",
          "text": [
            "The undocumented SLO instruction shifts the address memory location 1 bit to the left, with the bit 0 always being set to 0 and the bit 7 output always being contained in the carry flag. It then performs a bit-by-bit \"OR\" operation on the result and the accumulator and stores the result in the accumulator.",
            "The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. It sets Z flag if the result is equal to 0, otherwise resets Z and stores the input bit 7 in the carry flag."
          ]
        }
      },
      "SRE": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M / 2 → M, A ⊻ M → A",
        "documentation": {
          "title": "Logical Shift Right then \"Exclusive OR\" Memory with Accumulator",
          "text": [
            "The undocumented SRE instruction shifts the specified memory location 1 bit to the right, with the higher bit of the result always being set to 0, and the low bit which is shifted out of the field being stored in the carry flag. It then performs a bit-by-bit \"EXCLUSIVE OR\" of the result and the value of the accumulator and stores the result in the accumulator.",
            "This instruction affects the accumulator. It does not affect the overflow flag. The negative flag is set if the accumulator result contains bit 7 on, otherwise the negative flag is reset. The Z flag is set if the result is 0 and reset otherwise. The carry is set equal to input bit 0."
          ]
        }
      },
      "XAA": {
        "category": "arith",
        "flags": "*-----*-",
        "description": "(A ∨ V) ∧ X ∧ M → A",
        "documentation": {
          "title": "Non-deterministic Operation of Accumulator, Index Register X, Memory and Bus Contents",
          "text": [
            "The operation of the undocumented XAA instruction depends on the individual microprocessor. On most machines, it performs a bit-by-bit AND operation of the following three operands: The first two are the index register X and memory.",
            "The third operand is the result of a bit-by-bit AND operation of the accumulator and a magic component. This magic component depends on the individual microprocessor and is usually one of $00, $EE, $EF, $FE and $FF, and may be influenced by the RDY pin, leftover contents of the data bus, the temperature of the microprocessor, the supplied voltage, and other factors.",
            "On some machines, additional bits of the result may be set or reset depending on non-deterministic factors.",
            "It then transfers the result to the accumulator.",
            "XAA does not affect the C or V flags; sets Z if the value loaded was zero, otherwise resets it; sets N if the result in bit 7 is a 1; otherwise N is reset."
          ]
        }
      },
      "BRA": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch Always",
        "documentation": {
          "title": "Branch Always",
          "text": [
            "This instruction takes an unconditional branch.",
            "BRA does not affect any of the flags or any other part of the machine other than the program counter."
          ]
        }
      },
      "PHX": {
        "category": "stack",
        "flags": "--------",
        "description": "X↓",
        "documentation": {
          "title": "Push Index Register X On Stack",
          "text": [
            "This instruction transfers the current value of the index register X to the next location on the stack, automatically decrementing the stack to point to the next empty location.",
            "The Push X instruction only affects the stack pointer register which is decremented by 1 as a result of the operation. It affects no flags."
          ]
        }
      },
      "PHY": {
        "category": "stack",
        "flags": "--------",
        "description": "Y↑",
        "documentation": {
          "title": "Push Index Register Y On Stack",
          "text": [
            "This instruction transfers the current value of the index register Y to the next location on the stack, automatically decrementing the stack to point to the next empty location.",
            "The Push Y instruction only affects the stack pointer register which is decremented by 1 as a result of the operation. It affects no flags."
          ]
        }
      },
      "PLX": {
        "category": "stack",
        "flags": "N-----Z-",
        "description": "X↑",
        "documentation": {
          "title": "Pull Index Register X From Stack",
          "text": [
            "This instruction adds 1 to the current value of the stack pointer and uses it to address the stack and loads the contents of the stack into the X register.",
            "The PLX instruction does not affect the carry or overflow flags. It sets N if the bit 7 is on in index register X as a result of instructions, otherwise it is reset. If index register X is zero as a result of the PLA, then the Z flag is set, otherwise it is reset. The PLX instruction changes content of the index register X to the contents of the memory location at stack register plus 1 and also increments the stack register."
          ]
        }
      },
      "PLY": {
        "category": "stack",
        "flags": "N-----Z-",
        "description": "Y↑",
        "documentation": {
          "title": "Pull Index Register Y From Stack",
          "text": [
            "This instruction adds 1 to the current value of the stack pointer and uses it to address the stack and loads the contents of the stack into the Y register.",
            "The PLY instruction does not affect the carry or overflow flags. It sets N if the bit 7 is on in index register Y as a result of instructions, otherwise it is reset. If index register Y is zero as a result of the PLA, then the Z flag is set, otherwise it is reset. The PLY instruction changes content of the index register Y to the contents of the memory location at stack register plus 1 and also increments the stack register."
          ]
        }
      },
      "STZ": {
        "category": "load",
        "flags": "--------",
        "description": "Z → M",
        "documentation": {
          "title": "Store Z Register"
        }
      },
      "TRB": {
        "category": "logic",
        "flags": "------Z-",
        "description": "~A ∧ M → M",
        "documentation": {
          "title": "Test And Reset Memory Bits With Accumulator",
          "text": [
            "This instruction tests and resets bits in memory, using the accumulator for both a test mask, and a reset mask. It performs a logical AND between the inverted bits of the accumulator and the bits in memory, storing the result back into memory.",
            "The zero flag is set if all bits of the result of the AND are zero, otherwise it is reset."
          ]
        }
      },
      "TSB": {
        "category": "logic",
        "flags": "------Z-",
        "description": "A ∨ M → M",
        "documentation": {
          "title": "Test And Set Memory Bits With Accumulator",
          "text": [
            "This instruction tests and sets bits in memory, using the accumulator for both a test mask, and a set mask. It performs a logical OR between the bits of the accumulator and the bits in memory, storing the result back into memory.",
            "The zero flag is set if all bits of the result of the OR are zero, otherwise it is reset."
          ]
        }
      },
      "BBR0": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M0 = 0",
        "documentation": {
          "title": "Branch on Bit 0 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 0 is clear."
          ]
        }
      },
      "BBR1": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M1 = 0",
        "documentation": {
          "title": "Branch on Bit 1 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 1 is clear."
          ]
        }
      },
      "BBR2": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M2 = 0",
        "documentation": {
          "title": "Branch on Bit 2 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 2 is clear."
          ]
        }
      },
      "BBR3": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M3 = 0",
        "documentation": {
          "title": "Branch on Bit 3 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 3 is clear."
          ]
        }
      },
      "BBR4": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M4 = 0",
        "documentation": {
          "title": "Branch on Bit 4 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 4 is clear."
          ]
        }
      },
      "BBR5": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M5 = 0",
        "documentation": {
          "title": "Branch on Bit 5 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 5 is clear."
          ]
        }
      },
      "BBR6": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M6 = 0",
        "documentation": {
          "title": "Branch on Bit 6 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 6 is clear."
          ]
        }
      },
      "BBR7": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M7 = 0",
        "documentation": {
          "title": "Branch on Bit 7 Reset",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 7 is clear."
          ]
        }
      },
      "BBS0": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M0 = 1",
        "documentation": {
          "title": "Branch on Bit 0 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 0 is set."
          ]
        }
      },
      "BBS1": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M1 = 1",
        "documentation": {
          "title": "Branch on Bit 1 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 1 is set."
          ]
        }
      },
      "BBS2": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M2 = 1",
        "documentation": {
          "title": "Branch on Bit 2 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 2 is set."
          ]
        }
      },
      "BBS3": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M3 = 1",
        "documentation": {
          "title": "Branch on Bit 3 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 3 is set."
          ]
        }
      },
      "BBS4": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M4 = 1",
        "documentation": {
          "title": "Branch on Bit 4 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 4 is set."
          ]
        }
      },
      "BBS5": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M5 = 1",
        "documentation": {
          "title": "Branch on Bit 5 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 5 is set."
          ]
        }
      },
      "BBS6": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M6 = 1",
        "documentation": {
          "title": "Branch on Bit 6 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 6 is set."
          ]
        }
      },
      "BBS7": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch on M7 = 1",
        "documentation": {
          "title": "Branch on Bit 7 Set",
          "text": [
            "This instruction tests the specified zero page location and branches if bit 7 is set."
          ]
        }
      },
      "RMB0": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M0",
        "documentation": {
          "title": "Reset Memory Bit 0",
          "text": [
            "This instruction clears bit 0 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "RMB1": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M1",
        "documentation": {
          "title": "Reset Memory Bit 1",
          "text": [
            "This instruction clears bit 1 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "RMB2": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M2",
        "documentation": {
          "title": "Reset Memory Bit 2",
          "text": [
            "This instruction clears bit 2 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "RMB3": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M3",
        "documentation": {
          "title": "Reset Memory Bit 3",
          "text": [
            "This instruction clears bit 3 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "RMB4": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M4",
        "documentation": {
          "title": "Reset Memory Bit 4",
          "text": [
            "This instruction clears bit 4 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "RMB5": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M5",
        "documentation": {
          "title": "Reset Memory Bit 5",
          "text": [
            "This instruction clears bit 5 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "RMB6": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M6",
        "documentation": {
          "title": "Reset Memory Bit 6",
          "text": [
            "This instruction clears bit 6 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "RMB7": {
        "category": "logic",
        "flags": "--------",
        "description": "0 → M7",
        "documentation": {
          "title": "Reset Memory Bit 7",
          "text": [
            "This instruction clears bit 7 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB0": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M0",
        "documentation": {
          "title": "Set Memory Bit 0",
          "text": [
            "This instruction sets bit 0 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB1": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M1",
        "documentation": {
          "title": "Set Memory Bit 1",
          "text": [
            "This instruction sets bit 1 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB2": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M2",
        "documentation": {
          "title": "Set Memory Bit 2",
          "text": [
            "This instruction sets bit 2 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB3": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M3",
        "documentation": {
          "title": "Set Memory Bit 3",
          "text": [
            "This instruction sets bit 3 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB4": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M4",
        "documentation": {
          "title": "Set Memory Bit 4",
          "text": [
            "This instruction sets bit 4 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB5": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M5",
        "documentation": {
          "title": "Set Memory Bit 5",
          "text": [
            "This instruction sets bit 5 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB6": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M6",
        "documentation": {
          "title": "Set Memory Bit 6",
          "text": [
            "This instruction sets bit 6 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "SMB7": {
        "category": "logic",
        "flags": "--------",
        "description": "1 → M7",
        "documentation": {
          "title": "Set Memory Bit 7",
          "text": [
            "This instruction sets bit 7 in the specified zero page location. It does not affect any flags or registers."
          ]
        }
      },
      "ASW": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C ← /M15...M0/ ← 0",
        "documentation": {
          "title": "Arithmetic Shift Left Word",
          "text": [
            "The ASW instruction shifts either the 16 bit value at the memory location 1 bit to the left, with the bit 0 always being set to 0 and the bit 15 output always being contained in the carry flag. It is a read/modify/write instruction that affects only memory.",
            "The instruction does not affect the overflow bit, sets N equal to the result bit 15 (bit 14 in the input), sets Z flag if the result is equal to 0, otherwise resets Z and stores the input bit 7 in the carry flag."
          ]
        }
      },
      "AUG": {
        "category": "nop",
        "flags": "--------",
        "description": "No Operation",
        "documentation": {
          "title": "Augment",
          "text": [
            "The AUG instruction is a 4-byte NOP, and reserved for future expansion."
          ]
        }
      },
      "BSR": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch to Subroutine",
        "documentation": {
          "title": "Branch to Subroutine",
          "text": [
            "The BSR Branch to SubRoutine instruction pushes the two program counter bytes PCH and PCL onto the stack. It then adds the word-relative signed offset to the program counter. The relative offset is referenced to the address of the BSR opcode + 2, hence, it is relative to the third byte of the three-byte BSR instruction. The return address, on the stack, also points to this address. This was done to make it compatible with the RTS functionality, and to be consistant will other word-relative operations."
          ]
        }
      },
      "CLE": {
        "category": "flags",
        "flags": "--0-----",
        "description": "0 → E",
        "documentation": {
          "title": "Clear Extend Disable Flag",
          "text": [
            "This instruction initializes the extend disable to a 0. This sets the stack pointer to 16 bit mode.",
            "It affects no registers in the microprocessor and no flags other than the extend disable which is cleared."
          ]
        }
      },
      "CPZ": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "Z - M",
        "documentation": {
          "title": "Compare Index Register Z To Memory",
          "text": [
            "This instruction performs a two's complement subtraction between the index register Z and the specified memory location. The results of the subtraction are not stored anywhere. The instruction is strict­ly used to set the flags.",
            "CPZ affects no registers in the microprocessor and also does not affect the overflow flag. If the value in the index register Z is equal to or greater than the value in the memory, the carry flag will be set, otherwise it will be cleared. If the results of the subtract- tion contain bit 7 on the N bit will be set, otherwise it will be cleared. If the value in the index register Z and the value in the memory are equal, the zero flag will be set, otherwise it will be cleared."
          ]
        }
      },
      "DEW": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "Mw - 1 → Mw",
        "documentation": {
          "title": "Decrement Word"
        }
      },
      "DEZ": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "Z - 1 → Z",
        "documentation": {
          "title": "Decrement Z Register"
        }
      },
      "INW": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "Mw + 1 → Mw",
        "documentation": {
          "title": "Increment Word"
        }
      },
      "INZ": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "Z + 1 → Z",
        "documentation": {
          "title": "Increment Z Register"
        }
      },
      "LDZ": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → Z",
        "documentation": {
          "title": "Load Z Register"
        }
      },
      "NEG": {
        "category": "arith",
        "flags": "N-----Z-",
        "description": "0 - A → A",
        "documentation": {
          "title": "Negate"
        }
      },
      "PHW": {
        "category": "stack",
        "flags": "--------",
        "description": "Mw↓",
        "documentation": {
          "title": "Push Word"
        }
      },
      "PHZ": {
        "category": "stack",
        "flags": "--------",
        "description": "Z↓",
        "documentation": {
          "title": "Push Z Register"
        }
      },
      "PLZ": {
        "category": "stack",
        "flags": "N-----Z-",
        "description": "Z↑",
        "documentation": {
          "title": "Pull Z Register"
        }
      },
      "ROW": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C ← /15...0/ ← C",
        "documentation": {
          "title": "Rotate Word"
        }
      },
      "RTN": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Return from Kernal",
        "documentation": {
          "title": "Return from Kernal"
        }
      },
      "SEE": {
        "category": "flags",
        "flags": "--1-----",
        "description": "1 → E",
        "documentation": {
          "title": "Set Stack Extend Disable Flag"
        }
      },
      "TAB": {
        "category": "trans",
        "flags": "--------",
        "description": "A → B",
        "documentation": {
          "title": "Transfer Accumulator to Base Page Register"
        }
      },
      "TAZ": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "A → Z",
        "documentation": {
          "title": "Transfer Accumulator to Z"
        }
      },
      "TBA": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "B → A",
        "documentation": {
          "title": "Transfer Base Page Register to Accumulator"
        }
      },
      "TSY": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "S → Y",
        "documentation": {
          "title": "Transfer Stack Pointer to Y"
        }
      },
      "TYS": {
        "category": "trans",
        "flags": "--------",
        "description": "Y → S",
        "documentation": {
          "title": "Transfer Y to Stack Pointer"
        }
      },
      "TZA": {
        "category": "stack",
        "flags": "N-----Z-",
        "description": "Z → A",
        "documentation": {
          "title": "Transfer Z to Accumulator"
        }
      }
    },
    "mnemos": {
      "ADC": {
        "description": "Add with Carry"
      },
      "AND": {
        "description": "Logical AND"
      },
      "ASL": {
        "description": "Arithmetic Shift Left"
      },
      "BCC": {
        "description": "Branch if Carry Clear"
      },
      "BCS": {
        "description": "Branch if Carry Set"
      },
      "BEQ": {
        "description": "Branch if Equal"
      },
      "BIT": {
        "description": "Bit Test"
      },
      "BMI": {
        "description": "Branch if Minus"
      },
      "BNE": {
        "description": "Branch if Not Equal"
      },
      "BPL": {
        "description": "Branch if Plus"
      },
      "BRK": {
        "description": "Force Interrupt"
      },
      "BVC": {
        "description": "Branch if Overflow Clear"
      },
      "BVS": {
        "description": "Branch if Overflow Set"
      },
      "CLC": {
        "description": "Clear Carry Flag"
      },
      "CLD": {
        "description": "Clear Decimal Mode"
      },
      "CLI": {
        "description": "Clear Interrupt Disable"
      },
      "CLV": {
        "description": "Clear Overflow Flag"
      },
      "CMP": {
        "description": "Compare"
      },
      "CPX": {
        "description": "Compare X Register"
      },
      "CPY": {
        "description": "Compare Y Register"
      },
      "DEC": {
        "description": "Decrement Memory"
      },
      "DEX": {
        "description": "Decrement X Register"
      },
      "DEY": {
        "description": "Decrement Y Register"
      },
      "EOR": {
        "description": "Exclusive OR"
      },
      "INC": {
        "description": "Increment Memory"
      },
      "INX": {
        "description": "Increment X Register"
      },
      "INY": {
        "description": "Increment Y Register"
      },
      "JMP": {
        "description": "Jump"
      },
      "JSR": {
        "description": "Jump to Subroutine"
      },
      "LDA": {
        "description": "Load Accumulator"
      },
      "LDX": {
        "description": "Load X Register"
      },
      "LDY": {
        "description": "Load Y Register"
      },
      "LSR": {
        "description": "Logical Shift Right"
      },
      "NOP": {
        "description": "No Operation"
      },
      "ORA": {
        "description": "Logical OR"
      },
      "PHA": {
        "description": "Push Accumulator"
      },
      "PHP": {
        "description": "Push Processor Status"
      },
      "PLA": {
        "description": "Pull Accumulator"
      },
      "PLP": {
        "description": "Pull Processor Status"
      },
      "ROL": {
        "description": "Rotate Left"
      },
      "ROR": {
        "description": "Rotate Right"
      },
      "RTI": {
        "description": "Return from Interrupt"
      },
      "RTS": {
        "description": "Return from Subroutine"
      },
      "SBC": {
        "description": "Subtract with Carry"
      },
      "SEC": {
        "description": "Set Carry Flag"
      },
      "SED": {
        "description": "Set Decimal Flag"
      },
      "SEI": {
        "description": "Set Interrupt Disable"
      },
      "STA": {
        "description": "Store Accumulator"
      },
      "STX": {
        "description": "Store X Register"
      },
      "STY": {
        "description": "Store Y Register"
      },
      "TAX": {
        "description": "Transfer Accumulator to X"
      },
      "TAY": {
        "description": "Transfer Accumulator to Y"
      },
      "TSX": {
        "description": "Transfer Stack Pointer to X"
      },
      "TXA": {
        "description": "Transfer X to Accumulator"
      },
      "TXS": {
        "description": "Transfer X to Stack Pointer"
      },
      "TYA": {
        "description": "Transfer Y to Accumulator"
      },
      "BRA": {
        "description": "Branch Always"
      },
      "PHX": {
        "description": "Push X Register"
      },
      "PHY": {
        "description": "Push Y Register"
      },
      "PLX": {
        "description": "Pull X Register"
      },
      "PLY": {
        "description": "Pull Y Register"
      },
      "STZ": {
        "description": "Store Z Register"
      },
      "TRB": {
        "description": "Test and Reset Memory Bits"
      },
      "TSB": {
        "description": "Test and Set Memory Bits"
      },
      "BBR0": {
        "description": "Branch on Bit 0 Reset"
      },
      "BBR1": {
        "description": "Branch on Bit 1 Reset"
      },
      "BBR2": {
        "description": "Branch on Bit 2 Reset"
      },
      "BBR3": {
        "description": "Branch on Bit 3 Reset"
      },
      "BBR4": {
        "description": "Branch on Bit 4 Reset"
      },
      "BBR5": {
        "description": "Branch on Bit 5 Reset"
      },
      "BBR6": {
        "description": "Branch on Bit 6 Reset"
      },
      "BBR7": {
        "description": "Branch on Bit 7 Reset"
      },
      "BBS0": {
        "description": "Branch on Bit 0 Set"
      },
      "BBS1": {
        "description": "Branch on Bit 1 Set"
      },
      "BBS2": {
        "description": "Branch on Bit 2 Set"
      },
      "BBS3": {
        "description": "Branch on Bit 3 Set"
      },
      "BBS4": {
        "description": "Branch on Bit 4 Set"
      },
      "BBS5": {
        "description": "Branch on Bit 5 Set"
      },
      "BBS6": {
        "description": "Branch on Bit 6 Set"
      },
      "BBS7": {
        "description": "Branch on Bit 7 Set"
      },
      "RMB0": {
        "description": "Reset Memory Bit 0"
      },
      "RMB1": {
        "description": "Reset Memory Bit 1"
      },
      "RMB2": {
        "description": "Reset Memory Bit 2"
      },
      "RMB3": {
        "description": "Reset Memory Bit 3"
      },
      "RMB4": {
        "description": "Reset Memory Bit 4"
      },
      "RMB5": {
        "description": "Reset Memory Bit 5"
      },
      "RMB6": {
        "description": "Reset Memory Bit 6"
      },
      "RMB7": {
        "description": "Reset Memory Bit 7"
      },
      "SMB0": {
        "description": "Set Memory Bit 0"
      },
      "SMB1": {
        "description": "Set Memory Bit 1"
      },
      "SMB2": {
        "description": "Set Memory Bit 2"
      },
      "SMB3": {
        "description": "Set Memory Bit 3"
      },
      "SMB4": {
        "description": "Set Memory Bit 4"
      },
      "SMB5": {
        "description": "Set Memory Bit 5"
      },
      "SMB6": {
        "description": "Set Memory Bit 6"
      },
      "SMB7": {
        "description": "Set Memory Bit 7"
      },
      "ASR": {
        "description": "Arithmetic Shift Right"
      },
      "ASW": {
        "description": "Arithmetic Shift Left Word"
      },
      "AUG": {
        "description": "Augment"
      },
      "BSR": {
        "description": "Branch to Subroutine"
      },
      "CLE": {
        "description": "Clear Extend Disable Flag"
      },
      "CPZ": {
        "description": "Compare Z Register"
      },
      "DEW": {
        "description": "Decrement Word"
      },
      "DEZ": {
        "description": "Decrement Z Register"
      },
      "INW": {
        "description": "Increment Word"
      },
      "INZ": {
        "description": "Increment Z Register"
      },
      "LDZ": {
        "description": "Load Z Register"
      },
      "NEG": {
        "description": "Negate"
      },
      "PHW": {
        "description": "Push Word"
      },
      "PHZ": {
        "description": "Push Z Register"
      },
      "PLZ": {
        "description": "Pull Z Register"
      },
      "ROW": {
        "description": "Rotate Word"
      },
      "RTN": {
        "description": "Return from Kernal"
      },
      "SEE": {
        "description": "Set Stack Extend Disable Flag"
      },
      "TAB": {
        "description": "Transfer Accumulator to Base Page Register"
      },
      "TAZ": {
        "description": "Transfer Accumulator to Z"
      },
      "TBA": {
        "description": "Transfer Base Page Register to Accumulator"
      },
      "TSY": {
        "description": "Transfer Stack Pointer to Y"
      },
      "TYS": {
        "description": "Transfer Y to Stack Pointer"
      },
      "TZA": {
        "description": "Transfer Z to Accumulator"
      }
    },
    "addmodes": {
      "-": {
        "bytes": "1",
        "syntax": "",
        "description": "Implied",
        "documentation": {
          "title": "Implied",
          "text": [
            "In the implied addressing mode, the address containing the operand is implicitly stated in the operation code of the instruction."
          ]
        }
      },
      "A": {
        "bytes": "1",
        "syntax": "A",
        "description": "Accumulator",
        "documentation": {
          "title": "Accumulator",
          "text": [
            "This form of addressing is represented with a one byte instruction, implying an operation on the accumulator."
          ]
        }
      },
      "#d8": {
        "bytes": "2",
        "syntax": "#$nn",
        "description": "Immediate",
        "documentation": {
          "title": "Immediate",
          "text": [
            "In immediate addressing, the operand is contained in the second byte of the instruction, with no further memory addressing required."
          ]
        }
      },
      "a8": {
        "bytes": "2",
        "syntax": "$nn",
        "description": "Base Page",
        "documentation": {
          "title": "Base Page",
          "text": [
            "The second byte of the two-byte instruction contains the low-order address byte, and the B register contains the high-order address byte of the memory location to be used by the operation."
          ]
        }
      },
      "a8,X": {
        "bytes": "2",
        "syntax": "$nn,X",
        "description": "X-Indexed Base Page",
        "documentation": {
          "title": "X-Indexed Base Page",
          "text": [
            "The second byte of the two-byte instruction is added to the X index register to form the low-order address byte, and the B register contains the high-order address byte of the memory location to be used by the operation."
          ]
        }
      },
      "a8,Y": {
        "bytes": "2",
        "syntax": "$nn,Y",
        "description": "Y-Indexed Base Page",
        "documentation": {
          "title": "Y-Indexed Base Page",
          "text": [
            "The second byte of the two-byte instruction is added to the Y index register to form the low-order address byte, and the B register contains the high-order address byte of the memory location to be used by the operation."
          ]
        }
      },
      "(a8,X)": {
        "bytes": "2",
        "syntax": "($nn,X)",
        "description": "X-Indexed Base Page Indirect",
        "documentation": {
          "title": "X-Indexed Base Page Indirect",
          "text": [
            "The second byte of the two-byte instruction is added to the contents of the X register to form the low-order address byte, and the contents of the B register contains the high-order address byte, of two memory locations that contain the low-order and high-order address of the memory location to be used by the operation."
          ]
        }
      },
      "(a8),Y": {
        "bytes": "2",
        "syntax": "($nn),Y",
        "description": "Base Page Indirect Y-Indexed",
        "documentation": {
          "title": "Base Page Indirect Y-Indexed",
          "text": [
            "The second and third bytes of the three-byte instruction are added to the unsigned contents of the X index register to form the low-order and high-order address bytes, respectively, of two memory locations containing the low-order and high-order JMP or JSR address bytes."
          ]
        }
      },
      "a16": {
        "bytes": "3",
        "syntax": "$nnnn",
        "description": "Absolute",
        "documentation": {
          "title": "Absolute",
          "text": [
            "In absolute addressing, the second byte of the instruction specifies the eight low order bits of the effective address while the third byte specifies the eight high order bits. Thus, the absolute addressing mode allows access to the entire 65 K bytes of addressable memory."
          ]
        }
      },
      "a16,X": {
        "bytes": "3",
        "syntax": "$nnnn,X",
        "description": "X-Indexed Absolute",
        "documentation": {
          "title": "X-Indexed Absolute",
          "text": [
            "This form of addressing is used in conjunction with the X index register. The effective address is formed by adding the contents of X to the address contained in the second and third bytes of the instruction. This mode allows the index register to contain the index or count value and the instruction to contain the base address. This type of indexing allows any location referencing and the index to modify multiple fields resulting in reduced coding and execution time."
          ]
        }
      },
      "a16,Y": {
        "bytes": "3",
        "syntax": "$nnnn,Y",
        "description": "Y-Indexed Absolute",
        "documentation": {
          "title": "Y-Indexed Absolute",
          "text": [
            "This form of addressing is used in conjunction with the Y index register. The effective address is formed by adding the contents of Y to the address contained in the second and third bytes of the instruction. This mode allows the index register to contain the index or count value and the instruction to contain the base address. This type of indexing allows any location referencing and the index to modify multiple fields resulting in reduced coding and execution time."
          ]
        }
      },
      "(a16)": {
        "bytes": "3",
        "syntax": "($nnnn)",
        "description": "Absolute Indirect",
        "documentation": {
          "title": "Absolute Indirect",
          "text": [
            "The second byte of the instruction contains the low order eight bits of a memory location. The high order eight bits of that memory location is contained in the third byte of the instruction. The contents of the fully specified memory location is the low order byte of the effective address. The next memory location contains the high order byte of the effective address which is loaded into the sixteen bits of the program counter."
          ]
        }
      },
      "r8": {
        "bytes": "2",
        "syntax": "$nnnn",
        "description": "Relative",
        "documentation": {
          "title": "Relative",
          "text": [
            "Relative addressing is used only with branch instructions and establishes a destination for the conditional branch.",
            "The second byte of-the instruction becomes the operand which is an “Offset\" added to the contents of the lower eight bits of the program counter when the counter is set at the next instruction. The range of the offset is —128 to +127 bytes from the next instruction."
          ]
        }
      },
      "(a8)": {
        "bytes": "2",
        "syntax": "($nn)",
        "description": "Zero Page Indirect",
        "documentation": {
          "title": "Zero Page Indirect",
          "text": [
            "With Zero Page Indirect addressing mode, the second byte of the instruction is a zero page indirect address that points to the low byte of a two byte effective address."
          ]
        }
      },
      "(a16,X)": {
        "bytes": "3",
        "syntax": "($nnnn,X)",
        "description": "Absolute X-Indexed Indirect",
        "documentation": {
          "title": "Absolute X-Indexed Indirect",
          "text": [
            "With the Absolute Indexed Indirect addressing mode, the X Index Register is added to the second and third byes of the instruction to form an address to a pointer. This address mode is only used with the JMP instruction and the program Counter is loaded with the first and second bytes at this pointer."
          ]
        }
      },
      "a8,r8": {
        "bytes": "3",
        "syntax": "$nn,$nnnn",
        "description": "Zero Page, Relative",
        "documentation": {
          "title": "Base Page, Relative",
          "text": [
            "This mode bit tests the base page location specified for bit set/reset per the mask and performs a conditional relative branch based on the results of the bit test."
          ]
        }
      },
      "#d16": {
        "bytes": "3",
        "syntax": "#$nnnn",
        "description": "Immediate (word)",
        "documentation": {
          "title": "Immediate (word)",
          "text": [
            "The data used in the operation is taken from the bytes immediately following the opcode in the 3-byte instruction."
          ]
        }
      },
      "(a8),Z": {
        "bytes": "2",
        "syntax": "($nn),Z",
        "description": "Indirect Z-Indexed",
        "documentation": {
          "title": "Indirect Z-Indexed",
          "text": [
            "The second byte of the two-byte instruction contains the low-order byte, and the B register contains the high-order address byte of two memory locations whose contents are added to the unsigned Z index register to form the address of the memory location to be used by the operation."
          ]
        }
      },
      "r16": {
        "bytes": "3",
        "syntax": "$nnnn",
        "description": "Relative (word)",
        "documentation": {
          "title": "Relative (word)",
          "text": [
            "The second and third bytes of the three-byte branch instruction are added to the low-order and high-order program counter bytes, respectively. (The program counter now contains the opcode address plus two). If the condition of the branch is true, the sum is stored back into the program counter."
          ]
        }
      },
      "(a8,S),Y": {
        "bytes": "2",
        "syntax": "($nnnn,SP),Y",
        "description": "Stack Relative Indirect Y-Indexed",
        "documentation": {
          "title": "Stack Relative Indirect Y-Indexed",
          "text": [
            "The second byte of the two-byte instruction contains an unsigned offset value, d, which is added to the stack pointer (word) to form the address of two memory locations whose contents are added to the unsigned Y register to form the address of the memory location to be used by the operation."
          ]
        }
      }
    },
    "all_mnemos": {
      "regular": [
        "ADC",
        "AND",
        "ASL",
        "ASR",
        "ASW",
        "AUG",
        "BBR0",
        "BBR1",
        "BBR2",
        "BBR3",
        "BBR4",
        "BBR5",
        "BBR6",
        "BBR7",
        "BBS0",
        "BBS1",
        "BBS2",
        "BBS3",
        "BBS4",
        "BBS5",
        "BBS6",
        "BBS7",
        "BCC",
        "BCS",
        "BEQ",
        "BIT",
        "BMI",
        "BNE",
        "BPL",
        "BRA",
        "BRK",
        "BSR",
        "BVC",
        "BVS",
        "CLC",
        "CLD",
        "CLE",
        "CLI",
        "CLV",
        "CMP",
        "CPX",
        "CPY",
        "CPZ",
        "DEC",
        "DEW",
        "DEX",
        "DEY",
        "DEZ",
        "EOR",
        "INC",
        "INW",
        "INX",
        "INY",
        "INZ",
        "JMP",
        "JSR",
        "LDA",
        "LDX",
        "LDY",
        "LDZ",
        "LSR",
        "NEG",
        "NOP",
        "ORA",
        "PHA",
        "PHP",
        "PHW",
        "PHX",
        "PHY",
        "PHZ",
        "PLA",
        "PLP",
        "PLX",
        "PLY",
        "PLZ",
        "RMB0",
        "RMB1",
        "RMB2",
        "RMB3",
        "RMB4",
        "RMB5",
        "RMB6",
        "RMB7",
        "ROL",
        "ROR",
        "ROW",
        "RTI",
        "RTN",
        "RTS",
        "SBC",
        "SEC",
        "SED",
        "SEE",
        "SEI",
        "SMB0",
        "SMB1",
        "SMB2",
        "SMB3",
        "SMB4",
        "SMB5",
        "SMB6",
        "SMB7",
        "STA",
        "STX",
        "STY",
        "STZ",
        "TAB",
        "TAX",
        "TAY",
        "TAZ",
        "TBA",
        "TRB",
        "TSB",
        "TSX",
        "TSY",
        "TXA",
        "TXS",
        "TYA",
        "TYS",
        "TZA"
      ],
      "illegal": [],
      "all": [
        "ADC",
        "AND",
        "ASL",
        "ASR",
        "ASW",
        "AUG",
        "BBR0",
        "BBR1",
        "BBR2",
        "BBR3",
        "BBR4",
        "BBR5",
        "BBR6",
        "BBR7",
        "BBS0",
        "BBS1",
        "BBS2",
        "BBS3",
        "BBS4",
        "BBS5",
        "BBS6",
        "BBS7",
        "BCC",
        "BCS",
        "BEQ",
        "BIT",
        "BMI",
        "BNE",
        "BPL",
        "BRA",
        "BRK",
        "BSR",
        "BVC",
        "BVS",
        "CLC",
        "CLD",
        "CLE",
        "CLI",
        "CLV",
        "CMP",
        "CPX",
        "CPY",
        "CPZ",
        "DEC",
        "DEW",
        "DEX",
        "DEY",
        "DEZ",
        "EOR",
        "INC",
        "INW",
        "INX",
        "INY",
        "INZ",
        "JMP",
        "JSR",
        "LDA",
        "LDX",
        "LDY",
        "LDZ",
        "LSR",
        "NEG",
        "NOP",
        "ORA",
        "PHA",
        "PHP",
        "PHW",
        "PHX",
        "PHY",
        "PHZ",
        "PLA",
        "PLP",
        "PLX",
        "PLY",
        "PLZ",
        "RMB0",
        "RMB1",
        "RMB2",
        "RMB3",
        "RMB4",
        "RMB5",
        "RMB6",
        "RMB7",
        "ROL",
        "ROR",
        "ROW",
        "RTI",
        "RTN",
        "RTS",
        "SBC",
        "SEC",
        "SED",
        "SEE",
        "SEI",
        "SMB0",
        "SMB1",
        "SMB2",
        "SMB3",
        "SMB4",
        "SMB5",
        "SMB6",
        "SMB7",
        "STA",
        "STX",
        "STY",
        "STZ",
        "TAB",
        "TAX",
        "TAY",
        "TAZ",
        "TBA",
        "TRB",
        "TSB",
        "TSX",
        "TSY",
        "TXA",
        "TXS",
        "TYA",
        "TYS",
        "TZA"
      ]
    },
    "all_addmodes": {
      "regular": [
        "-",
        "A",
        "#d8",
        "#d16",
        "a16",
        "a16,X",
        "a16,Y",
        "(a16)",
        "(a16,X)",
        "a8",
        "a8,X",
        "a8,Y",
        "(a8,X)",
        "(a8),Y",
        "(a8),Z",
        "r8",
        "r16",
        "a8,r8",
        "(a8,S),Y"
      ],
      "illegal": [],
      "all": [
        "-",
        "A",
        "#d8",
        "#d16",
        "a16",
        "a16,X",
        "a16,Y",
        "(a16)",
        "(a16,X)",
        "a8",
        "a8,X",
        "a8,Y",
        "(a8,X)",
        "(a8),Y",
        "(a8),Z",
        "r8",
        "r16",
        "a8,r8",
        "(a8,S),Y"
      ]
    }
  },
  "65c816": {
    "info": {
      "manufacturer": "WDC",
      "name": "65C816",
      "year": "1984",
      "id": "65c816",
      "basedon": "65c02",
      "description": "This is the original implementation of the 16 bit version of the 65C02 designed by Western Design Center, Inc. It supports all instructions of original WDC 65C02, and adds support support for 16 bit registers, 24 bit addresses, a relocatable zero page and stack-relative addressing, filling all 256 opcodes. (The timing information corresponds to native mode.)"
    },
    "registers": {
      "registers": [
        "A",
        "X",
        "Y",
        "P",
        "S",
        "DBR",
        "D",
        "K",
        "PC"
      ],
      "A": {
        "size": "16",
        "description": "Accumulator"
      },
      "X": {
        "size": "16",
        "description": "X Index Register"
      },
      "Y": {
        "size": "16",
        "description": "Y Index Register"
      },
      "S": {
        "size": "16",
        "description": "Stack Pointer"
      },
      "P": {
        "size": "8",
        "description": "Processor Status"
      },
      "PC": {
        "size": "16",
        "description": "Program Counter"
      },
      "DBR": {
        "size": "8",
        "description": "Data Bank Register"
      },
      "D": {
        "size": "16",
        "description": "Direct Page Register"
      },
      "K": {
        "size": "8",
        "description": "Program Bank Register"
      }
    },
    "vectors": {
      "FFFA": "NMI",
      "FFFC": "RESET",
      "FFFE": "IRQ",
      "00FFE4": "COP",
      "00FFE6": "BRK",
      "00FFE8": "ABORT",
      "00FFEA": "NMI",
      "00FFEE": "IRQ",
      "00FFFC": "RESET"
    },
    "flags": {
      "names": "NVMXDIZCE",
      "N": "Negative",
      "V": "Overflow",
      "M": "Accumulator/Memory Width",
      "X": "Index Register Width",
      "D": "Decimal",
      "I": "Interrupt Disable",
      "Z": "Zero",
      "C": "Carry",
      "E": "Emulation Mode"
    },
    "opcodes": [
      {
        "illegal": false,
        "mnemo": "BRK",
        "addmode": "-",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8,X)",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "COP",
        "addmode": "#d8",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a8,S",
        "cycles": "5-m",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "TSB",
        "addmode": "a8",
        "cycles": "7-2*m+w",
        "mincycles": 5,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a8",
        "cycles": "4-m+w",
        "mincycles": 3,
        "maxcycles": 5,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a8",
        "cycles": "7-2*m+w",
        "mincycles": 5,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "[a8]",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PHP",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "#m:d8/d16",
        "cycles": "3-m",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHD",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TSB",
        "addmode": "a16",
        "cycles": "8-2*m",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16",
        "cycles": "5-m",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a16",
        "cycles": "8-2*m",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a24",
        "cycles": "6-m",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BPL",
        "addmode": "r8",
        "cycles": "2+t",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "t"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8),Y",
        "cycles": "7-m+w-x+x*p",
        "mincycles": 5,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8)",
        "cycles": "6-m+w",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "(a8,S),Y",
        "cycles": "8-m",
        "mincycles": 7,
        "maxcycles": 8,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "TRB",
        "addmode": "a8",
        "cycles": "7-2*m+w",
        "mincycles": 5,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a8,X",
        "cycles": "5-m+w",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a8,X",
        "cycles": "8-2*m+w",
        "mincycles": 6,
        "maxcycles": 9,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "[a8],Y",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CLC",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16,Y",
        "cycles": "6-m-x+x*p",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TCS",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TRB",
        "addmode": "a16",
        "cycles": "8-2*m",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a16,X",
        "cycles": "6-m-x+x*p",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ASL",
        "addmode": "a16,X",
        "cycles": "9-2*m",
        "mincycles": 7,
        "maxcycles": 9,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ORA",
        "addmode": "a24,X",
        "cycles": "6-m",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "JSR",
        "addmode": "a16",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8,X)",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "JSL",
        "addmode": "a24",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a8,S",
        "cycles": "5-m",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a8",
        "cycles": "4-m+w",
        "mincycles": 3,
        "maxcycles": 5,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a8",
        "cycles": "4-m+w",
        "mincycles": 3,
        "maxcycles": 5,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a8",
        "cycles": "7-2*m+w",
        "mincycles": 5,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "[a8]",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PLP",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "#m:d8/d16",
        "cycles": "3-m",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PLD",
        "addmode": "-",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a16",
        "cycles": "5-m",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16",
        "cycles": "5-m",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a16",
        "cycles": "8-2*m",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a24",
        "cycles": "6-m",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BMI",
        "addmode": "r8",
        "cycles": "2+t",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "t"
        ]
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8),Y",
        "cycles": "7-m+w-x+x*p",
        "mincycles": 5,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8)",
        "cycles": "6-m+w",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "(a8,S),Y",
        "cycles": "8-m",
        "mincycles": 7,
        "maxcycles": 8,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a8,X",
        "cycles": "5-m+w",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a8,X",
        "cycles": "5-m+w",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a8,X",
        "cycles": "8-2*m+w",
        "mincycles": 6,
        "maxcycles": 9,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "[a8],Y",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SEC",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16,Y",
        "cycles": "6-m-x+x*p",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TSC",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "a16,X",
        "cycles": "6-m-x+x*p",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a16,X",
        "cycles": "6-m-x+x*p",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROL",
        "addmode": "a16,X",
        "cycles": "9-2*m",
        "mincycles": 7,
        "maxcycles": 9,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "AND",
        "addmode": "a24,X",
        "cycles": "6-m",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "RTI",
        "addmode": "-",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8,X)",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "WDM",
        "addmode": "#d8",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a8,S",
        "cycles": "5-m",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "MVP",
        "addmode": "src,dest",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a8",
        "cycles": "4-m+w",
        "mincycles": 3,
        "maxcycles": 5,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a8",
        "cycles": "7-2*m+w",
        "mincycles": 5,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "[a8]",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PHA",
        "addmode": "-",
        "cycles": "4-m",
        "mincycles": 3,
        "maxcycles": 4,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "#m:d8/d16",
        "cycles": "3-m",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHK",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "a16",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16",
        "cycles": "5-m",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a16",
        "cycles": "8-2*m",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a24",
        "cycles": "6-m",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BVC",
        "addmode": "r8",
        "cycles": "2+t",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "t"
        ]
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8),Y",
        "cycles": "7-m+w-x+x*p",
        "mincycles": 5,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8)",
        "cycles": "6-m+w",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "(a8,S),Y",
        "cycles": "8-m",
        "mincycles": 7,
        "maxcycles": 8,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "MVN",
        "addmode": "src,dest",
        "cycles": "7",
        "mincycles": 7,
        "maxcycles": 7,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a8,X",
        "cycles": "5-m+w",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a8,X",
        "cycles": "8-2*m+w",
        "mincycles": 6,
        "maxcycles": 9,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "[a8],Y",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CLI",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16,Y",
        "cycles": "6-m-x+x*p",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PHY",
        "addmode": "-",
        "cycles": "4-x",
        "mincycles": 3,
        "maxcycles": 4,
        "cyclesymbols": [
          "x"
        ]
      },
      {
        "illegal": false,
        "mnemo": "TCD",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "a24",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a16,X",
        "cycles": "6-m-x+x*p",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LSR",
        "addmode": "a16,X",
        "cycles": "9-2*m",
        "mincycles": 7,
        "maxcycles": 9,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "EOR",
        "addmode": "a24,X",
        "cycles": "6-m",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "RTS",
        "addmode": "-",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8,X)",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PER",
        "addmode": "#d8",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a8,S",
        "cycles": "5-m",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STZ",
        "addmode": "a8",
        "cycles": "4-m+w",
        "mincycles": 3,
        "maxcycles": 5,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a8",
        "cycles": "4-m+w",
        "mincycles": 3,
        "maxcycles": 5,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a8",
        "cycles": "7-2*m+w",
        "mincycles": 5,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "[a8]",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PLA",
        "addmode": "-",
        "cycles": "5-m",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "#m:d8/d16",
        "cycles": "3-m",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "A",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "RTL",
        "addmode": "-",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "(a16)",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16",
        "cycles": "5-m",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a16",
        "cycles": "8-2*m",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a24",
        "cycles": "6-m",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BVS",
        "addmode": "r8",
        "cycles": "2+t",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "t"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8),Y",
        "cycles": "7-m+w-x+x*p",
        "mincycles": 5,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8)",
        "cycles": "6-m+w",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "(a8,S),Y",
        "cycles": "8-m",
        "mincycles": 7,
        "maxcycles": 8,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STZ",
        "addmode": "a8,X",
        "cycles": "5-m+w",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a8,X",
        "cycles": "5-m+w",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a8,X",
        "cycles": "8-2*m+w",
        "mincycles": 6,
        "maxcycles": 9,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "[a8],Y",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SEI",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16,Y",
        "cycles": "6-m-x+x*p",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PLY",
        "addmode": "-",
        "cycles": "5-x",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "x"
        ]
      },
      {
        "illegal": false,
        "mnemo": "TDC",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "(a16,X)",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a16,X",
        "cycles": "6-m-x+x*p",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ROR",
        "addmode": "a16,X",
        "cycles": "9-2*m",
        "mincycles": 7,
        "maxcycles": 9,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "ADC",
        "addmode": "a24,X",
        "cycles": "6-m",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BRA",
        "addmode": "r8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8,X)",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BRL",
        "addmode": "r16",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a8,S",
        "cycles": "5-m",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a8",
        "cycles": "4-x+w",
        "mincycles": 3,
        "maxcycles": 5,
        "cyclesymbols": [
          "x",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a8",
        "cycles": "4-m+w",
        "mincycles": 3,
        "maxcycles": 5,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a8",
        "cycles": "4-x+w",
        "mincycles": 3,
        "maxcycles": 5,
        "cyclesymbols": [
          "x",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "[a8]",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "DEY",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "BIT",
        "addmode": "#m:d8/d16",
        "cycles": "3-m",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "TXA",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PHB",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a16",
        "cycles": "5-x",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "x"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16",
        "cycles": "5-m",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a16",
        "cycles": "5-x",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "x"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a24",
        "cycles": "6-m",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BCC",
        "addmode": "r8",
        "cycles": "2+t",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "t"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8),Y",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8)",
        "cycles": "6-m+w",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "(a8,S),Y",
        "cycles": "8-m",
        "mincycles": 7,
        "maxcycles": 8,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STY",
        "addmode": "a8,X",
        "cycles": "5-x+w",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "x",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a8,X",
        "cycles": "5-m+w",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STX",
        "addmode": "a8,Y",
        "cycles": "5-x+w",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "x",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "[a8],Y",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "TYA",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16,Y",
        "cycles": "6-m",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "TXS",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TXY",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "STZ",
        "addmode": "a16",
        "cycles": "5-m",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a16,X",
        "cycles": "6-m",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STZ",
        "addmode": "a16,X",
        "cycles": "6-m",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STA",
        "addmode": "a24,X",
        "cycles": "6-m",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "#x:d8/d16",
        "cycles": "3-x",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "x"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8,X)",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "#x:d8/d16",
        "cycles": "3-x",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "x"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a8,S",
        "cycles": "5-m",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a8",
        "cycles": "4-x+w",
        "mincycles": 3,
        "maxcycles": 5,
        "cyclesymbols": [
          "x",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a8",
        "cycles": "4-m+w",
        "mincycles": 3,
        "maxcycles": 5,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a8",
        "cycles": "4-x+w",
        "mincycles": 3,
        "maxcycles": 5,
        "cyclesymbols": [
          "x",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "[a8]",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "TAY",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "#m:d8/d16",
        "cycles": "3-m",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "TAX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "PLB",
        "addmode": "-",
        "cycles": "4",
        "mincycles": 4,
        "maxcycles": 4,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a16",
        "cycles": "5-x",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "x"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16",
        "cycles": "5-m",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a16",
        "cycles": "5-x",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "x"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a24",
        "cycles": "6-m",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BCS",
        "addmode": "r8",
        "cycles": "2+t",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "t"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8),Y",
        "cycles": "7-m+w-x+x*p",
        "mincycles": 5,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8)",
        "cycles": "6-m+w",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "(a8,S),Y",
        "cycles": "8-m",
        "mincycles": 7,
        "maxcycles": 8,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a8,X",
        "cycles": "5-x+w",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "x",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a8,X",
        "cycles": "5-m+w",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a8,Y",
        "cycles": "5-x+w",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "x",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "[a8],Y",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CLV",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16,Y",
        "cycles": "6-m-x+x*p",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "TSX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "TYX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "LDY",
        "addmode": "a16,X",
        "cycles": "6-2*x+x*p",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a16,X",
        "cycles": "6-m-x+x*p",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDX",
        "addmode": "a16,Y",
        "cycles": "6-2*x+x*p",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "LDA",
        "addmode": "a24,X",
        "cycles": "6-m",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "#x:d8/d16",
        "cycles": "3-x",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "x"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8,X)",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "REP",
        "addmode": "#d8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a8,S",
        "cycles": "5-m",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "a8",
        "cycles": "4-x+w",
        "mincycles": 3,
        "maxcycles": 5,
        "cyclesymbols": [
          "x",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a8",
        "cycles": "4-m+w",
        "mincycles": 3,
        "maxcycles": 5,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a8",
        "cycles": "7-2*m+w",
        "mincycles": 5,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "[a8]",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INY",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "#m:d8/d16",
        "cycles": "3-m",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "DEX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "WAI",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPY",
        "addmode": "a16",
        "cycles": "5-x",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "x"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16",
        "cycles": "5-m",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a16",
        "cycles": "8-2*m",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a24",
        "cycles": "6-m",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BNE",
        "addmode": "r8",
        "cycles": "2+t",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "t"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8),Y",
        "cycles": "7-m+w-x+x*p",
        "mincycles": 5,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8)",
        "cycles": "6-m+w",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "(a8,S),Y",
        "cycles": "8-m",
        "mincycles": 7,
        "maxcycles": 8,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PEI",
        "addmode": "a8",
        "cycles": "6+w",
        "mincycles": 6,
        "maxcycles": 7,
        "cyclesymbols": [
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a8,X",
        "cycles": "5-m+w",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a8,X",
        "cycles": "8-2*m+w",
        "mincycles": 6,
        "maxcycles": 9,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "[a8],Y",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CLD",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16,Y",
        "cycles": "6-m-x+x*p",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PHX",
        "addmode": "-",
        "cycles": "4-x",
        "mincycles": 3,
        "maxcycles": 4,
        "cyclesymbols": [
          "x"
        ]
      },
      {
        "illegal": false,
        "mnemo": "STP",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JMP",
        "addmode": "[a16]",
        "cycles": "6",
        "mincycles": 6,
        "maxcycles": 6,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a16,X",
        "cycles": "6-m-x+x*p",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "DEC",
        "addmode": "a16,X",
        "cycles": "9-2*m",
        "mincycles": 7,
        "maxcycles": 9,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CMP",
        "addmode": "a24,X",
        "cycles": "6-m",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "#x:d8/d16",
        "cycles": "3-x",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "x"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8,X)",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SEP",
        "addmode": "#d8",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a8,S",
        "cycles": "5-m",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "a8",
        "cycles": "4-x+w",
        "mincycles": 3,
        "maxcycles": 5,
        "cyclesymbols": [
          "x",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a8",
        "cycles": "4-m+w",
        "mincycles": 3,
        "maxcycles": 5,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a8",
        "cycles": "7-2*m+w",
        "mincycles": 5,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "[a8]",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INX",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "#m:d8/d16",
        "cycles": "3-m",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "NOP",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "XBA",
        "addmode": "-",
        "cycles": "3",
        "mincycles": 3,
        "maxcycles": 3,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "CPX",
        "addmode": "a16",
        "cycles": "5-x",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "x"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16",
        "cycles": "5-m",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a16",
        "cycles": "8-2*m",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a24",
        "cycles": "6-m",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "BEQ",
        "addmode": "r8",
        "cycles": "2+t",
        "mincycles": 2,
        "maxcycles": 3,
        "cyclesymbols": [
          "t"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8),Y",
        "cycles": "7-m+w-x+x*p",
        "mincycles": 5,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8)",
        "cycles": "6-m+w",
        "mincycles": 5,
        "maxcycles": 7,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "(a8,S),Y",
        "cycles": "8-m",
        "mincycles": 7,
        "maxcycles": 8,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PEA",
        "addmode": "#d8",
        "cycles": "5",
        "mincycles": 5,
        "maxcycles": 5,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a8,X",
        "cycles": "5-m+w",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a8,X",
        "cycles": "8-2*m+w",
        "mincycles": 6,
        "maxcycles": 9,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "[a8],Y",
        "cycles": "7-m+w",
        "mincycles": 6,
        "maxcycles": 8,
        "cyclesymbols": [
          "m",
          "w"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SED",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16,Y",
        "cycles": "6-m-x+x*p",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "PLX",
        "addmode": "-",
        "cycles": "5-x",
        "mincycles": 4,
        "maxcycles": 5,
        "cyclesymbols": [
          "x"
        ]
      },
      {
        "illegal": false,
        "mnemo": "XCE",
        "addmode": "-",
        "cycles": "2",
        "mincycles": 2,
        "maxcycles": 2,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "JSR",
        "addmode": "(a16,X)",
        "cycles": "8",
        "mincycles": 8,
        "maxcycles": 8,
        "cyclesymbols": []
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a16,X",
        "cycles": "6-m-x+x*p",
        "mincycles": 4,
        "maxcycles": 6,
        "cyclesymbols": [
          "m",
          "x",
          "x",
          "p"
        ]
      },
      {
        "illegal": false,
        "mnemo": "INC",
        "addmode": "a16,X",
        "cycles": "9-2*m",
        "mincycles": 7,
        "maxcycles": 9,
        "cyclesymbols": [
          "m"
        ]
      },
      {
        "illegal": false,
        "mnemo": "SBC",
        "addmode": "a24,X",
        "cycles": "6-m",
        "mincycles": 5,
        "maxcycles": 6,
        "cyclesymbols": [
          "m"
        ]
      }
    ],
    "operations": {
      "ADC": {
        "category": "arith",
        "flags": "NV----ZC",
        "description": "A + M + C → A, C"
      },
      "AND": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ∧ M → A"
      },
      "ASL": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C ← /M7...M0/ ← 0"
      },
      "BCC": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on C = 0"
      },
      "BCS": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on C = 1"
      },
      "BEQ": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on Z = 1"
      },
      "BIT": {
        "category": "logic",
        "flags": "NV----Z-",
        "description": "A ∧ M, M7 → N, M6 → V"
      },
      "BMI": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on N = 1"
      },
      "BNE": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on Z = 0"
      },
      "BPL": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on N = 0"
      },
      "BRK": {
        "category": "ctrl",
        "flags": "-----1--",
        "description": "PC + 2↓, [FFFE] → PCL, [FFFF] → PCH"
      },
      "BVC": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on V = 0"
      },
      "BVS": {
        "category": "bra",
        "flags": "--------",
        "description": "Branch on V = 1"
      },
      "CLC": {
        "category": "flags",
        "flags": "-------0",
        "description": "0 → C"
      },
      "CLD": {
        "category": "flags",
        "flags": "----0---",
        "description": "0 → D"
      },
      "CLI": {
        "category": "flags",
        "flags": "-----0--",
        "description": "0 → I"
      },
      "CLV": {
        "category": "flags",
        "flags": "-0------",
        "description": "0 → V"
      },
      "CMP": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "A - M"
      },
      "CPX": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "X - M"
      },
      "CPY": {
        "category": "arith",
        "flags": "N-----ZC",
        "description": "Y - M"
      },
      "DEC": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "M - 1 → M"
      },
      "DEX": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "X - 1 → X"
      },
      "DEY": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "Y - 1 → Y"
      },
      "EOR": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ⊻ M → A"
      },
      "INC": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "M + 1 → M"
      },
      "INX": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "X + 1 → X"
      },
      "INY": {
        "category": "inc",
        "flags": "N-----Z-",
        "description": "Y + 1 → Y"
      },
      "JMP": {
        "category": "ctrl",
        "flags": "--------",
        "description": "[PC + 1] → PCL, [PC + 2] → PCH"
      },
      "JSR": {
        "category": "ctrl",
        "flags": "--------",
        "description": "PC + 2↓, [PC + 1] → PCL, [PC + 2] → PCH"
      },
      "LDA": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → A"
      },
      "LDX": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → X"
      },
      "LDY": {
        "category": "load",
        "flags": "N-----Z-",
        "description": "M → Y"
      },
      "LSR": {
        "category": "shift",
        "flags": "0-----ZC",
        "description": "0 → /M7...M0/ → C"
      },
      "NOP": {
        "category": "nop",
        "flags": "--------",
        "description": "No operation"
      },
      "ORA": {
        "category": "logic",
        "flags": "N-----Z-",
        "description": "A ∨ M → A"
      },
      "PHA": {
        "category": "stack",
        "flags": "--------",
        "description": "A↓"
      },
      "PHP": {
        "category": "stack",
        "flags": "--------",
        "description": "P↓"
      },
      "PLA": {
        "category": "stack",
        "flags": "N-----Z-",
        "description": "A↑"
      },
      "PLP": {
        "category": "stack",
        "flags": "NV--DIZC",
        "description": "P↑"
      },
      "ROL": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C ← /M7...M0/ ← C"
      },
      "ROR": {
        "category": "shift",
        "flags": "N-----ZC",
        "description": "C → /M7...M0/ → C"
      },
      "RTI": {
        "category": "ctrl",
        "flags": "NV--DIZC",
        "description": "P↑ PC↑"
      },
      "RTS": {
        "category": "ctrl",
        "flags": "--------",
        "description": "PC↑, PC + 1 → PC"
      },
      "SBC": {
        "category": "arith",
        "flags": "NV----ZC",
        "description": "A - M - ~C → A"
      },
      "SEC": {
        "category": "flags",
        "flags": "-------1",
        "description": "1 → C"
      },
      "SED": {
        "category": "flags",
        "flags": "----1---",
        "description": "1 → D"
      },
      "SEI": {
        "category": "flags",
        "flags": "-----1--",
        "description": "1 → I"
      },
      "STA": {
        "category": "load",
        "flags": "--------",
        "description": "A → M"
      },
      "STX": {
        "category": "load",
        "flags": "--------",
        "description": "X → M"
      },
      "STY": {
        "category": "load",
        "flags": "--------",
        "description": "Y → M"
      },
      "TAX": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "A → X"
      },
      "TAY": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "A → Y"
      },
      "TSX": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "S → X"
      },
      "TXA": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "X → A"
      },
      "TXS": {
        "category": "trans",
        "flags": "--------",
        "description": "X → S"
      },
      "TYA": {
        "category": "trans",
        "flags": "N-----Z-",
        "description": "Y → A"
      },
      "#": {
        "category": "mnemos",
        "flags": "are",
        "description": "based on VICE"
      },
      "ANC": {
        "category": "arith",
        "flags": "*-----**",
        "description": "A ∧ M → A, N → C"
      },
      "ARR": {
        "category": "arith",
        "flags": "**----**",
        "description": "(A ∧ M) / 2 → A"
      },
      "ASR": {
        "category": "arith",
        "flags": "0-----**",
        "description": "(A ∧ M) / 2 → A"
      },
      "DCP": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M - 1 → M, A - M"
      },
      "ISC": {
        "category": "arith",
        "flags": "**----**",
        "description": "M + 1 → M, A - M → A"
      },
      "JAM": {
        "category": "kil",
        "flags": "--------",
        "description": "Stop execution"
      },
      "LAS": {
        "category": "load",
        "flags": "*-----*-",
        "description": "M ∧ S → A, X, S"
      },
      "LAX": {
        "category": "load",
        "flags": "*-----*-",
        "description": "M → A, X"
      },
      "RLA": {
        "category": "arith",
        "flags": "*-----**",
        "description": "C ← /M7...M0/ ← C, A ∧ M → A"
      },
      "RRA": {
        "category": "arith",
        "flags": "**----**",
        "description": "C → /M7...M0/ → C, A + M + C → A"
      },
      "SAX": {
        "category": "load",
        "flags": "--------",
        "description": "A ∧ X → M"
      },
      "SBX": {
        "category": "arith",
        "flags": "*-----**",
        "description": "(A ∧ X) - M → X"
      },
      "SHA": {
        "category": "load",
        "flags": "--------",
        "description": "A ∧ X ∧ V → M"
      },
      "SHS": {
        "category": "trans",
        "flags": "--------",
        "description": "A ∧ X → S, S ∧ (H + 1) → M"
      },
      "SHX": {
        "category": "load",
        "flags": "--------",
        "description": "X ∧ (H + 1) → M"
      },
      "SHY": {
        "category": "load",
        "flags": "--------",
        "description": "Y ∧ (H + 1) → M"
      },
      "SLO": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M * 2 → M, A ∨ M → A"
      },
      "SRE": {
        "category": "arith",
        "flags": "*-----**",
        "description": "M / 2 → M, A ⊻ M → A"
      },
      "XAA": {
        "category": "arith",
        "flags": "*-----*-",
        "description": "(A ∨ V) ∧ X ∧ M → A"
      },
      "BRA": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch Always"
      },
      "PHX": {
        "category": "stack",
        "flags": "--------",
        "description": "X↓"
      },
      "PHY": {
        "category": "stack",
        "flags": "--------",
        "description": "Y↑"
      },
      "PLX": {
        "category": "stack",
        "flags": "N-----Z-",
        "description": "X↑"
      },
      "PLY": {
        "category": "stack",
        "flags": "N-----Z-",
        "description": "Y↑"
      },
      "STZ": {
        "category": "load",
        "flags": "--------",
        "description": "0 → M"
      },
      "TRB": {
        "category": "logic",
        "flags": "------Z-",
        "description": "~A ∧ M → M"
      },
      "TSB": {
        "category": "logic",
        "flags": "------Z-",
        "description": "A ∨ M → M"
      },
      "BRL": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Branch always long"
      },
      "COP": {
        "category": "ctrl",
        "flags": "----01--",
        "description": "Co-processor empowerment"
      },
      "JSL": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Jump to subroutine long"
      },
      "MVN": {
        "category": "load",
        "flags": "--------",
        "description": "Move memory negative"
      },
      "MVP": {
        "category": "load",
        "flags": "--------",
        "description": "Move memory positive"
      },
      "PEA": {
        "category": "stack",
        "flags": "--------",
        "description": "Mw↓"
      },
      "PEI": {
        "category": "stack",
        "flags": "--------",
        "description": "Mw↓"
      },
      "PER": {
        "category": "stack",
        "flags": "--------",
        "description": "Mw↓"
      },
      "PHB": {
        "category": "stack",
        "flags": "--------",
        "description": "B↓"
      },
      "PHD": {
        "category": "stack",
        "flags": "--------",
        "description": "D↓"
      },
      "PHK": {
        "category": "stack",
        "flags": "--------",
        "description": "K↓"
      },
      "PLB": {
        "category": "stack",
        "flags": "*-----*-",
        "description": "B↑"
      },
      "PLD": {
        "category": "stack",
        "flags": "*-----*-",
        "description": "D↑"
      },
      "REP": {
        "category": "flags",
        "flags": "********",
        "description": "P ⊼ M → P"
      },
      "RTL": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Return from subroutine long"
      },
      "SEP": {
        "category": "flags",
        "flags": "********",
        "description": "P ∨ M → P"
      },
      "STP": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Stop the clock"
      },
      "TCD": {
        "category": "trans",
        "flags": "*-----*-",
        "description": "C → D"
      },
      "TCS": {
        "category": "trans",
        "flags": "--------",
        "description": "C → S"
      },
      "TDC": {
        "category": "trans",
        "flags": "*-----*-",
        "description": "D → C"
      },
      "TSC": {
        "category": "trans",
        "flags": "*-----*-",
        "description": "S → C"
      },
      "TXY": {
        "category": "trans",
        "flags": "*-----*-",
        "description": "T → Y"
      },
      "TYX": {
        "category": "trans",
        "flags": "*-----*-",
        "description": "Y → X"
      },
      "WAI": {
        "category": "ctrl",
        "flags": "--------",
        "description": "Wait for interrupt"
      },
      "WDM": {
        "category": "nop",
        "flags": "--------",
        "description": "Reserved for future expansion"
      },
      "XBA": {
        "category": "trans",
        "flags": "*-----*-",
        "description": "B ↔ A"
      },
      "XCE": {
        "category": "flags",
        "flags": "-------**",
        "description": "C ↔ E"
      }
    },
    "mnemos": {
      "ADC": {
        "description": "Add with Carry"
      },
      "AND": {
        "description": "Logical AND"
      },
      "ASL": {
        "description": "Arithmetic Shift Left"
      },
      "BCC": {
        "description": "Branch if Carry Clear"
      },
      "BCS": {
        "description": "Branch if Carry Set"
      },
      "BEQ": {
        "description": "Branch if Equal"
      },
      "BIT": {
        "description": "Bit Test"
      },
      "BMI": {
        "description": "Branch if Minus"
      },
      "BNE": {
        "description": "Branch if Not Equal"
      },
      "BPL": {
        "description": "Branch if Plus"
      },
      "BRK": {
        "description": "Force Interrupt"
      },
      "BVC": {
        "description": "Branch if Overflow Clear"
      },
      "BVS": {
        "description": "Branch if Overflow Set"
      },
      "CLC": {
        "description": "Clear Carry Flag"
      },
      "CLD": {
        "description": "Clear Decimal Mode"
      },
      "CLI": {
        "description": "Clear Interrupt Disable"
      },
      "CLV": {
        "description": "Clear Overflow Flag"
      },
      "CMP": {
        "description": "Compare"
      },
      "CPX": {
        "description": "Compare X Register"
      },
      "CPY": {
        "description": "Compare Y Register"
      },
      "DEC": {
        "description": "Decrement Memory"
      },
      "DEX": {
        "description": "Decrement X Register"
      },
      "DEY": {
        "description": "Decrement Y Register"
      },
      "EOR": {
        "description": "Exclusive OR"
      },
      "INC": {
        "description": "Increment Memory"
      },
      "INX": {
        "description": "Increment X Register"
      },
      "INY": {
        "description": "Increment Y Register"
      },
      "JMP": {
        "description": "Jump"
      },
      "JSR": {
        "description": "Jump to Subroutine"
      },
      "LDA": {
        "description": "Load Accumulator"
      },
      "LDX": {
        "description": "Load X Register"
      },
      "LDY": {
        "description": "Load Y Register"
      },
      "LSR": {
        "description": "Logical Shift Right"
      },
      "NOP": {
        "description": "No Operation"
      },
      "ORA": {
        "description": "Logical OR"
      },
      "PHA": {
        "description": "Push Accumulator"
      },
      "PHP": {
        "description": "Push Processor Status"
      },
      "PLA": {
        "description": "Pull Accumulator"
      },
      "PLP": {
        "description": "Pull Processor Status"
      },
      "ROL": {
        "description": "Rotate Left"
      },
      "ROR": {
        "description": "Rotate Right"
      },
      "RTI": {
        "description": "Return from Interrupt"
      },
      "RTS": {
        "description": "Return from Subroutine"
      },
      "SBC": {
        "description": "Subtract with Carry"
      },
      "SEC": {
        "description": "Set Carry Flag"
      },
      "SED": {
        "description": "Set Decimal Flag"
      },
      "SEI": {
        "description": "Set Interrupt Disable"
      },
      "STA": {
        "description": "Store Accumulator"
      },
      "STX": {
        "description": "Store X Register"
      },
      "STY": {
        "description": "Store Y Register"
      },
      "TAX": {
        "description": "Transfer Accumulator to X"
      },
      "TAY": {
        "description": "Transfer Accumulator to Y"
      },
      "TSX": {
        "description": "Transfer Stack Pointer to X"
      },
      "TXA": {
        "description": "Transfer X to Accumulator"
      },
      "TXS": {
        "description": "Transfer X to Stack Pointer"
      },
      "TYA": {
        "description": "Transfer Y to Accumulator"
      },
      "BRA": {
        "description": "Branch Always"
      },
      "PHX": {
        "description": "Push X Register"
      },
      "PHY": {
        "description": "Push Y Register"
      },
      "PLX": {
        "description": "Pull X Register"
      },
      "PLY": {
        "description": "Pull Y Register"
      },
      "STZ": {
        "description": "Store Zero"
      },
      "TRB": {
        "description": "Test and Reset Memory Bits"
      },
      "TSB": {
        "description": "Test and Set Memory Bits"
      },
      "BRL": {
        "description": "Branch Long"
      },
      "COP": {
        "description": "Coprocessor"
      },
      "JSL": {
        "description": "Jump to Subroutine Long"
      },
      "MVN": {
        "description": "Move Memory Negative"
      },
      "MVP": {
        "description": "Move Memory Positive"
      },
      "PEA": {
        "description": "Push Effective Address"
      },
      "PEI": {
        "description": "Push Effective Indirect Address"
      },
      "PER": {
        "description": "Push Effective Relative Address"
      },
      "PHB": {
        "description": "Push Data Bank Register"
      },
      "PHD": {
        "description": "Push Direct Register"
      },
      "PHK": {
        "description": "Push K Register"
      },
      "PLB": {
        "description": "Pull Data Bank Register"
      },
      "PLD": {
        "description": "Pull Direct Register"
      },
      "REP": {
        "description": "Reset Processor Status Bits"
      },
      "RTL": {
        "description": "Return From Subroutine Long"
      },
      "SEP": {
        "description": "Set Processor Status Bits"
      },
      "STP": {
        "description": "Stop the Clock"
      },
      "TCD": {
        "description": "Transfer C Accumulator to Direct Register"
      },
      "TCS": {
        "description": "Transfer C Accumulator to Stack Pointer"
      },
      "TDC": {
        "description": "Transfer Direct Register to C Accumulator"
      },
      "TSC": {
        "description": "Transfer Stack Pointer to C Accumulator"
      },
      "TXY": {
        "description": "Transfer X to Y"
      },
      "TYX": {
        "description": "Transfer Y to X"
      },
      "WAI": {
        "description": "Wait for Interrupt"
      },
      "WDM": {
        "description": "William D. Mensch, Jr."
      },
      "XBA": {
        "description": "Exchange B and A Accumulator"
      },
      "XCE": {
        "description": "Exchange Carry and Emulation Flags"
      }
    },
    "addmodes": {
      "-": {
        "bytes": "1",
        "syntax": "",
        "description": "Implied"
      },
      "A": {
        "bytes": "1",
        "syntax": "A",
        "description": "Accumulator"
      },
      "#d8": {
        "bytes": "2",
        "syntax": "#$nn",
        "description": "Immediate"
      },
      "a8": {
        "bytes": "2",
        "syntax": "$nn",
        "description": "Direct Page"
      },
      "a8,X": {
        "bytes": "2",
        "syntax": "$nn,X",
        "description": "X-Indexed Direct Page"
      },
      "a8,Y": {
        "bytes": "2",
        "syntax": "$nn,Y",
        "description": "Y-Indexed Direct Page"
      },
      "(a8,X)": {
        "bytes": "2",
        "syntax": "($nn,X)",
        "description": "X-Indexed Direct Page Indirect"
      },
      "(a8),Y": {
        "bytes": "2",
        "syntax": "($nn),Y",
        "description": "Direct Page Indirect Y-Indexed"
      },
      "a16": {
        "bytes": "3",
        "syntax": "$nnnn",
        "description": "Absolute"
      },
      "a16,X": {
        "bytes": "3",
        "syntax": "$nnnn,X",
        "description": "X-Indexed Absolute"
      },
      "a16,Y": {
        "bytes": "3",
        "syntax": "$nnnn,Y",
        "description": "Y-Indexed Absolute"
      },
      "(a16)": {
        "bytes": "3",
        "syntax": "($nnnn)",
        "description": "Absolute Indirect"
      },
      "r8": {
        "bytes": "2",
        "syntax": "$nnnn",
        "description": "Relative"
      },
      "(a8)": {
        "bytes": "2",
        "syntax": "($nn)",
        "description": "Zero Page Indirect"
      },
      "(a16,X)": {
        "bytes": "3",
        "syntax": "($nnnn,X)",
        "description": "Absolute X-Indexed Indirect"
      },
      "#m:d8/d16": {
        "bytes": "3-m",
        "syntax": "#$nn/$nnnn",
        "description": "Immediate (M)"
      },
      "#x:d8/d16": {
        "bytes": "3-x",
        "syntax": "#$nn/$nnnn",
        "description": "Immediate (X)"
      },
      "[a16]": {
        "bytes": "3",
        "syntax": "[$nnnn]",
        "description": "Absolute Indirect Long"
      },
      "[a8]": {
        "bytes": "2",
        "syntax": "[$nn]",
        "description": "Direct Page Indirect Long"
      },
      "[a8],Y": {
        "bytes": "2",
        "syntax": "[$nn],Y",
        "description": "Direct Page Indirect Y-Indexed Long"
      },
      "a24": {
        "bytes": "4",
        "syntax": "$nnnnnn",
        "description": "Absolute Long"
      },
      "a24,X": {
        "bytes": "4",
        "syntax": "$nnnnnn,X",
        "description": "Absolute X-Indexed Long"
      },
      "r16": {
        "bytes": "3",
        "syntax": "$nnnn",
        "description": "Relative (word)"
      },
      "src,dest": {
        "bytes": "3",
        "syntax": "$nn,$nn",
        "description": "Block Move"
      },
      "a8,S": {
        "bytes": "2",
        "syntax": "$nn,S",
        "description": "Stack Relative"
      },
      "(a8,S),Y": {
        "bytes": "2",
        "syntax": "($nn,S),Y",
        "description": "Stack Relative Indirect Y-Indexed"
      }
    },
    "all_mnemos": {
      "regular": [
        "ADC",
        "AND",
        "ASL",
        "BCC",
        "BCS",
        "BEQ",
        "BIT",
        "BMI",
        "BNE",
        "BPL",
        "BRA",
        "BRK",
        "BRL",
        "BVC",
        "BVS",
        "CLC",
        "CLD",
        "CLI",
        "CLV",
        "CMP",
        "COP",
        "CPX",
        "CPY",
        "DEC",
        "DEX",
        "DEY",
        "EOR",
        "INC",
        "INX",
        "INY",
        "JMP",
        "JSL",
        "JSR",
        "LDA",
        "LDX",
        "LDY",
        "LSR",
        "MVN",
        "MVP",
        "NOP",
        "ORA",
        "PEA",
        "PEI",
        "PER",
        "PHA",
        "PHB",
        "PHD",
        "PHK",
        "PHP",
        "PHX",
        "PHY",
        "PLA",
        "PLB",
        "PLD",
        "PLP",
        "PLX",
        "PLY",
        "REP",
        "ROL",
        "ROR",
        "RTI",
        "RTL",
        "RTS",
        "SBC",
        "SEC",
        "SED",
        "SEI",
        "SEP",
        "STA",
        "STP",
        "STX",
        "STY",
        "STZ",
        "TAX",
        "TAY",
        "TCD",
        "TCS",
        "TDC",
        "TRB",
        "TSB",
        "TSC",
        "TSX",
        "TXA",
        "TXS",
        "TXY",
        "TYA",
        "TYX",
        "WAI",
        "WDM",
        "XBA",
        "XCE"
      ],
      "illegal": [],
      "all": [
        "ADC",
        "AND",
        "ASL",
        "BCC",
        "BCS",
        "BEQ",
        "BIT",
        "BMI",
        "BNE",
        "BPL",
        "BRA",
        "BRK",
        "BRL",
        "BVC",
        "BVS",
        "CLC",
        "CLD",
        "CLI",
        "CLV",
        "CMP",
        "COP",
        "CPX",
        "CPY",
        "DEC",
        "DEX",
        "DEY",
        "EOR",
        "INC",
        "INX",
        "INY",
        "JMP",
        "JSL",
        "JSR",
        "LDA",
        "LDX",
        "LDY",
        "LSR",
        "MVN",
        "MVP",
        "NOP",
        "ORA",
        "PEA",
        "PEI",
        "PER",
        "PHA",
        "PHB",
        "PHD",
        "PHK",
        "PHP",
        "PHX",
        "PHY",
        "PLA",
        "PLB",
        "PLD",
        "PLP",
        "PLX",
        "PLY",
        "REP",
        "ROL",
        "ROR",
        "RTI",
        "RTL",
        "RTS",
        "SBC",
        "SEC",
        "SED",
        "SEI",
        "SEP",
        "STA",
        "STP",
        "STX",
        "STY",
        "STZ",
        "TAX",
        "TAY",
        "TCD",
        "TCS",
        "TDC",
        "TRB",
        "TSB",
        "TSC",
        "TSX",
        "TXA",
        "TXS",
        "TXY",
        "TYA",
        "TYX",
        "WAI",
        "WDM",
        "XBA",
        "XCE"
      ]
    },
    "all_addmodes": {
      "regular": [
        "-",
        "A",
        "#d8",
        "#m:d8/d16",
        "#x:d8/d16",
        "a16",
        "a16,X",
        "a16,Y",
        "(a16)",
        "(a16,X)",
        "a8",
        "a8,X",
        "a8,Y",
        "(a8)",
        "(a8,X)",
        "(a8),Y",
        "[a8]",
        "[a16]",
        "a24",
        "a24,X",
        "r8",
        "r16",
        "a8,S",
        "(a8,S),Y",
        "src,dest"
      ],
      "illegal": [],
      "all": [
        "-",
        "A",
        "#d8",
        "#m:d8/d16",
        "#x:d8/d16",
        "a16",
        "a16,X",
        "a16,Y",
        "(a16)",
        "(a16,X)",
        "a8",
        "a8,X",
        "a8,Y",
        "(a8)",
        "(a8,X)",
        "(a8),Y",
        "[a8]",
        "[a16]",
        "a24",
        "a24,X",
        "r8",
        "r16",
        "a8,S",
        "(a8,S),Y",
        "src,dest"
      ]
    }
  }
}
